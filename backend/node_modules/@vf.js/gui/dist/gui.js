(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/vf-gui.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/UI.ts":
/*!*******************!*\
  !*** ./src/UI.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Alert = exports.SyncManager = exports.Animation = exports.AnimationJitter = exports.PathGraphics = exports.NumberFrame = exports.Scheduler = exports.Enum = exports.Event = exports.SpriteAnimated = exports.Image = exports.Easing = exports.TimeLine = exports.Tween = exports.TickerShared = exports.DisplayObject = exports.Interaction = exports.Polygon = exports.ScrollBar = exports.ConnectLine = exports.Tracing = exports.FollowLine = exports.Graphics = exports.Isosceles = exports.Ellipse = exports.Arrow = exports.Star = exports.Circle = exports.Rect = exports.CheckBox = exports.Video = exports.Button = exports.TextInput = exports.Label = exports.Slider = exports.ScrollingContainer = exports.AutoContainer = exports.Container = exports.Stage = exports.Utils = exports.Filter = exports.Audio = void 0;
/** 工具类 */
var Utils = __webpack_require__(/*! ./utils/Utils */ "./src/utils/Utils.ts");
exports.Utils = Utils;
/** UI舞台，最顶级的层 展示所有UI组件 */
var Stage_1 = __webpack_require__(/*! ./core/Stage */ "./src/core/Stage.ts");
Object.defineProperty(exports, "Stage", { enumerable: true, get: function () { return Stage_1.Stage; } });
/** UI基础显示对象，一般不会直接使用，只作为类型推断 */
var DisplayObject_1 = __webpack_require__(/*! ./core/DisplayObject */ "./src/core/DisplayObject.ts");
Object.defineProperty(exports, "DisplayObject", { enumerable: true, get: function () { return DisplayObject_1.DisplayObject; } });
/** 心跳，需要在初始化完成后，启动心跳更新 */
var Ticker_1 = __webpack_require__(/*! ./core/Ticker */ "./src/core/Ticker.ts");
Object.defineProperty(exports, "TickerShared", { enumerable: true, get: function () { return Ticker_1.TickerShared; } });
/** 滤镜的基础类 */
var Filter_1 = __webpack_require__(/*! ./core/Filter */ "./src/core/Filter.ts");
Object.defineProperty(exports, "Filter", { enumerable: true, get: function () { return Filter_1.Filter; } });
/**
 * 基础容器
 *
 * 设置checkGroup后，进行分组。 分组后，可理解为复选框。
 *
 * @example let container = new vf.gui.Container();
 *
 */
var Container_1 = __webpack_require__(/*! ./display/Container */ "./src/display/Container.ts");
Object.defineProperty(exports, "Container", { enumerable: true, get: function () { return Container_1.Container; } });
/**
 * 滚动容器
 *
 * @example let scrollingContainer = new vf.gui.ScrollingContainer();
 *
 */
var ScrollingContainer_1 = __webpack_require__(/*! ./display/ScrollingContainer */ "./src/display/ScrollingContainer.ts");
Object.defineProperty(exports, "ScrollingContainer", { enumerable: true, get: function () { return ScrollingContainer_1.ScrollingContainer; } });
/**
 * 图片
 *
 * @example let image = new vf.gui.Image();
 *
 *
 */
var Image_1 = __webpack_require__(/*! ./display/Image */ "./src/display/Image.ts");
Object.defineProperty(exports, "Image", { enumerable: true, get: function () { return Image_1.Image; } });
/**
 * 序列图动画
 *
 * 支持使用texturepacker导出以及处理轴点
 *
 * @example let spriteAnimated = new vf.gui.SpriteAnimated();
 *
 */
var SpriteAnimated_1 = __webpack_require__(/*! ./display/SpriteAnimated */ "./src/display/SpriteAnimated.ts");
Object.defineProperty(exports, "SpriteAnimated", { enumerable: true, get: function () { return SpriteAnimated_1.SpriteAnimated; } });
/**
 * 文本
 *
 * 中文换行特殊处理 xxxx.style.breakWords = true;
 *
 * 文本没有宽高，自适应
 *
 * @example let label = new vf.gui.Label();
 *
 *
 */
var Label_1 = __webpack_require__(/*! ./display/Label */ "./src/display/Label.ts");
Object.defineProperty(exports, "Label", { enumerable: true, get: function () { return Label_1.Label; } });
/**
 * 文本输入
 *
 * @example let textInput = new vf.gui.TextInput(true|false);//单行或多行
 *
 *
 */
var TextInput_1 = __webpack_require__(/*! ./display/TextInput */ "./src/display/TextInput.ts");
Object.defineProperty(exports, "TextInput", { enumerable: true, get: function () { return TextInput_1.TextInput; } });
/**
 * 滑动条/进度条
 *
 * @example let slider = new vf.gui.Slider();
 *
 */
var Slider_1 = __webpack_require__(/*! ./display/Slider */ "./src/display/Slider.ts");
Object.defineProperty(exports, "Slider", { enumerable: true, get: function () { return Slider_1.Slider; } });
/**
 * 按钮
 *
 * @example let button = new vf.gui.Button();
 *
 */
var Button_1 = __webpack_require__(/*! ./display/Button */ "./src/display/Button.ts");
Object.defineProperty(exports, "Button", { enumerable: true, get: function () { return Button_1.Button; } });
/**
 * 单选\复选框
 *
 * 设置checkGroup后，进行分组。 分组后，可理解为复选框。
 *
 * @example let checkBox = new vf.gui.CheckBox();
 *
 *
 */
var CheckBox_1 = __webpack_require__(/*! ./display/CheckBox */ "./src/display/CheckBox.ts");
Object.defineProperty(exports, "CheckBox", { enumerable: true, get: function () { return CheckBox_1.CheckBox; } });
/**
 * 绘制矩形或圆角矩形
 *
 * @example let rect = new vf.gui.Rect();
 *
 *
 */
var Rect_1 = __webpack_require__(/*! ./display/Rect */ "./src/display/Rect.ts");
Object.defineProperty(exports, "Rect", { enumerable: true, get: function () { return Rect_1.Rect; } });
/**
 * 绘制矩形或圆角矩形
 *
 * @example let rect = new vf.gui.Circle();
 *
 *
 */
var Circle_1 = __webpack_require__(/*! ./display/Circle */ "./src/display/Circle.ts");
Object.defineProperty(exports, "Circle", { enumerable: true, get: function () { return Circle_1.Circle; } });
/**
 * 星型绘制
 *
 */
var Star_1 = __webpack_require__(/*! ./display/Star */ "./src/display/Star.ts");
Object.defineProperty(exports, "Star", { enumerable: true, get: function () { return Star_1.Star; } });
/**
 * 多边形绘制
 *
 */
var Polygon_1 = __webpack_require__(/*! ./display/Polygon */ "./src/display/Polygon.ts");
Object.defineProperty(exports, "Polygon", { enumerable: true, get: function () { return Polygon_1.Polygon; } });
/**
 * 箭头绘制
 *
 */
var Arrow_1 = __webpack_require__(/*! ./display/Arrow */ "./src/display/Arrow.ts");
Object.defineProperty(exports, "Arrow", { enumerable: true, get: function () { return Arrow_1.Arrow; } });
/**
 * 椭圆绘制
 *
 */
var Ellipse_1 = __webpack_require__(/*! ./display/Ellipse */ "./src/display/Ellipse.ts");
Object.defineProperty(exports, "Ellipse", { enumerable: true, get: function () { return Ellipse_1.Ellipse; } });
/**
 * 等腰绘制
 *
 */
var Isosceles_1 = __webpack_require__(/*! ./display/Isosceles */ "./src/display/Isosceles.ts");
Object.defineProperty(exports, "Isosceles", { enumerable: true, get: function () { return Isosceles_1.Isosceles; } });
/**
 * 矢量绘制
 *
 * @example let graphics = new vf.gui.Graphics();
 *
 *
 */
var Graphics_1 = __webpack_require__(/*! ./display/Graphics */ "./src/display/Graphics.ts");
Object.defineProperty(exports, "Graphics", { enumerable: true, get: function () { return Graphics_1.Graphics; } });
/**
 * 跟随划线（鼠标或触摸按下时）
 *
 * @example let graphics = new vf.gui.FollowLine();
 *
 *
 */
var FollowLine_1 = __webpack_require__(/*! ./display/FollowLine */ "./src/display/FollowLine.ts");
Object.defineProperty(exports, "FollowLine", { enumerable: true, get: function () { return FollowLine_1.FollowLine; } });
var Video_1 = __webpack_require__(/*! ./display/Video */ "./src/display/Video.ts");
Object.defineProperty(exports, "Video", { enumerable: true, get: function () { return Video_1.Video; } });
/**
 * 连线组件
 *
 *
 * @example let connectLine = new vf.gui.ConnectLine();
 *
 *
 */
var ConnectLine_1 = __webpack_require__(/*! ./display/ConnectLine */ "./src/display/ConnectLine.ts");
Object.defineProperty(exports, "ConnectLine", { enumerable: true, get: function () { return ConnectLine_1.ConnectLine; } });
/**
 * 临摹组件
 *
 * @example let Tracing = new vf.gui.Tracing();
 *
 */
var Tracing_1 = __webpack_require__(/*! ./display/Tracing */ "./src/display/Tracing.ts");
Object.defineProperty(exports, "Tracing", { enumerable: true, get: function () { return Tracing_1.Tracing; } });
/**
 * 滚动组件
 *
 * @example let scrollBar = new vf.gui.ScrollBar();
 *
 *
 */
var ScrollBar_1 = __webpack_require__(/*! ./display/ScrollBar */ "./src/display/ScrollBar.ts");
Object.defineProperty(exports, "ScrollBar", { enumerable: true, get: function () { return ScrollBar_1.ScrollBar; } });
/**
 * 完整的缓动曲线列表
 *
 * @example vf.gui.Easing.Linear.None;
 *
 *
 */
var Easing_1 = __webpack_require__(/*! ./tween/Easing */ "./src/tween/Easing.ts");
Object.defineProperty(exports, "Easing", { enumerable: true, get: function () { return Easing_1.Easing; } });
/**
 * 缓动动画
 *
 * @example let tween = new vf.gui.Tween(myObject).to({width:'300px'}, 2000).start()
 *
 *
 */
var Tween_1 = __webpack_require__(/*! ./tween/Tween */ "./src/tween/Tween.ts");
Object.defineProperty(exports, "Tween", { enumerable: true, get: function () { return Tween_1.Tween; } });
/**
 * 动画时间轴
 */
// import { TimeLineNew } from "./tween/TimeLine";
/**
 * 振动动画
 */
var AnimationJitter_1 = __webpack_require__(/*! ./display/animation/AnimationJitter */ "./src/display/animation/AnimationJitter.ts");
Object.defineProperty(exports, "AnimationJitter", { enumerable: true, get: function () { return AnimationJitter_1.AnimationJitter; } });
var Animation_1 = __webpack_require__(/*! ./display/animation/Animation */ "./src/display/animation/Animation.ts");
Object.defineProperty(exports, "Animation", { enumerable: true, get: function () { return Animation_1.Animation; } });
var Timeline_1 = __webpack_require__(/*! ./display/animation/Timeline */ "./src/display/animation/Timeline.ts");
Object.defineProperty(exports, "NumberFrame", { enumerable: true, get: function () { return Timeline_1.NumberFrame; } });
/**
 * 基于帧的时间轴控制类
 *
 * @example let timeline = new vf.gui.Timeline();
 *
 *
 */
var TimeLine_1 = __webpack_require__(/*! ./tween/TimeLine */ "./src/tween/TimeLine.ts");
Object.defineProperty(exports, "TimeLine", { enumerable: true, get: function () { return TimeLine_1.TimeLine; } });
/**
 * 音频
 *
 *
 *
 * 估计是能播放  没毛病
 *
 * @example let audio = new vf.gui.Audio(“地址或者是arrbuffer”);
 *
 *
 */
var Audio_1 = __webpack_require__(/*! ./display/Audio */ "./src/display/Audio.ts");
Object.defineProperty(exports, "Audio", { enumerable: true, get: function () { return Audio_1.Audio; } });
/**
 * 事件绑定类，非继承于inputbase的组件是没有任何交互事件，需单独绑定
 */
var Interaction = __webpack_require__(/*! ./interaction/Index */ "./src/interaction/Index.ts");
exports.Interaction = Interaction;
/**
 * 事件名
 */
var Event = __webpack_require__(/*! ./event/Index */ "./src/event/Index.ts");
exports.Event = Event;
/**
 * 枚举
 */
var Enum = __webpack_require__(/*! ./enum/Index */ "./src/enum/Index.ts");
exports.Enum = Enum;
var Scheduler_1 = __webpack_require__(/*! ./core/Scheduler */ "./src/core/Scheduler.ts");
Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function () { return Scheduler_1.Scheduler; } });
var SyncManager_1 = __webpack_require__(/*! ./interaction/SyncManager */ "./src/interaction/SyncManager.ts");
Object.defineProperty(exports, "SyncManager", { enumerable: true, get: function () { return SyncManager_1.SyncManager; } });
/**
 *  路线绘制
 */
var PathGraphics_1 = __webpack_require__(/*! ./display/PathGraphics */ "./src/display/PathGraphics.ts");
Object.defineProperty(exports, "PathGraphics", { enumerable: true, get: function () { return PathGraphics_1.PathGraphics; } });
var Alert_1 = __webpack_require__(/*! ./display/Alert */ "./src/display/Alert.ts");
Object.defineProperty(exports, "Alert", { enumerable: true, get: function () { return Alert_1.Alert; } });
/**
 * 自动容器
 */
var AutoContainer_1 = __webpack_require__(/*! ./display/AutoContainer */ "./src/display/AutoContainer.ts");
Object.defineProperty(exports, "AutoContainer", { enumerable: true, get: function () { return AutoContainer_1.AutoContainer; } });
window.PIXI = vf;


/***/ }),

/***/ "./src/core/Background.ts":
/*!********************************!*\
  !*** ./src/core/Background.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Background = void 0;
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var LineGradient_1 = __webpack_require__(/*! ./plugs/LineGradient */ "./src/core/plugs/LineGradient.ts");
var Background = /** @class */ (function () {
    function Background(parent) {
        this._oldRepeat = "";
        this._invalidateFlag = false;
        this.isInit = false;
        this._type = 0;
        this._color = undefined;
        this._alpha = 1;
        this._radius = 0;
        this._positionX = 0;
        this._positionY = 0;
        this._repeat = "no-repeat";
        this._fillAlpha = 1;
        this._fillGradientStops = [];
        this._fillGradientType = 1;
        this.parent = parent;
    }
    Object.defineProperty(Background.prototype, "type", {
        get: function () {
            return this._type;
        },
        set: function (value) {
            this._type = value;
            if (this._container === undefined) {
                this._container = new vf.Container();
                this._container.name = 'background';
                this.parent.container.addChildAt(this._container, 0);
                this._mask = new vf.Graphics();
                this.isInit = true;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color = value || undefined;
            if (value === 0) {
                this._color = 0;
            }
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "alpha", {
        get: function () {
            return this._alpha;
        },
        set: function (value) {
            this._alpha = value;
            if (this._container) {
                this._container.alpha = value;
            }
            else {
                this._invalidateFlag = true;
                this.parent.invalidateDisplayList();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "radius", {
        get: function () {
            return this._radius;
        },
        set: function (value) {
            this._radius = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "src", {
        get: function () {
            return this._src;
        },
        set: function (value) {
            this._src = value || undefined;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "positionX", {
        get: function () {
            return this._positionX;
        },
        set: function (value) {
            this._positionX = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "positionY", {
        get: function () {
            return this._positionY;
        },
        set: function (value) {
            this._positionY = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "size", {
        get: function () {
            return this._size;
        },
        set: function (value) {
            this._size = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "repeat", {
        get: function () {
            return this._repeat;
        },
        set: function (value) {
            this._repeat = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "fillColor", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            if (Array.isArray(value)) {
                if (Array.isArray(value[0])) {
                    if (this.canvas === undefined) {
                        this.canvas = document.createElement("canvas");
                        this.context = this.canvas.getContext("2d");
                        this.texture = vf.Texture.from(this.canvas);
                    }
                    this._color = value;
                    this._invalidateFlag = true;
                    return; // 多颜色渐变，不走color
                }
                this._fillAlpha = value[3] || 1;
                this.color = Utils_1.rgbToNumber(value[0], value[1], value[2]);
                return;
            }
            else {
                this.color = value || undefined;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "fillGradientStops", {
        get: function () {
            return this._fillGradientStops;
        },
        set: function (value) {
            this._fillGradientStops = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Background.prototype, "fillGradientType", {
        get: function () {
            return this._fillGradientType;
        },
        set: function (value) {
            this._fillGradientType = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Background.prototype.update = function (w, h) {
        if (this.lastW !== w || this.lastH !== h) {
            this._invalidateFlag = true;
            this.lastW = w;
            this.lastH = h;
        }
        if (!this._invalidateFlag) {
            return;
        }
        this._invalidateFlag = false;
        if (this._container === undefined) {
            return;
        }
        var _container = this._container;
        _container.alpha = this._alpha;
        if (this.type === 1) {
            if (this._image) {
                this.removeImage(this._image, _container);
            }
            var _a = this, _color = _a._color, _radius = _a._radius, _rect = _a._rect;
            if (_color === undefined && _rect && _rect.parent) {
                _container.removeChild(_rect);
                return;
            }
            if (this._rect === undefined) {
                this._rect = new vf.Graphics();
            }
            if (_color) {
                this.drawRect(this._rect, _color, w, h, _radius, this._fillAlpha);
                if (!this._rect.parent) {
                    _container.addChild(this._rect);
                }
            }
        }
        else if (this.type === 2) {
            if (this._mask === undefined) {
                return;
            }
            if (this._rect && this._rect.parent) {
                _container.removeChild(this._rect);
            }
            var _b = this, _repeat = _b._repeat, _src = _b._src, _size = _b._size, _mask = _b._mask;
            if ((this._oldRepeat != _repeat) || (this._oldSrc != _src)) {
                this._oldRepeat = _repeat;
                if (this._image) {
                    this._image.destroy();
                }
                switch (_repeat) {
                    case "no-repeat":
                        this._image = new vf.Sprite(Utils_1.getTexture(_src));
                        break;
                    case "repeat":
                        this._image = new vf.TilingSprite(Utils_1.getTexture(_src));
                        break;
                }
                if (this._image) {
                    this._image.mask = _mask;
                }
            }
            var image = this._image;
            if (image) {
                if (_src === undefined) {
                    this.removeImage(image, _container);
                    return;
                }
                if (image instanceof vf.TilingSprite) {
                    image.tilePosition.set(this._positionX, this._positionY);
                }
                else {
                    image.position.set(this._positionX, this._positionY);
                }
                this.drawRect(_mask, 0x000000, w, h, this._radius);
                if (_size !== undefined) {
                    image.width = _size[0];
                    image.height = _size[1];
                }
                else {
                    if (image.texture.width > 1) {
                        image.width = image.texture.width;
                        image.height = image.texture.height;
                    }
                }
                if (!_mask.parent) {
                    _container.addChild(_mask);
                }
                if (!image.parent) {
                    _container.addChild(image);
                }
            }
        }
    };
    Background.prototype.drawRect = function (bg, _color, w, h, _radius, _alpha) {
        if (_alpha === void 0) { _alpha = 1; }
        bg.clear();
        if (typeof _color === 'number') {
            bg.beginFill(_color, _alpha);
        }
        else {
            LineGradient_1.updateTextureFill(bg, {
                canvas: this.canvas,
                context: this.context,
                texture: this.texture,
                width: w,
                height: h,
                anchorX: 0,
                anchorY: 0,
                style: {
                    fillColor: _color,
                    fillGradientStops: this._fillGradientStops,
                    fillGradientType: this.fillGradientType
                }
            });
        }
        bg.drawRoundedRect(0, 0, w, h, _radius);
        bg.endFill();
    };
    Background.prototype.removeImage = function (image, _container) {
        if (this._mask && this._mask.parent) {
            _container.removeChild(this._mask);
        }
        if (image.parent) {
            _container.removeChild(image);
        }
    };
    Background.prototype.release = function () {
        if (this._mask && this._mask.parent) {
            this._mask.destroy();
        }
        if (this._image) {
            this._image.destroy();
            this._image = undefined;
        }
        if (this._rect) {
            this._rect.destroy();
            this._rect = undefined;
        }
        if (this.canvas) {
            this.canvas.height = this.canvas.width = 0;
            this.context = undefined;
            this.canvas = undefined;
        }
        if (this._container) {
            this._container.destroy();
            if (this._container.parent) {
                this._container.parent.removeChild(this._container);
            }
            this._container = undefined;
        }
        this._invalidateFlag = false;
        this._type = 0;
        this.parent = undefined;
    };
    return Background;
}());
exports.Background = Background;


/***/ }),

/***/ "./src/core/ContainerBase.ts":
/*!***********************************!*\
  !*** ./src/core/ContainerBase.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerBase = void 0;
/** 容器扩展类，后续便于做延时渲染 */
var ContainerBase = /** @class */ (function (_super) {
    __extends(ContainerBase, _super);
    function ContainerBase() {
        var _this = _super.call(this) || this;
        _this.isEmitRender = false;
        return _this;
    }
    ContainerBase.prototype.render = function (renderer) {
        if (this.isEmitRender) {
            this.emit("renderChange", renderer);
        }
        _super.prototype.render.call(this, renderer);
    };
    return ContainerBase;
}(vf.Container));
exports.ContainerBase = ContainerBase;


/***/ }),

/***/ "./src/core/DisplayLayoutAbstract.ts":
/*!*******************************************!*\
  !*** ./src/core/DisplayLayoutAbstract.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplayLayoutAbstract = exports.$tempLocalBounds = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
var UIKeys = __webpack_require__(/*! ./DisplayLayoutKeys */ "./src/core/DisplayLayoutKeys.ts");
var DisplayLayoutValidator_1 = __webpack_require__(/*! ./DisplayLayoutValidator */ "./src/core/DisplayLayoutValidator.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var DisplayObjectAbstract_1 = __webpack_require__(/*! ./DisplayObjectAbstract */ "./src/core/DisplayObjectAbstract.ts");
exports.$tempLocalBounds = new vf.Rectangle();
/**
 * UI 布局的基础属性类
 */
var DisplayLayoutAbstract = /** @class */ (function (_super) {
    __extends(DisplayLayoutAbstract, _super);
    function DisplayLayoutAbstract() {
        var _this = _super.call(this) || this;
        _this.isContainer = false;
        /**
         * @private
         */
        _this.$values = {};
        _this.initializeUIValues();
        return _this;
    }
    /**
     * @private
     * 定义的所有变量请不要添加任何初始值，必须统一在此处初始化。
     */
    DisplayLayoutAbstract.prototype.initializeUIValues = function () {
        var _a;
        this.$values = (_a = {},
            _a[UIKeys.invalidatePropertiesFlag] = true,
            _a[UIKeys.invalidateSizeFlag] = true,
            _a[UIKeys.invalidateDisplayListFlag] = true,
            _a[UIKeys.includeInLayout] = true,
            _a[UIKeys.left] = NaN,
            _a[UIKeys.right] = NaN,
            _a[UIKeys.top] = NaN,
            _a[UIKeys.bottom] = NaN,
            _a[UIKeys.horizontalCenter] = NaN,
            _a[UIKeys.verticalCenter] = NaN,
            _a[UIKeys.percentWidth] = NaN,
            _a[UIKeys.percentHeight] = NaN,
            _a[UIKeys.width] = NaN,
            _a[UIKeys.height] = NaN,
            _a[UIKeys.explicitWidth] = NaN,
            _a[UIKeys.explicitHeight] = NaN,
            _a[UIKeys.minWidth] = 0,
            _a[UIKeys.maxWidth] = 100000,
            _a[UIKeys.minHeight] = 0,
            _a[UIKeys.maxHeight] = 100000,
            _a[UIKeys.measuredWidth] = 0,
            _a[UIKeys.measuredHeight] = 0,
            _a[UIKeys.oldPreferWidth] = NaN,
            _a[UIKeys.oldPreferHeight] = NaN,
            _a);
    };
    /**
     * @private
     * 检查属性失效标记并应用
     */
    DisplayLayoutAbstract.prototype.checkInvalidateFlag = function () {
        var values = this.$values;
        if (values[UIKeys.invalidatePropertiesFlag]) {
            DisplayLayoutValidator_1.default.invalidateProperties(this);
        }
        if (values[UIKeys.invalidateSizeFlag]) {
            DisplayLayoutValidator_1.default.invalidateSize(this);
        }
        if (values[UIKeys.invalidateDisplayListFlag]) {
            DisplayLayoutValidator_1.default.invalidateDisplayList(this);
        }
        this.validateSize();
    };
    /**
     * @private
     * 验证组件的属性
     */
    DisplayLayoutAbstract.prototype.validateProperties = function () {
        var values = this.$values;
        if (values[UIKeys.invalidatePropertiesFlag]) {
            this.commitProperties();
            values[UIKeys.invalidatePropertiesFlag] = false;
        }
    };
    /**
     * @private
     * 验证组件的尺寸
     */
    DisplayLayoutAbstract.prototype.validateSize = function (recursive) {
        if (this.parent === undefined) {
            return;
        }
        if (recursive) {
            var children = this.uiChildren;
            if (children) {
                var length_1 = children.length;
                for (var i = 0; i < length_1; i++) {
                    var child = children[i];
                    child.validateSize(true);
                }
            }
        }
        var values = this.$values;
        if (values[UIKeys.invalidateSizeFlag]) {
            var changed = this.measureSizes();
            if (changed) {
                this.invalidateDisplayList();
                this.invalidateParentLayout();
            }
            values[UIKeys.invalidateSizeFlag] = false;
        }
    };
    /**
     * @private
     * 验证子项的位置和大小，并绘制其他可视内容
     */
    DisplayLayoutAbstract.prototype.validateDisplayList = function () {
        if (this.parent == undefined) {
            return;
        }
        var values = this.$values;
        if (values[UIKeys.invalidateDisplayListFlag]) {
            this.updateSize();
            this.updateDisplayList(this.width, this.height);
            this.updateBackground(this.width, this.height); // 需要计算完成布局后，设置
            this.updateMask(this.width, this.height);
            values[UIKeys.invalidateDisplayListFlag] = false;
        }
    };
    /**
     * @private
     * 提交属性，子类在调用完invalidateProperties()方法后，应覆盖此方法以应用属性
     */
    DisplayLayoutAbstract.prototype.commitProperties = function () {
        //
    };
    /**
     * 测量显示对象宽高，如果子类没有重写，默认是this.container.width..
     */
    DisplayLayoutAbstract.prototype.measure = function () {
        var values = this.$values;
        values[UIKeys.measuredWidth] = this.container.width;
        values[UIKeys.measuredHeight] = this.container.height;
    };
    /**
     * @private
     * 测量组件尺寸，返回尺寸是否发生变化
     */
    DisplayLayoutAbstract.prototype.measureSizes = function () {
        var changed = false;
        var values = this.$values;
        if (!values[UIKeys.invalidateSizeFlag]) {
            return changed;
        }
        var parent = this.parent;
        var parentWidth = parent ? parent.width : 1;
        var parentHeight = parent ? parent.height : 1;
        var maxWidth = Utils_1.formatRelative(values[UIKeys.maxWidth], parentWidth);
        var maxHeight = Utils_1.formatRelative(values[UIKeys.maxHeight], parentHeight);
        var minWidth = Utils_1.formatRelative(values[UIKeys.minWidth], parentWidth);
        var minHeight = Utils_1.formatRelative(values[UIKeys.minHeight], parentHeight);
        //显示设置宽高，会忽略最大与最小值  
        if (isNaN(values[UIKeys.explicitWidth]) || isNaN(values[UIKeys.explicitHeight])) {
            if (isNaN(values[UIKeys.percentWidth]) && isNaN(values[UIKeys.percentHeight])) {
                this.measure();
            }
            if (!isNaN(values[UIKeys.percentWidth])) {
                values[UIKeys.measuredWidth] = Math.ceil(values[UIKeys.percentWidth] * parentWidth);
            }
            if (!isNaN(values[UIKeys.percentHeight])) {
                values[UIKeys.measuredHeight] = Math.ceil(values[UIKeys.percentHeight] * parentHeight);
            }
            if (values[UIKeys.measuredWidth] < minWidth) {
                values[UIKeys.measuredWidth] = minWidth;
            }
            if (values[UIKeys.measuredWidth] > maxWidth) {
                values[UIKeys.measuredWidth] = maxWidth;
            }
            if (values[UIKeys.measuredHeight] < minHeight) {
                values[UIKeys.measuredHeight] = minHeight;
            }
            if (values[UIKeys.measuredHeight] > maxHeight) {
                values[UIKeys.measuredHeight] = maxHeight;
            }
        }
        else {
            if (values[UIKeys.explicitWidth] < minWidth) {
                values[UIKeys.explicitWidth] = minWidth;
            }
            if (values[UIKeys.explicitWidth] > maxWidth) {
                values[UIKeys.explicitWidth] = maxWidth;
            }
            if (values[UIKeys.explicitHeight] < minHeight) {
                values[UIKeys.explicitHeight] = minHeight;
            }
            if (values[UIKeys.explicitHeight] > maxHeight) {
                values[UIKeys.explicitHeight] = maxHeight;
            }
        }
        var preferredW = this.getPreferredUWidth();
        var preferredH = this.getPreferredUHeight();
        if (preferredW !== values[UIKeys.oldPreferWidth] ||
            preferredH !== values[UIKeys.oldPreferHeight]) {
            values[UIKeys.oldPreferWidth] = preferredW;
            values[UIKeys.oldPreferHeight] = preferredH;
            values[UIKeys.width] = preferredW;
            values[UIKeys.height] = preferredH;
            changed = true;
        }
        return changed;
    };
    /**
     * @private
     *
     * @returns
     */
    DisplayLayoutAbstract.prototype.getPreferredUWidth = function () {
        var values = this.$values;
        if (isNaN(values[UIKeys.explicitWidth])) {
            return values[UIKeys.measuredWidth];
        }
        return values[UIKeys.explicitWidth];
    };
    /**
     * @private
     */
    DisplayLayoutAbstract.prototype.getPreferredUHeight = function () {
        var values = this.$values;
        if (isNaN(values[UIKeys.explicitHeight])) {
            return values[UIKeys.measuredHeight];
        }
        return values[UIKeys.explicitHeight];
    };
    /**
     * @private
     * 获取组件的首选尺寸,常用于父级的measure()方法中
     * 按照：外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸，
     */
    DisplayLayoutAbstract.prototype.getPreferredBounds = function (bounds) {
        bounds.width = this.getPreferredUWidth();
        bounds.height = this.getPreferredUHeight();
        bounds.x = this.container.x;
        bounds.y = this.container.y;
        return bounds;
    };
    /**
    * @private
    * 标记提交过需要延迟应用的属性，以便在稍后屏幕更新期间调用该组件的 commitProperties() 方法。
    *
    * 例如，要更改文本颜色和大小，如果在更改颜色后立即进行更新，然后在设置大小后再更新大小，就有些浪费。
    * 同时更改两个属性后再使用新的大小和颜色一次性呈示文本，效率会更高。<p/>
    *
    * 通常，子类应覆盖 commitProperties() 方法，而不是覆盖此方法。
     */
    DisplayLayoutAbstract.prototype.invalidateProperties = function () {
        var values = this.$values;
        if (!values[UIKeys.invalidatePropertiesFlag]) {
            values[UIKeys.invalidatePropertiesFlag] = true;
            DisplayLayoutValidator_1.default.invalidateProperties(this);
        }
    };
    /**
    * @private
    * 标记提交过需要验证组件尺寸，以便在稍后屏幕更新期间调用该组件的 measure(),updatesize() 方法。
    */
    DisplayLayoutAbstract.prototype.invalidateSize = function () {
        var values = this.$values;
        if (!values[UIKeys.invalidateSizeFlag]) {
            values[UIKeys.invalidateSizeFlag] = true;
            DisplayLayoutValidator_1.default.invalidateSize(this);
        }
    };
    /**
    * @private
    * 标记需要验证显示列表，以便在稍后屏幕更新期间调用该组件的 updateDisplayList() 方法。
    */
    DisplayLayoutAbstract.prototype.invalidateDisplayList = function () {
        var values = this.$values;
        if (!values[UIKeys.invalidateDisplayListFlag]) {
            values[UIKeys.invalidateDisplayListFlag] = true;
            DisplayLayoutValidator_1.default.invalidateDisplayList(this);
        }
    };
    /**
     * @private
     * 标记父级容器的尺寸和显示列表为失效
     */
    DisplayLayoutAbstract.prototype.invalidateParentLayout = function () {
        var parent = this.parent;
        if (!parent || !this.$values[UIKeys.includeInLayout]) {
            return;
        }
        if (parent instanceof DisplayLayoutAbstract) {
            parent.invalidateSize();
            parent.invalidateDisplayList();
        }
    };
    /**
     * @private
     * 设置组件的布局位置
     */
    DisplayLayoutAbstract.prototype.setPosition = function (x, y) {
        this.container.position.set(x, y);
        this.emit(Index_1.ComponentEvent.MOVE, this);
    };
    /**
     * @private
     * 设置测量结果。
     * @param width 测量宽度
     * @param height 测量高度
     */
    DisplayLayoutAbstract.prototype.setMeasuredSize = function (width, height) {
        var values = this.$values;
        values[UIKeys.measuredWidth] = Math.ceil(+width || 0);
        values[UIKeys.measuredHeight] = Math.ceil(+height || 0);
    };
    /**
     * @private
     * 设置组件的宽高。此方法不同于直接设置width,height属性，
     * 不会影响显式标记尺寸属性
     */
    DisplayLayoutAbstract.prototype.setActualSize = function (w, h, isInvalidate) {
        if (isInvalidate === void 0) { isInvalidate = true; }
        var change = false;
        var values = this.$values;
        if (values[UIKeys.width] !== w) {
            values[UIKeys.width] = w;
            change = true;
        }
        if (values[UIKeys.height] !== h) {
            values[UIKeys.height] = h;
            change = true;
        }
        if (change && isInvalidate) {
            this.invalidateDisplayList();
            this.emit(Index_1.ComponentEvent.RESIZE, this);
        }
    };
    DisplayLayoutAbstract.prototype.updateTransform = function () {
        this.container.setTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation * (Math.PI / 180), this.skewX, this.skewY, this.pivotX, this.pivotY);
    };
    /**
     * 更新背景
     */
    DisplayLayoutAbstract.prototype.updateBackground = function (unscaledWidth, unscaledHeight) {
        this.$background.update(unscaledWidth, unscaledHeight);
    };
    /**
     * 更新遮罩
     */
    DisplayLayoutAbstract.prototype.updateMask = function (unscaledWidth, unscaledHeight) {
        this.$mask.update(unscaledWidth, unscaledHeight);
    };
    /**
     * @private
     * 更新最终的组件宽高
     */
    DisplayLayoutAbstract.prototype.updateSize = function () {
        this.setActualSize(this.getPreferredUWidth(), this.getPreferredUHeight());
    };
    /**
     * 更新显示列表,子类重写，实现布局
     */
    DisplayLayoutAbstract.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        //
    };
    /**
     * @private
     * 立即应用组件及其子项的所有属性
     */
    DisplayLayoutAbstract.prototype.validateNow = function () {
        if (this.parent)
            DisplayLayoutValidator_1.default.validateClient(this);
    };
    /**
     * @private
    * 验证并更新此对象的属性和布局，如果需要的话重绘对象。
    *
    * 通常只有当脚本执行完毕后，才会处理要求进行大量计算的处理属性。<p/>
    *
    * 例如，对 width 属性的设置可能会延迟，因为此设置需要重新计算这些对象的子项或父项的宽度。
    * 如果脚本多次设置了 width 属性，则延迟处理可防止进行多次处理。此方法允许您手动覆盖此行为。
     */
    DisplayLayoutAbstract.prototype.validateSizeNow = function () {
        this.validateSize(true);
        this.updateSize();
    };
    Object.defineProperty(DisplayLayoutAbstract.prototype, "includeInLayout", {
        /**
         * 指定此组件是否包含在父容器的布局中。若为false，则父级容器在测量和布局阶段都忽略此组件。默认值为true。
         * 注意，visible属性与此属性不同，设置visible为false，父级容器仍会对其布局。
         */
        get: function () {
            return this.$values[UIKeys.includeInLayout];
        },
        set: function (value) {
            var values = this.$values;
            value = !!value;
            if (values[UIKeys.includeInLayout] === value)
                return;
            values[UIKeys.includeInLayout] = true;
            this.invalidateParentLayout();
            values[UIKeys.includeInLayout] = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "left", {
        /**
         * @private
         * 距父级容器离左边距离
         */
        get: function () {
            return this.$values[UIKeys.left];
        },
        set: function (value) {
            if (!value || typeof value == "number") {
                value = +value;
            }
            else {
                value = value.toString().trim();
            }
            var values = this.$values;
            if (values[UIKeys.left] === value)
                return;
            values[UIKeys.left] = value;
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "right", {
        /**
         * @private
         * 距父级容器右边距离
         */
        get: function () {
            return this.$values[UIKeys.right];
        },
        set: function (value) {
            if (!value || typeof value == "number") {
                value = +value;
            }
            else {
                value = value.toString().trim();
            }
            var values = this.$values;
            if (values[UIKeys.right] === value)
                return;
            values[UIKeys.right] = value;
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "top", {
        /**
         * @private
         * 距父级容器顶部距离
         */
        get: function () {
            return this.$values[UIKeys.top];
        },
        set: function (value) {
            if (!value || typeof value == "number") {
                value = +value;
            }
            else {
                value = value.toString().trim();
            }
            var values = this.$values;
            if (values[UIKeys.top] === value)
                return;
            values[UIKeys.top] = value;
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "bottom", {
        /**
         * @private
         * 距父级容器底部距离
         */
        get: function () {
            return this.$values[UIKeys.bottom];
        },
        set: function (value) {
            if (!value || typeof value == "number") {
                value = +value;
            }
            else {
                value = value.toString().trim();
            }
            var values = this.$values;
            if (values[UIKeys.bottom] == value)
                return;
            values[UIKeys.bottom] = value;
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "horizontalCenter", {
        /**
         * @private
         * 在父级容器中距水平中心位置的距离
         */
        get: function () {
            return this.$values[UIKeys.horizontalCenter];
        },
        set: function (value) {
            if (!value || typeof value == "number") {
                value = +value;
            }
            else {
                value = value.toString().trim();
            }
            var values = this.$values;
            if (values[UIKeys.horizontalCenter] === value)
                return;
            values[UIKeys.horizontalCenter] = value;
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "verticalCenter", {
        /**
         * @private
         * 在父级容器中距竖直中心位置的距离
         */
        get: function () {
            return this.$values[UIKeys.verticalCenter];
        },
        set: function (value) {
            if (!value || typeof value == "number") {
                value = +value;
            }
            else {
                value = value.toString().trim();
            }
            var values = this.$values;
            if (values[UIKeys.verticalCenter] === value)
                return;
            values[UIKeys.verticalCenter] = value;
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "percentWidth", {
        /**
         * @private
         * 相对父级容器宽度的百分比
         */
        get: function () {
            return this.$values[UIKeys.percentWidth];
        },
        set: function (value) {
            value = +value;
            var values = this.$values;
            if (values[UIKeys.percentWidth] === value)
                return;
            values[UIKeys.percentWidth] = value;
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "percentHeight", {
        /**
         * @private
         * 相对父级容器高度的百分比
         */
        get: function () {
            return this.$values[UIKeys.percentHeight];
        },
        set: function (value) {
            value = +value;
            var values = this.$values;
            if (values[UIKeys.percentHeight] === value)
                return;
            values[UIKeys.percentHeight] = value;
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "explicitWidth", {
        /**
         * @private
         * 外部显式指定的宽度
         */
        get: function () {
            return this.$values[UIKeys.explicitWidth];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "explicitHeight", {
        /**
         * @private
         * 外部显式指定的高度
         */
        get: function () {
            return this.$values[UIKeys.explicitHeight];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "minWidth", {
        /**
         * @private
         * 组件的最小宽度,此属性设置为大于maxWidth的值时无效。同时影响测量和自动布局的尺寸。
         */
        get: function () {
            return this.$values[UIKeys.minWidth];
        },
        set: function (value) {
            value = +value || 0;
            var values = this.$values;
            if (value < 0 || values[UIKeys.minWidth] === value) {
                return;
            }
            values[UIKeys.minWidth] = value;
            this.invalidateSize();
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "maxWidth", {
        /**
         * @private
         * 组件的最大高度。同时影响测量和自动布局的尺寸。
         */
        get: function () {
            return this.$values[UIKeys.maxWidth];
        },
        set: function (value) {
            value = +value || 0;
            var values = this.$values;
            if (value < 0 || values[UIKeys.maxWidth] === value) {
                return;
            }
            values[UIKeys.maxWidth] = value;
            this.invalidateSize();
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "minHeight", {
        /**
         * @private
         * 组件的最小高度,此属性设置为大于maxHeight的值时无效。同时影响测量和自动布局的尺寸。
         */
        get: function () {
            return this.$values[UIKeys.minHeight];
        },
        set: function (value) {
            value = +value || 0;
            var values = this.$values;
            if (value < 0 || values[UIKeys.minHeight] === value) {
                return;
            }
            values[UIKeys.minHeight] = value;
            this.invalidateSize();
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "maxHeight", {
        /**
         * @private
         * 组件的最大高度,同时影响测量和自动布局的尺寸。
         */
        get: function () {
            return this.$values[UIKeys.maxHeight];
        },
        set: function (value) {
            value = +value || 0;
            var values = this.$values;
            if (value < 0 || values[UIKeys.maxHeight] === value) {
                return;
            }
            values[UIKeys.maxHeight] = value;
            this.invalidateSize();
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    DisplayLayoutAbstract.prototype.allInvalidate = function () {
        this.invalidateProperties();
        this.invalidateSize();
        this.invalidateDisplayList();
        this.invalidateParentLayout();
    };
    Object.defineProperty(DisplayLayoutAbstract.prototype, "width", {
        /**
         * @private
         * 组件宽度设置为undefined将使用组件的measure()方法自动计算尺寸
         */
        get: function () {
            var v = this.$values;
            if (this.getPreferredUWidth() !== v[UIKeys.width]) {
                this.validateSize();
            }
            return v[UIKeys.width];
        },
        /**
         * @private
         *
         * @param value
         */
        set: function (value) {
            value = +value;
            var values = this.$values;
            if (value < 0 || values[UIKeys.explicitWidth] === value)
                return;
            values[UIKeys.explicitWidth] = value;
            this.emit(Index_1.ComponentEvent.WIDTH_CHANGE, value);
            this.invalidateSize();
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "height", {
        /**
         * @private
         * 组件高度,默认值为NaN,设置为NaN将使用组件的measure()方法自动计算尺寸
         */
        get: function () {
            var v = this.$values;
            if (this.getPreferredUHeight() !== v[UIKeys.height]) {
                this.validateSize();
            }
            return v[UIKeys.height];
        },
        /**
         * @private
         *
         * @param value
         */
        set: function (value) {
            value = +value;
            var values = this.$values;
            if (value < 0 || values[UIKeys.explicitHeight] === value)
                return;
            values[UIKeys.explicitHeight] = value;
            this.invalidateSize();
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "scaleX", {
        get: function () {
            return this.container.scale.x;
        },
        set: function (value) {
            // this.invalidateSize();
            // this.invalidateParentLayout();
            this.container.scale.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "scaleY", {
        get: function () {
            return this.container.scale.y;
        },
        set: function (value) {
            // this.invalidateSize();
            // this.invalidateParentLayout();
            this.container.scale.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "x", {
        get: function () {
            return this.container.x;
        },
        set: function (value) {
            // this.invalidateDisplayList();
            // this.invalidateParentLayout();
            this.container.position.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "y", {
        get: function () {
            return this.container.y;
        },
        set: function (value) {
            // this.invalidateDisplayList();
            // this.invalidateParentLayout();
            this.container.position.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "skewX", {
        get: function () {
            return this.container.skew.x;
        },
        set: function (value) {
            // this.invalidateDisplayList();
            this.container.skew.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "skewY", {
        get: function () {
            return this.container.skew.y;
        },
        set: function (value) {
            // this.invalidateDisplayList();
            this.container.skew.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "pivotX", {
        get: function () {
            return this.container.pivot.x;
        },
        set: function (value) {
            // this.invalidateDisplayList();
            this.container.pivot.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "pivotY", {
        get: function () {
            return this.container.pivot.y;
        },
        set: function (value) {
            // this.invalidateDisplayList();
            this.container.pivot.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "rotation", {
        get: function () {
            return this.container.angle;
        },
        set: function (value) {
            // this.invalidateDisplayList();
            this.container.angle = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayLayoutAbstract.prototype, "zIndex", {
        /**
         *  =不可用= 设置索引层级，每次父级变化时，会排序 （未实现）
         */
        get: function () {
            return this.container.zIndex;
        },
        set: function (value) {
            // this.invalidateParentLayout();
            if (this.parent && this.parent.isContainer && !this.parent.container.sortableChildren) {
                this.parent.container.sortableChildren = true;
            }
            this.container.zIndex = value;
        },
        enumerable: false,
        configurable: true
    });
    return DisplayLayoutAbstract;
}(DisplayObjectAbstract_1.DisplayObjectAbstract));
exports.DisplayLayoutAbstract = DisplayLayoutAbstract;


/***/ }),

/***/ "./src/core/DisplayLayoutKeys.ts":
/*!***************************************!*\
  !*** ./src/core/DisplayLayoutKeys.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.verticalCenter = exports.horizontalCenter = exports.bottom = exports.top = exports.right = exports.left = exports.oldPreferHeight = exports.oldPreferWidth = exports.measuredHeight = exports.measuredWidth = exports.percentHeight = exports.percentWidth = exports.maxHeight = exports.minHeight = exports.maxWidth = exports.minWidth = exports.explicitHeight = exports.explicitWidth = exports.height = exports.width = exports.includeInLayout = exports.invalidateDisplayListFlag = exports.invalidateSizeFlag = exports.invalidatePropertiesFlag = void 0;
//states
/**
 * 兼容处理，不支持的浏览器，使用description
 * @param description
 */
function getSymbol(description) {
    return Symbol(description) || description;
}
/** 标记属性失效 */
exports.invalidatePropertiesFlag = getSymbol("invalidatePropertiesFlag");
/** 标记大小失效 */
exports.invalidateSizeFlag = getSymbol("invalidateSizeFlag");
/** 标记显示失效 */
exports.invalidateDisplayListFlag = getSymbol("invalidateDisplayListFlag");
/** 是否参与布局 */
exports.includeInLayout = getSymbol("includeInLayout");
//Properties
exports.width = getSymbol("width");
exports.height = getSymbol("height");
exports.explicitWidth = getSymbol("explicitWidth");
exports.explicitHeight = getSymbol("explicitHeight");
exports.minWidth = getSymbol("minWidth");
exports.maxWidth = getSymbol("maxWidth");
exports.minHeight = getSymbol("minHeight");
exports.maxHeight = getSymbol("maxHeight");
exports.percentWidth = getSymbol("percentWidth");
exports.percentHeight = getSymbol("percentHeight");
// export const scaleX = getSymbol("scaleX");
// export const scaleY = getSymbol("scaleY");
exports.measuredWidth = getSymbol("measuredWidth");
exports.measuredHeight = getSymbol("measuredHeight");
exports.oldPreferWidth = getSymbol("oldPreferWidth");
exports.oldPreferHeight = getSymbol("oldPreferHeight");
//Styles
exports.left = getSymbol("left");
exports.right = getSymbol("right");
exports.top = getSymbol("top");
exports.bottom = getSymbol("bottom");
exports.horizontalCenter = getSymbol("horizontalCenter");
exports.verticalCenter = getSymbol("verticalCenter");


/***/ }),

/***/ "./src/core/DisplayLayoutValidator.ts":
/*!********************************************!*\
  !*** ./src/core/DisplayLayoutValidator.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Ticker_1 = __webpack_require__(/*! ./Ticker */ "./src/core/Ticker.ts");
/**
 * @private
 * 列表项
 */
var DepthBin = /** @class */ (function () {
    function DepthBin() {
        this.map = {};
        this.items = [];
        this.length = 0;
    }
    DepthBin.prototype.insert = function (client) {
        var hashCode = client.uuid;
        if (this.map[hashCode]) {
            return;
        }
        this.map[hashCode] = true;
        this.length++;
        this.items.push(client);
    };
    DepthBin.prototype.pop = function () {
        var client = this.items.pop(); //使用pop会比shift有更高的性能，避免索引整体重置。
        if (client) {
            this.length--;
            if (this.length === 0) {
                this.map = {}; //清空所有key防止内存泄露
            }
            else {
                this.map[client.uuid] = false;
            }
        }
        return client;
    };
    DepthBin.prototype.remove = function (client) {
        var index = this.items.indexOf(client);
        if (index >= 0) {
            this.items.splice(index, 1);
            this.length--;
            if (this.length === 0) {
                this.map = {}; //清空所有key防止内存泄露
            }
            else {
                this.map[client.uuid] = false;
            }
        }
    };
    return DepthBin;
}());
/**
 * @private
 * 显示列表嵌套深度排序队列
 */
var DepthQueue = /** @class */ (function () {
    function DepthQueue() {
        /**
         * 深度队列
         */
        this.depthBins = {};
        /**
         * 最小深度
         */
        this.minDepth = 0;
        /**
         * 最大深度
         */
        this.maxDepth = -1;
    }
    /**
     * 移除所有
     */
    DepthQueue.prototype.removeAll = function () {
        var depthBins = this.depthBins;
        for (var key in depthBins) {
            var item = depthBins[key];
            item.items = [];
            item.map = {};
            item.length = 0;
        }
        this.minDepth = 0;
        this.maxDepth = -1;
    };
    /**
     * 插入一个元素
     */
    DepthQueue.prototype.insert = function (client) {
        var depth = client.$nestLevel;
        if (this.maxDepth < this.minDepth) {
            this.minDepth = this.maxDepth = depth;
        }
        else {
            if (depth < this.minDepth)
                this.minDepth = depth;
            if (depth > this.maxDepth)
                this.maxDepth = depth;
        }
        var bin = this.depthBins[depth];
        if (!bin) {
            bin = this.depthBins[depth] = new DepthBin();
        }
        bin.insert(client);
    };
    /**
     * 从队列尾弹出深度最大的一个对象
     */
    DepthQueue.prototype.pop = function () {
        var client;
        var minDepth = this.minDepth;
        if (minDepth <= this.maxDepth) {
            var bin = this.depthBins[this.maxDepth];
            while (!bin || bin.length === 0) {
                this.maxDepth--;
                if (this.maxDepth < minDepth)
                    return undefined;
                bin = this.depthBins[this.maxDepth];
            }
            client = bin.pop();
            while (!bin || bin.length == 0) {
                this.maxDepth--;
                if (this.maxDepth < minDepth)
                    break;
                bin = this.depthBins[this.maxDepth];
            }
        }
        return client;
    };
    /**
     * 从队列首弹出深度最小的一个对象
     */
    DepthQueue.prototype.shift = function () {
        var client;
        var maxDepth = this.maxDepth;
        if (this.minDepth <= maxDepth) {
            var bin = this.depthBins[this.minDepth];
            while (!bin || bin.length === 0) {
                this.minDepth++;
                if (this.minDepth > maxDepth)
                    return undefined;
                bin = this.depthBins[this.minDepth];
            }
            client = bin.pop();
            while (!bin || bin.length == 0) {
                this.minDepth++;
                if (this.minDepth > maxDepth)
                    break;
                bin = this.depthBins[this.minDepth];
            }
        }
        return client;
    };
    /**
     * 移除大于等于指定组件层级的元素中最大的元素
     */
    DepthQueue.prototype.removeLargestChild = function (client) {
        var hashCode = client.uuid;
        var nestLevel = client.$nestLevel;
        var max = this.maxDepth;
        var min = nestLevel;
        while (min <= max) {
            var bin = this.depthBins[max];
            if (bin && bin.length > 0) {
                if (max === nestLevel) {
                    if (bin.map[hashCode]) {
                        bin.remove(client);
                        return client;
                    }
                }
                else if (client["isContainer"]) {
                    var items = bin.items;
                    var length_1 = bin.length;
                    for (var i = 0; i < length_1; i++) {
                        var value = items[i];
                        if (client.contains(value)) {
                            bin.remove(value);
                            return value;
                        }
                    }
                }
                else {
                    break;
                }
                max--;
            }
            else {
                if (max == this.maxDepth) {
                    this.maxDepth--;
                }
                max--;
                if (max < min)
                    break;
            }
        }
        return undefined;
    };
    /**
     * 移除大于等于指定组件层级的元素中最小的元素
     */
    DepthQueue.prototype.removeSmallestChild = function (client) {
        var nestLevel = client.$nestLevel;
        var min = nestLevel;
        var max = this.maxDepth;
        var hashCode = client.uuid;
        while (min <= max) {
            var bin = this.depthBins[min];
            if (bin && bin.length > 0) {
                if (min === nestLevel) {
                    if (bin.map[hashCode]) {
                        bin.remove(client);
                        return client;
                    }
                }
                else if (client["isContainer"]) {
                    var items = bin.items;
                    var length_2 = bin.length;
                    for (var i = 0; i < length_2; i++) {
                        var value = items[i];
                        if (client.contains(value)) {
                            bin.remove(value);
                            return value;
                        }
                    }
                }
                else {
                    break;
                }
                min++;
            }
            else {
                if (min == this.minDepth)
                    this.minDepth++;
                min++;
                if (min > max)
                    break;
            }
        }
        return undefined;
    };
    /**
     * 队列是否为空
     */
    DepthQueue.prototype.isEmpty = function () {
        return this.minDepth > this.maxDepth;
    };
    return DepthQueue;
}());
/**
 * @private
 * 失效验证管理器
 */
var UIValidator = /** @class */ (function (_super) {
    __extends(UIValidator, _super);
    /**
     * @private
     * 创建一个Validator对象
     */
    function UIValidator() {
        var _this = _super.call(this) || this;
        /**
         * @private
         */
        _this.targetLevel = Infinity;
        /**
         * @private
         */
        _this.invalidatePropertiesFlag = false;
        /**
         * @private
         */
        _this.invalidateClientPropertiesFlag = false;
        /**
         * @private
         */
        _this.invalidatePropertiesQueue = new DepthQueue();
        /**
         * @private
         */
        _this.invalidateSizeFlag = false;
        /**
         * @private
         */
        _this.invalidateClientSizeFlag = false;
        /**
         * @private
         */
        _this.invalidateSizeQueue = new DepthQueue();
        /**
         * @private
         */
        _this.invalidateDisplayListFlag = false;
        /**
         * @private
         */
        _this.invalidateDisplayListQueue = new DepthQueue();
        /**
         * @private
         * 是否已经添加了事件监听
         */
        _this.listenersAttached = false;
        return _this;
    }
    /**
     * @private
     * 标记组件属性失效
     */
    UIValidator.prototype.invalidateProperties = function (target) {
        if (!this.invalidatePropertiesFlag) {
            this.invalidatePropertiesFlag = true;
            if (!this.listenersAttached)
                this.attachListeners();
        }
        if (this.targetLevel <= target.$nestLevel)
            this.invalidateClientPropertiesFlag = true;
        this.invalidatePropertiesQueue.insert(target);
    };
    /**
     * @private
     * 验证失效的属性
     */
    UIValidator.prototype.validateProperties = function () {
        var queue = this.invalidatePropertiesQueue;
        var target = queue.shift();
        while (target) {
            if (target.parent) {
                target.validateProperties();
            }
            target = queue.shift();
        }
        if (queue.isEmpty())
            this.invalidatePropertiesFlag = false;
    };
    /**
     * @private
     * 标记需要重新测量尺寸
     */
    UIValidator.prototype.invalidateSize = function (target) {
        if (!this.invalidateSizeFlag) {
            this.invalidateSizeFlag = true;
            if (!this.listenersAttached)
                this.attachListeners();
        }
        if (this.targetLevel <= target.$nestLevel)
            this.invalidateClientSizeFlag = true;
        this.invalidateSizeQueue.insert(target);
    };
    /**
     * @private
     * 测量尺寸
     */
    UIValidator.prototype.validateSize = function () {
        var queue = this.invalidateSizeQueue;
        var target = queue.pop();
        while (target) {
            if (target.parent) {
                target.validateSize();
            }
            target = queue.pop();
        }
        if (queue.isEmpty())
            this.invalidateSizeFlag = false;
    };
    /**
     * @private
     * 标记需要重新布局
     */
    UIValidator.prototype.invalidateDisplayList = function (client) {
        if (!this.invalidateDisplayListFlag) {
            this.invalidateDisplayListFlag = true;
            if (!this.listenersAttached)
                this.attachListeners();
        }
        this.invalidateDisplayListQueue.insert(client);
    };
    /**
     * @private
     * 重新布局
     */
    UIValidator.prototype.validateDisplayList = function () {
        var queue = this.invalidateDisplayListQueue;
        var client = queue.shift();
        while (client) {
            if (client.parent) {
                client.validateDisplayList();
            }
            client = queue.shift();
        }
        if (queue.isEmpty())
            this.invalidateDisplayListFlag = false;
    };
    /**
     * @private
     * 添加事件监听
     */
    UIValidator.prototype.attachListeners = function () {
        Ticker_1.TickerShared.addOnce(this.doPhasedInstantiationCallBack, this);
        this.listenersAttached = true;
    };
    /**
     * @private
     * 执行属性应用
     */
    UIValidator.prototype.doPhasedInstantiationCallBack = function () {
        this.doPhasedInstantiation();
    };
    /**
     * @private
     */
    UIValidator.prototype.doPhasedInstantiation = function () {
        if (this.invalidatePropertiesFlag) {
            this.validateProperties();
        }
        if (this.invalidateSizeFlag) {
            this.validateSize();
        }
        if (this.invalidateDisplayListFlag) {
            this.validateDisplayList();
        }
        if (this.invalidatePropertiesFlag ||
            this.invalidateSizeFlag ||
            this.invalidateDisplayListFlag) {
            this.attachListeners();
        }
        else {
            this.listenersAttached = false;
        }
    };
    /**
     * @private
     * 使大于等于指定组件层级的元素立即应用属性
     * @param target 要立即应用属性的组件
     */
    UIValidator.prototype.validateClient = function (target) {
        var obj;
        var done = false;
        var oldTargetLevel = this.targetLevel;
        if (this.targetLevel === Infinity)
            this.targetLevel = target.$nestLevel;
        var propertiesQueue = this.invalidatePropertiesQueue;
        var sizeQueue = this.invalidateSizeQueue;
        var displayListQueue = this.invalidateDisplayListQueue;
        while (!done) {
            done = true;
            obj = propertiesQueue.removeSmallestChild(target);
            while (obj) {
                if (obj.parent) {
                    obj.validateProperties();
                }
                obj = propertiesQueue.removeSmallestChild(target);
            }
            if (propertiesQueue.isEmpty()) {
                this.invalidatePropertiesFlag = false;
            }
            this.invalidateClientPropertiesFlag = false;
            obj = sizeQueue.removeLargestChild(target);
            while (obj) {
                if (obj.parent) {
                    obj.validateSize();
                }
                if (this.invalidateClientPropertiesFlag) {
                    obj = (propertiesQueue.removeSmallestChild(target));
                    if (obj) {
                        propertiesQueue.insert(obj);
                        done = false;
                        break;
                    }
                }
                obj = sizeQueue.removeLargestChild(target);
            }
            if (sizeQueue.isEmpty()) {
                this.invalidateSizeFlag = false;
            }
            this.invalidateClientPropertiesFlag = false;
            this.invalidateClientSizeFlag = false;
            obj = displayListQueue.removeSmallestChild(target);
            while (obj) {
                if (obj.parent) {
                    obj.validateDisplayList();
                }
                if (this.invalidateClientPropertiesFlag) {
                    obj = propertiesQueue.removeSmallestChild(target);
                    if (obj) {
                        propertiesQueue.insert(obj);
                        done = false;
                        break;
                    }
                }
                if (this.invalidateClientSizeFlag) {
                    obj = sizeQueue.removeLargestChild(target);
                    if (obj) {
                        sizeQueue.insert(obj);
                        done = false;
                        break;
                    }
                }
                obj = displayListQueue.removeSmallestChild(target);
            }
            if (displayListQueue.isEmpty()) {
                this.invalidateDisplayListFlag = false;
            }
        }
        if (oldTargetLevel === Infinity) {
            this.targetLevel = Infinity;
        }
    };
    UIValidator.prototype.removeDepthQueueAll = function () {
        this.invalidatePropertiesQueue.removeAll();
        this.invalidateDisplayListQueue.removeAll();
        this.invalidateSizeQueue.removeAll();
        this.doPhasedInstantiation();
    };
    return UIValidator;
}(vf.utils.EventEmitter));
var validatorShared = new UIValidator();
exports.default = validatorShared;


/***/ }),

/***/ "./src/core/DisplayObject.ts":
/*!***********************************!*\
  !*** ./src/core/DisplayObject.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplayObject = void 0;
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var DisplayLayoutAbstract_1 = __webpack_require__(/*! ./DisplayLayoutAbstract */ "./src/core/DisplayLayoutAbstract.ts");
var CSSStyle_1 = __webpack_require__(/*! ../layout/CSSStyle */ "./src/layout/CSSStyle.ts");
var CSSLayout_1 = __webpack_require__(/*! ../layout/CSSLayout */ "./src/layout/CSSLayout.ts");
var UIBaseDrag_1 = __webpack_require__(/*! ./plugs/UIBaseDrag */ "./src/core/plugs/UIBaseDrag.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var UIClick_1 = __webpack_require__(/*! ./plugs/UIClick */ "./src/core/plugs/UIClick.ts");
var UI_1 = __webpack_require__(/*! ../UI */ "./src/UI.ts");
var HitArea_1 = __webpack_require__(/*! ./plugs/HitArea */ "./src/core/plugs/HitArea.ts");
/**
 * UI的顶级类，基础的UI对象
 *
 * @class
 * @since 1.0.0
 */
var DisplayObject = /** @class */ (function (_super) {
    __extends(DisplayObject, _super);
    /**
     * 构造函数
     */
    function DisplayObject() {
        var _this = _super.call(this) || this;
        /**
         * 插件列表
         */
        _this.plugs = new Map();
        /**
         * 拖动限制门槛,小于设置的数不执行拖动,防止点击与滚动
         */
        _this.dragThreshold = 0;
        /** 拖动时，事件流是否继续传输 */
        _this.dragStopPropagation = true;
        /** 子类实现 */
        _this._anchorX = 0;
        /** 子类实现 */
        _this._anchorY = 0;
        /**
         * 色调
         * @default 0xFFFFFF
         * */
        _this._tint = 0xFFFFFF;
        _this._filterProxy = {};
        _this._filterMap = new Map();
        _this._filterCount = 0;
        _this.grayscaleFilterValue = NaN;
        /**
        *  在不同分辨率下保持像素稳定
        * @default
        */
        _this.pixelPerfect = true;
        /**
         * 动态属性，避免其他类注入
         */
        _this.attach = {};
        _this.container.name = _this.constructor.name;
        return _this;
    }
    Object.defineProperty(DisplayObject.prototype, "dragOption", {
        /**
         * 设置拖动
         */
        get: function () {
            if (this.plugs.has(UIBaseDrag_1.UIBaseDrag.key)) {
                return this.plugs.get(UIBaseDrag_1.UIBaseDrag.key);
            }
            return new UIBaseDrag_1.UIBaseDrag(this);
        },
        set: function (value) {
            var dragOption = this.dragOption;
            Utils_1.deepCopy(value, dragOption);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "interactabled", {
        /** 是否开启鼠标或触摸点击，开启后，接收TouchMouseEvent */
        get: function () {
            var click = this.plugs.get(UIClick_1.UIClick.key);
            if (click) {
                return true;
            }
            return false;
        },
        set: function (value) {
            var click = this.plugs.get(UIClick_1.UIClick.key);
            if (value) {
                if (!click) {
                    new UIClick_1.UIClick(this);
                }
            }
            else {
                if (click) {
                    click.release();
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "hitArea", {
        /**
         * 设置拖拽
         */
        get: function () {
            if (this.plugs.has(HitArea_1.HitArea.key)) {
                return this.plugs.get(HitArea_1.HitArea.key);
            }
            return new HitArea_1.HitArea(this);
        },
        enumerable: false,
        configurable: true
    });
    DisplayObject.prototype.checkHitArea = function () {
        return this.plugs.has(HitArea_1.HitArea.key);
    };
    Object.defineProperty(DisplayObject.prototype, "isClick", {
        /** 是否开启鼠标或触摸点击，开启后，接收TouchMouseEvent */
        get: function () {
            console.error('[VF LOG] isClick 已弃用，请使用 interactabled 替换!');
            return this.interactabled;
        },
        set: function (value) {
            console.error('[VF LOG] isClick 已弃用，请使用 interactabled 替换!');
            this.interactabled = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "groupName", {
        get: function () {
            return this._groupName;
        },
        set: function (value) {
            if (value === undefined) {
                Index_1.GroupController.unRegistrerGroup(this);
            }
            if (this._groupName == value) {
                return;
            }
            this._groupName = value;
            Index_1.GroupController.registrerGroup(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "alpha", {
        /**
         * 透明度
         */
        get: function () {
            return this.container.alpha;
        },
        set: function (value) {
            this.container.alpha = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "tint", {
        get: function () {
            return this._tint;
        },
        set: function (value) {
            if (value === this._blendMode) {
                return;
            }
            if (value === undefined) {
                this._tint = 0xFFFFFF;
                return;
            }
            this._tint = value;
            this.container.children.forEach(function (childrenItem) {
                if (childrenItem["tint"]) {
                    childrenItem["tint"] = value;
                }
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "blendMode", {
        get: function () {
            return this._blendMode;
        },
        set: function (value) {
            if (value === this._blendMode) {
                return;
            }
            this._blendMode = value;
            this.container.children.forEach(function (childrenItem) {
                if (childrenItem instanceof vf.Sprite) {
                    childrenItem.blendMode = value || vf.BLEND_MODES.NORMAL;
                }
                else if (childrenItem instanceof vf.Graphics) {
                    childrenItem.blendMode = value || vf.BLEND_MODES.NORMAL;
                }
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "filter", {
        get: function () {
            if (this._filterCount !== UI_1.Filter.list.size) {
                this._filterCount = UI_1.Filter.list.size;
                var _a = this, _filterProxy_1 = _a._filterProxy, _filterMap_1 = _a._filterMap;
                if (this.container.filters == null) {
                    this.container.filters = [];
                }
                var containerFilters_1 = this.container.filters;
                UI_1.Filter.list.forEach(function (cls, key) {
                    if (!_filterMap_1.has(key)) {
                        var filter_1 = new cls();
                        _filterMap_1.set(key, filter_1);
                        Object.defineProperty(_filterProxy_1, key, {
                            get: function () {
                                var index = containerFilters_1.indexOf(filter_1);
                                if (index === -1) {
                                    containerFilters_1.push(filter_1);
                                }
                                return filter_1;
                            },
                            set: function (val) {
                                if (val == null || val == '') {
                                    var index = containerFilters_1.indexOf(filter_1);
                                    if (index >= 0) {
                                        containerFilters_1.splice(index, 1);
                                    }
                                    _filterMap_1.delete(key);
                                }
                            }
                        });
                    }
                });
            }
            return this._filterProxy;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "filterBlur", {
        get: function () {
            return this.blurFilter ? this.blurFilter.blur : 0;
        },
        /**
         * 设置Blur XY的模糊强度
         *
         * 参数类型为number时，设置 blurX = blurY = value
         *
         */
        set: function (value) {
            var container = this.container;
            if (this.blurFilter === undefined) {
                this.blurFilter = new vf.filters.BlurFilter(8, 1, 1);
                container.filters = [this.blurFilter];
            }
            if ((value === undefined || isNaN(value)) && this.blurFilter && container.filters) {
                container.filters.splice(container.filters.indexOf(this.blurFilter), 1);
                this.blurFilter = undefined;
            }
            else {
                this.blurFilter.blur = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "filterGrayscale", {
        get: function () {
            return this.grayscaleFilterValue * 100;
        },
        set: function (value) {
            var container = this.container;
            if (this.grayscaleFilter === undefined) {
                this.grayscaleFilter = new vf.filters.ColorMatrixFilter();
                container.filters = [this.grayscaleFilter];
            }
            if ((value === undefined || isNaN(value)) && this.grayscaleFilter && container.filters) {
                container.filters.splice(container.filters.indexOf(this.grayscaleFilter), 1);
                this.grayscaleFilter = undefined;
                this.grayscaleFilterValue = NaN;
            }
            else {
                this.grayscaleFilterValue = value / 100;
                this.grayscaleFilter.greyscale(this.grayscaleFilterValue, false);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "style", {
        /**
         * 获取样式
         */
        get: function () {
            if (this._style == undefined) {
                this._style = new CSSStyle_1.CSSStyle(this);
            }
            return this._style;
        },
        set: function (value) {
            var style = this.style;
            Utils_1.deepCopy(value, style);
            this.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    DisplayObject.prototype.toDomRectangle = function () {
        return Utils_1.toDomRectangle(this);
    };
    /**
     * 更新显示列表,子类重写，实现布局
     */
    DisplayObject.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        if (!this.visible || this.alpha <= 0) { // 隐藏元素后，布局失效
            return;
        }
        if (this._style) {
            //console.log("displayStyle",unscaledWidth,unscaledHeight,this.left,this.right,this.x,this.y);
            CSSLayout_1.updateDisplayLayout(this, unscaledWidth, unscaledHeight);
        }
        else {
            //console.log("display",this.x + this.pivotX,this.y + this.pivotY,this.scaleX,this.scaleY,this.rotation*(Math.PI/180),this.skewX,this.skewY,this.pivotX,this.pivotY);
            this.updateTransform();
            //虚拟热区
            if (this.checkHitArea() === true) {
                this.hitArea.updataHitArea();
            }
        }
    };
    DisplayObject.prototype.load = function () {
        this.initializeUIValues();
        _super.prototype.load.call(this);
    };
    DisplayObject.prototype.release = function () {
        var _a = this, container = _a.container, $mask = _a.$mask, $background = _a.$background, _filterMap = _a._filterMap, plugs = _a.plugs;
        container.filters = [];
        _filterMap.clear();
        if (this._style) {
            this._style.release();
            this._style = undefined;
        }
        $mask && $mask.release();
        $background && $background.release();
        this.$background = undefined;
        this.$mask = undefined;
        plugs.forEach(function (value) {
            value.release();
        });
        plugs.clear();
        Index_1.GroupController.unRegistrerID(this);
        Index_1.GroupController.unRegistrerGroup(this);
        _super.prototype.release.call(this);
    };
    DisplayObject.prototype.releaseAll = function () {
        this.offAll();
        this.release();
        while (this.uiChildren.length > 0) {
            if (this.uiChildren[0].uiChildren.length > 0) {
                this.uiChildren[0].uiChildren[0].releaseAll();
            }
            this.uiChildren[0].releaseAll();
        }
        this.uiChildren = [];
        this.container && this.container.parent && this.container.parent.removeChild(this.container);
        this.container.removeAllListeners();
        this.container.removeChildren();
    };
    return DisplayObject;
}(DisplayLayoutAbstract_1.DisplayLayoutAbstract));
exports.DisplayObject = DisplayObject;


/***/ }),

/***/ "./src/core/DisplayObjectAbstract.ts":
/*!*******************************************!*\
  !*** ./src/core/DisplayObjectAbstract.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DisplayObjectAbstract = void 0;
var ContainerBase_1 = __webpack_require__(/*! ./ContainerBase */ "./src/core/ContainerBase.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Background_1 = __webpack_require__(/*! ./Background */ "./src/core/Background.ts");
var Mask_1 = __webpack_require__(/*! ./Mask */ "./src/core/Mask.ts");
var DisplayObjectAbstract = /** @class */ (function (_super) {
    __extends(DisplayObjectAbstract, _super);
    function DisplayObjectAbstract() {
        var _this = _super.call(this) || this;
        _this.id = '';
        /**
         * 自定义组价名
         */
        _this.name = '';
        /**
         * @private
         * 这个对象在显示列表中的嵌套深度，舞台为1，它的子项为2，子项的子项为3，以此类推。当对象不在显示列表中时此属性值为0.
         */
        _this.$nestLevel = 0;
        /**
         * 是否初始化
         * @default
         */
        _this.initialized = false;
        /**
         * 节点列表
         */
        _this.uiChildren = [];
        /**
         * 背景(内部使用)
         */
        _this.$background = new Background_1.Background(_this);
        /**
         * 遮罩(内部使用)，设置遮罩后，组件内部的索引位置可能产生变化
         */
        _this.$mask = new Mask_1.Mask(_this); // vf.Graphics | vf.Sprite | DisplayLayoutAbstract;
        /**
         * 是否开启事件同步
         */
        _this.syncabled = true;
        /**
         * 是否开启恢复时派发事件
         */
        _this.resumeabled = true;
        _this._interactive = true;
        _this._interactiveChildren = true;
        _this._enabled = true;
        /**
         * 是否可见
         */
        _this._visible = true;
        _this.uuid = Utils_1.uid();
        _this.container = new ContainerBase_1.ContainerBase();
        _this.container.on("added", _this.$onAddStage, _this);
        _this.container.on("removed", _this.$onRemoveStage, _this);
        return _this;
    }
    /** 添加显示对象，需集成Core */
    DisplayObjectAbstract.prototype.addChild = function (item) {
        if (this.container.children.length !== this.uiChildren.length) {
            return this.addChildAt(item, this.container.children.length);
        }
        else {
            return this.addChildAt(item, this.uiChildren.length);
        }
    };
    /**
     * 插入显示对象到特定位置
     * @param item 显示对象
     * @param index 要插入的索引，最大值为当前显示列表的长度，最小值为0
     */
    DisplayObjectAbstract.prototype.addChildAt = function (item, index) {
        if (item.parent) {
            item.parent.removeChild(item);
        }
        item.parent = this;
        item.$nestLevel = this.$nestLevel + 1;
        this.uiChildren.splice(index, 0, item);
        if (!item.initialized) {
            item.initialized = true;
            item.$onInit();
        }
        index = Math.min(index, this.container.children.length);
        this.emit(Index_1.ComponentEvent.ADD, this);
        if (this.$background && this.$background.isInit) {
            this.container.addChildAt(item.container, Math.min(index + 1, this.container.children.length));
        }
        else {
            this.container.addChildAt(item.container, index);
        }
        return item;
    };
    DisplayObjectAbstract.prototype.getChildAt = function (index) {
        return this.uiChildren[index] || undefined;
    };
    DisplayObjectAbstract.prototype.getChildByUUID = function (uuid) {
        var uiChildren = this.uiChildren;
        var len = uiChildren.length;
        for (var i = 0; i < len; i++) {
            if (uiChildren[i].uuid == uuid) {
                return uiChildren[i];
            }
        }
        return undefined;
    };
    DisplayObjectAbstract.prototype._getChildById = function (id) {
        var uiChildren = this.uiChildren;
        var len = uiChildren.length;
        for (var i = 0; i < len; i++) {
            if (uiChildren[i].id === id) {
                return uiChildren[i];
            }
        }
        return undefined;
    };
    DisplayObjectAbstract.prototype.getChildByPath = function (ids) {
        var display = this;
        var len = ids.length - 1;
        for (var i = len; i >= 0; i--) {
            if (display)
                display = display._getChildById(ids[i]);
            else
                display = undefined;
        }
        return display;
    };
    /**
     * 移除已添加的UI组件
     * @param UIObject 要移除的UI组件
     */
    DisplayObjectAbstract.prototype.removeChild = function (item) {
        var index = this.uiChildren.indexOf(item);
        if (index === -1) { // 防止删除多余的
            return item;
        }
        return this.removeChildAt(index);
    };
    DisplayObjectAbstract.prototype.removeChildAt = function (index) {
        index = Math.max(0, index);
        index = Math.min(this.uiChildren.length, index);
        var item = this.uiChildren[index];
        if (item) {
            item.container.parent.removeChild(item.container);
            this.uiChildren.splice(index, 1);
            item.parent = undefined;
        }
        return item;
    };
    /**
     * 移除元素
     * @param release 是否释放子节点，破坏结构
     * @param beginIndex 开始
     * @param endIndex 结束
     */
    DisplayObjectAbstract.prototype.removeChildren = function (release, beginIndex, endIndex) {
        if (release === void 0) { release = false; }
        var start = beginIndex ? beginIndex : 0;
        var end = endIndex ? endIndex : this.uiChildren.length;
        for (var i = end - 1; i >= start; i--) {
            var disp = this.removeChild(this.uiChildren[i]);
            if (release) {
                disp.release();
            }
        }
    };
    Object.defineProperty(DisplayObjectAbstract.prototype, "renderable", {
        get: function () {
            return this.container.renderable;
        },
        /**
         * 是否绘制显示对象，如果false不进行绘制，不过仍然会进行相关的更新计算。
         * 只影响父级的递归调用。
         */
        set: function (value) {
            this.container.renderable = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObjectAbstract.prototype, "interactive", {
        get: function () {
            return this.container.interactive;
        },
        /**
         * 对象是否可以接收事件
         */
        set: function (value) {
            this._interactive = value;
            if (!this._enabled) {
                return;
            }
            this.container.interactive = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObjectAbstract.prototype, "interactiveChildren", {
        get: function () {
            return this.container.interactiveChildren;
        },
        /**
         * 子对象是否可以接收事件，设置false后，会绕过HitTest方法的递归
         */
        set: function (value) {
            this._interactiveChildren = value;
            if (!this._enabled) {
                return;
            }
            this.container.interactiveChildren = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 子类实现
     */
    DisplayObjectAbstract.prototype.validateNow = function () {
        //
    };
    Object.defineProperty(DisplayObjectAbstract.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        set: function (value) {
            if (this._enabled === value) {
                return;
            }
            this._enabled = value;
            this.container.interactive = value;
            this.container.interactiveChildren = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObjectAbstract.prototype, "visible", {
        get: function () {
            return this._visible;
        },
        set: function (value) {
            if (this._visible === value) {
                return;
            }
            this._visible = value;
            if (value === true) {
                this.validateNow();
            }
            this.container.visible = value;
        },
        enumerable: false,
        configurable: true
    });
    /** 清除全部事件 */
    DisplayObjectAbstract.prototype.offAll = function (event) {
        return this.removeAllListeners(event);
    };
    Object.defineProperty(DisplayObjectAbstract.prototype, "stage", {
        get: function () {
            if (this.$stage == undefined) {
                this.$stage = Utils_1.getStage(this);
            }
            return this.$stage;
        },
        enumerable: false,
        configurable: true
    });
    DisplayObjectAbstract.prototype.checkInvalidateFlag = function () {
        //
    };
    DisplayObjectAbstract.prototype.load = function () {
        this.$onLoad();
    };
    DisplayObjectAbstract.prototype.release = function () {
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.$onRelease();
        this.$stage = undefined;
    };
    DisplayObjectAbstract.prototype.$onInit = function () {
        this.emit(Index_1.ComponentEvent.CREATION_COMPLETE, this);
    };
    DisplayObjectAbstract.prototype.$onLoad = function () {
        //
    };
    DisplayObjectAbstract.prototype.$onRelease = function () {
        //
    };
    DisplayObjectAbstract.prototype.$onAddStage = function () {
        this.checkInvalidateFlag();
        this.emit(Index_1.ComponentEvent.ADDED, this);
    };
    DisplayObjectAbstract.prototype.$onRemoveStage = function () {
        this.checkInvalidateFlag();
        this.parent = undefined;
        this.emit(Index_1.ComponentEvent.REMOVEED, this);
    };
    return DisplayObjectAbstract;
}(vf.utils.EventEmitter));
exports.DisplayObjectAbstract = DisplayObjectAbstract;


/***/ }),

/***/ "./src/core/Filter.ts":
/*!****************************!*\
  !*** ./src/core/Filter.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Filter = void 0;
var Filter = /** @class */ (function (_super) {
    __extends(Filter, _super);
    function Filter(vertexSrc, fragmentSrc, uniforms) {
        return _super.call(this, vertexSrc, fragmentSrc, uniforms) || this;
    }
    Filter.isFilter = true;
    Filter.defaultFilterVertex = vf.defaultFilterVertex;
    Filter.list = new Map();
    return Filter;
}(vf.Filter));
exports.Filter = Filter;


/***/ }),

/***/ "./src/core/Mask.ts":
/*!**************************!*\
  !*** ./src/core/Mask.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Mask = void 0;
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Mask = /** @class */ (function () {
    function Mask(parent) {
        this._invalidateFlag = false;
        this.parent = parent;
    }
    Object.defineProperty(Mask.prototype, "position", {
        get: function () {
            return this._position;
        },
        set: function (value) {
            this._position = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Mask.prototype, "size", {
        get: function () {
            return this._size;
        },
        set: function (value) {
            this._size = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Mask.prototype, "image", {
        get: function () {
            return this._image;
        },
        set: function (value) {
            if (value === this._image) {
                return;
            }
            this._image = value;
            this._invalidateFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    Mask.prototype.update = function (w, h) {
        if (!this._invalidateFlag) {
            return;
        }
        this._invalidateFlag = false;
        var target = this.parent;
        var container = target.container;
        var image = this._image;
        var maskdisplay;
        if (image !== this._oldImage) {
            this._oldImage = image;
            if (this._mask && this._mask.parent) {
                this._mask.parent.removeChild(this._mask);
            }
            if (image === undefined) {
                container.mask = null;
                return;
            }
            this._mask = undefined;
            if (typeof image === 'string' && image.indexOf('//') !== -1) { // http
                this._mask = maskdisplay = vf.Sprite.from(image);
            }
            else if (typeof image === 'string' && image.indexOf('this') !== -1) { // vf-player gui 'this#xxxx' 组件被添加到舞台
                maskdisplay = Utils_1.getDisplayObject(this._image);
            }
            else if (typeof image === 'string' || typeof image === 'number') { // vf-player id, 组件没有被添加到舞台
                var guiObject = Utils_1.getDisplayObject(image);
                if (typeof guiObject === 'string') {
                    this._mask = maskdisplay = vf.Sprite.from(guiObject);
                }
                else {
                    maskdisplay = this.getGuiObject(guiObject);
                }
            }
            else if (typeof image === 'string' && image.indexOf('.') !== -1) { // file.xxx
                this._mask = maskdisplay = vf.Sprite.from(image);
            }
            else if (image instanceof vf.Graphics || image instanceof vf.Sprite) {
                this._mask = maskdisplay = image;
            }
            else if (image.maskSprite) { // gui组件
                maskdisplay = this.getGuiObject(image);
            }
            if (maskdisplay) {
                container.mask = maskdisplay;
                if (!maskdisplay.parent) {
                    container.addChild(maskdisplay);
                }
            }
        }
        var mask = container.mask;
        if (mask && this._size) {
            if (this._mask) {
                this._mask.width = this._size[0];
                this._mask.height = this._size[1];
            }
            else {
                mask.width = this._size[0];
                mask.height = this._size[1];
            }
        }
        if (mask && this._position) {
            if (this._mask) {
                this._mask.x = this._position[0] || 0;
                this._mask.y = this._position[1] || 0;
            }
            else {
                mask.x = this._position[0] || 0;
                mask.y = this._position[1] || 0;
            }
        }
    };
    Mask.prototype.getGuiObject = function (sp) {
        this._mask = sp;
        if (!sp.parent) {
            this.parent.addChild(sp);
        }
        sp.validateNow();
        return sp.maskSprite();
    };
    Mask.prototype.release = function () {
        if (this.parent) {
            this.parent.mask = null;
        }
        this._mask = undefined;
        this._oldImage = undefined;
        this.image = undefined;
        this.parent = undefined;
        this._invalidateFlag = false;
    };
    return Mask;
}());
exports.Mask = Mask;


/***/ }),

/***/ "./src/core/Scheduler.ts":
/*!*******************************!*\
  !*** ./src/core/Scheduler.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scheduler = void 0;
var Ticker_1 = __webpack_require__(/*! ./Ticker */ "./src/core/Ticker.ts");
/**
 * Schedule anything
 *
 * @author 8088
 */
var Scheduler = /** @class */ (function (_super) {
    __extends(Scheduler, _super);
    function Scheduler(timeout, interval) {
        if (timeout === void 0) { timeout = Infinity; }
        if (interval === void 0) { interval = 0; }
        var _this = _super.call(this) || this;
        _this._interval = 0;
        _this._timeout = Infinity;
        _this._id = Math.random();
        _this._running = false;
        _this._pausing = false;
        _this._totalDuration = 0;
        _this._intervalDuration = 0;
        _this._timeout = timeout;
        _this._interval = interval;
        _this.restart();
        return _this;
    }
    Object.defineProperty(Scheduler.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: false,
        configurable: true
    });
    Scheduler.stopAll = function () {
        for (var i = 0; i < Scheduler.schedulerList.length; ++i) {
            Scheduler.schedulerList[i].stop();
        }
        console.log('removeAll', Scheduler.schedulerList);
        Scheduler.schedulerList = [];
    };
    Scheduler.setEnterFrame = function (listener) {
        var scheduler = new Scheduler(Infinity, 0);
        scheduler.addListener("tick" /* TICK */, listener);
        Scheduler.schedulerList.push(scheduler);
        return scheduler;
    };
    Scheduler.setInterval = function (time, listener) {
        var scheduler = new Scheduler(Infinity, time);
        scheduler.addListener("tick" /* TICK */, listener);
        Scheduler.schedulerList.push(scheduler);
        return scheduler;
    };
    Scheduler.setTimeout = function (time, listener) {
        var scheduler = new Scheduler(time, Infinity);
        scheduler.addListener("end" /* END */, listener, scheduler);
        Scheduler.schedulerList.push(scheduler);
        return scheduler;
    };
    Scheduler.prototype.restart = function () {
        this._totalDuration = 0;
        this._intervalDuration = 0;
        this._pausing = false;
        if (!this._running) {
            this._running = true;
            Ticker_1.TickerShared.add(this.run, this);
        }
    };
    Scheduler.prototype.stop = function () {
        // this.removeAllListeners();  //去掉这句，因为有可能会stop之后调用restart
        if (this._running) {
            this._running = false;
            Ticker_1.TickerShared.remove(this.run, this);
        }
        for (var i = 0; i < Scheduler.schedulerList.length; ++i) {
            if (Scheduler.schedulerList[i] == this) {
                Scheduler.schedulerList.splice(i, 1);
                break;
            }
        }
    };
    Scheduler.prototype.pause = function () {
        if (this._running && !this._pausing) {
            this._pausing = true;
            Ticker_1.TickerShared.remove(this.run, this);
        }
    };
    Scheduler.prototype.resume = function () {
        if (this._pausing) {
            this._pausing = false;
            Ticker_1.TickerShared.add(this.run, this);
        }
    };
    Scheduler.prototype.run = function (deltaTime) {
        this._totalDuration += Ticker_1.TickerShared.deltaMS;
        this._intervalDuration += Ticker_1.TickerShared.deltaMS;
        if (this._intervalDuration >= this._interval) {
            var info = {
                code: "tick" /* TICK */,
                level: "status" /* STATUS */,
                target: this,
                dt: this._intervalDuration,
                elapsed: this._totalDuration,
            };
            this.emit("tick" /* TICK */, info);
            this._intervalDuration = 0;
        }
        if (this._totalDuration >= this._timeout) {
            var info = {
                code: "end" /* END */,
                level: "status" /* STATUS */,
                target: this,
                dt: this._intervalDuration,
                elapsed: this._totalDuration,
            };
            this.emit("end" /* END */, info);
            this.stop();
        }
        return false;
    };
    Scheduler.schedulerList = [];
    return Scheduler;
}(vf.utils.EventEmitter));
exports.Scheduler = Scheduler;


/***/ }),

/***/ "./src/core/Stage.ts":
/*!***************************!*\
  !*** ./src/core/Stage.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stage = void 0;
var tween = __webpack_require__(/*! ../tween/private/index */ "./src/tween/private/index.ts");
var Ticker_1 = __webpack_require__(/*! ./Ticker */ "./src/core/Ticker.ts");
var DisplayLayoutAbstract_1 = __webpack_require__(/*! ./DisplayLayoutAbstract */ "./src/core/DisplayLayoutAbstract.ts");
var core_1 = __webpack_require__(/*! ../tween/private/core */ "./src/tween/private/core.ts");
var DisplayLayoutValidator_1 = __webpack_require__(/*! ./DisplayLayoutValidator */ "./src/core/DisplayLayoutValidator.ts");
var SyncManager_1 = __webpack_require__(/*! ../interaction/SyncManager */ "./src/interaction/SyncManager.ts");
var Scheduler_1 = __webpack_require__(/*! ./Scheduler */ "./src/core/Scheduler.ts");
/**
 * UI的舞台对象，展示所有UI组件
 *
 * @class
 * @param width {Number} 舞台宽度
 * @param height {Number} 舞台高度
 */
var Stage = /** @class */ (function (_super) {
    __extends(Stage, _super);
    function Stage(width, height, app) {
        var _this = _super.call(this) || this;
        _this.resumeStatusFlag = false; //当前stage是否正在恢复信令
        /**
         * 是否组织原始数据继续传递
         */
        _this.originalEventPreventDefault = false;
        // /**
        //  * 截取图片
        //  * @param display 
        //  * @param {string} [format] - 图片格式, 如 "image/jpeg" or "image/webp".
        //  * @param {number} [quality] - 图片的品质 0 to 1. 默认 is 0.92.
        //  */
        // public extractBase64(target?: vf.gui.DisplayObject,format?: string, quality?: number): any {
        // }
        /**
         * 是否同步交互事件
         */
        _this._syncInteractiveFlag = false; //TODO:默认false
        _this.width = width;
        _this.height = height;
        _this.setActualSize(width, height);
        _this.container.name = "Stage";
        _this.container.hitArea = new vf.Rectangle(0, 0, width, height);
        _this.container.interactive = true;
        _this.container.interactiveChildren = true;
        _this.$nestLevel = 1;
        _this.app = app;
        _this.initialized = true;
        if (!Ticker_1.TickerShared.started) {
            Ticker_1.TickerShared.start();
        }
        Ticker_1.TickerShared.add(tween.update, _this);
        if (!_this.container.parent) {
            _this.app.stage.addChildAt(_this.container, 0);
        }
        return _this;
    }
    Object.defineProperty(Stage.prototype, "stageWidth", {
        get: function () {
            return this.app.view.width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "stageHeight", {
        get: function () {
            return this.app.view.height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "scaleX", {
        get: function () {
            return this.container.scale.x;
        },
        set: function (value) {
            this.container.scale.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "scaleY", {
        get: function () {
            return this.container.scale.y;
        },
        set: function (value) {
            this.container.scale.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "Scale", {
        set: function (value) {
            this.container.scale.copyFrom(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "syncInteractiveFlag", {
        get: function () {
            return this._syncInteractiveFlag;
        },
        set: function (value) {
            this._syncInteractiveFlag = value;
            if (value) {
                if (!this.syncManager) {
                    this.syncManager = new SyncManager_1.SyncManager(this);
                    SyncManager_1.SyncManager.instance = this.syncManager;
                }
                this.syncManager.start();
            }
            else {
                if (this.syncManager) {
                    this.syncManager.stop();
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Stage.prototype.getSystemEvent = function () {
        //
        return this;
    };
    Stage.prototype.sendToPlayer = function (e) {
        //
    };
    Stage.prototype.release = function () {
        _super.prototype.release.call(this);
        Scheduler_1.Scheduler.stopAll();
        Ticker_1.TickerShared.remove(tween.update, this);
        core_1.releaseAllTimeLine();
        this.syncManager && this.syncManager.stop();
        this.syncManager = undefined;
        SyncManager_1.SyncManager.instance = undefined;
    };
    Stage.prototype.releaseAll = function () {
        Scheduler_1.Scheduler.stopAll();
        Ticker_1.TickerShared.remove(tween.update, this);
        core_1.releaseAllTimeLine();
        this.syncManager && this.syncManager.stop();
        this.syncManager = undefined;
        SyncManager_1.SyncManager.instance = undefined;
        for (var i = this.uiChildren.length - 1; i >= 0; i--) {
            var ui = this.uiChildren[i];
            ui.releaseAll();
        }
        this.uiChildren = [];
        this.container.removeAllListeners();
        this.container.removeChildren();
        DisplayLayoutValidator_1.default.removeAllListeners();
        DisplayLayoutValidator_1.default.removeDepthQueueAll();
        this.app = undefined;
    };
    Stage.prototype.resize = function () {
        this.container.hitArea = new vf.Rectangle(0, 0, this.width, this.height);
        //this.updateChildren();
    };
    /**
     * 接收来自player的消息
     * @param msg
     */
    Stage.prototype.receiveFromPlayer = function (msg) {
        if (msg.code == 'syncEvent') {
            var data = msg.data; //{data: eventData, type: 'live/history'}
            this.syncManager && this.syncManager.receiveEvent(data.data, data.type);
        }
    };
    Stage.prototype.getVitualCanvas = function () {
        if (!this._virCanvas) {
            this._virCanvas = document.createElement("canvas");
        }
        return this._virCanvas;
    };
    Stage.prototype.screenShots = function (x, y, width, height, endWidth, endHeight, displayObject) {
        if (endWidth === void 0) { endWidth = NaN; }
        if (endHeight === void 0) { endHeight = NaN; }
        var newCanvas = this.getVitualCanvas();
        var ctx = newCanvas.getContext("2d");
        var canvas = this.app.renderer.extract.canvas(displayObject || this.container);
        var w = isNaN(endWidth) ? width : endWidth;
        var h = isNaN(endHeight) ? height : endHeight;
        ctx.clearRect(0, 0, newCanvas.width, newCanvas.height);
        newCanvas.width = w;
        newCanvas.height = h;
        ctx.drawImage(canvas, x, y, width, height, 0, 0, w, h);
        var dataURL = newCanvas.toDataURL("image/png", 1.0);
        return vf.Texture.from(dataURL);
    };
    return Stage;
}(DisplayLayoutAbstract_1.DisplayLayoutAbstract));
exports.Stage = Stage;


/***/ }),

/***/ "./src/core/Ticker.ts":
/*!****************************!*\
  !*** ./src/core/Ticker.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TickerShared = void 0;
var Ticker = /** @class */ (function (_super) {
    __extends(Ticker, _super);
    function Ticker() {
        var _this = _super.call(this) || this;
        _this.currentTickerTime = performance.now();
        return _this;
    }
    Ticker.prototype.start = function () {
        _super.prototype.start.call(this);
        this.currentTickerTime = performance.now();
    };
    Ticker.prototype.update = function (currentTime) {
        if (currentTime === void 0) {
            currentTime = performance.now();
        }
        if (currentTime - this._lastFrame >= this._minElapsedMS) {
            this.currentTickerTime += (currentTime - this.lastTime);
        }
        _super.prototype.update.call(this, currentTime);
    };
    /**
     * 时间穿越， 单位ms
     * @param duration
     */
    Ticker.prototype.timeTravel = function (duration) {
        // let deltaTime = (this as any)._minElapsedMS;  //帧间隔
        var deltaTime = 50; //模拟穿越时，帧间隔使用50能最大化减少误差 by ziye+
        // deltaTime = parseFloat(deltaTime.toFixed(6));
        while (duration > 0) {
            duration -= deltaTime;
            //暂时去掉这句，尽量往后穿越一点，避免Tween跑不完的问题
            // if(duration < 0){
            //     deltaTime += duration;
            // }
            this.currentTickerTime += deltaTime;
            if (duration < 0) {
                this.currentTickerTime += duration; //时间用真实的穿越时间，执行多走一点，保证穿越效果
            }
            //分别跑vf.gui.ticker 和vf.ticker
            for (var i = 0; i < 2; ++i) {
                var _target = (i === 0 ? this : vf.Ticker.shared);
                var head = _target._head;
                var listener = head.next;
                while (listener) {
                    _target.deltaMS = deltaTime;
                    listener = listener.emit(deltaTime * vf.settings.TARGET_FPMS);
                }
            }
        }
    };
    return Ticker;
}(vf.Ticker));
exports.TickerShared = new Ticker();
exports.TickerShared.autoStart = false;
exports.TickerShared.maxFPS = 30;


/***/ }),

/***/ "./src/core/plugs/HitArea.ts":
/*!***********************************!*\
  !*** ./src/core/plugs/HitArea.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HitArea = void 0;
var Utils_1 = __webpack_require__(/*! ../../utils/Utils */ "./src/utils/Utils.ts");
var HitArea = /** @class */ (function () {
    /**
     * 构造函数
     */
    function HitArea(target) {
        this._type = "rect";
        this._x = NaN;
        this._y = NaN;
        this._width = NaN;
        this._height = NaN;
        this._displayObj = target;
        target.plugs.set(HitArea.key, this);
    }
    Object.defineProperty(HitArea.prototype, "type", {
        get: function () {
            return this._type;
        },
        set: function (value) {
            if (this._type === value) {
                return;
            }
            this._type = value;
            this._displayObj.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HitArea.prototype, "x", {
        get: function () {
            return this._x;
        },
        set: function (value) {
            if (this._x === value) {
                return;
            }
            this._x = value;
            this._displayObj.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HitArea.prototype, "y", {
        get: function () {
            return this._y;
        },
        set: function (value) {
            if (this._y === value) {
                return;
            }
            this._y = value;
            this._displayObj.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HitArea.prototype, "width", {
        get: function () {
            return this._width;
        },
        set: function (value) {
            if (this._width === value) {
                return;
            }
            this._width = value;
            this._displayObj.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HitArea.prototype, "height", {
        get: function () {
            return this._height;
        },
        set: function (value) {
            if (this._height === value) {
                return;
            }
            this._height = value;
            this._displayObj.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    HitArea.prototype.updataHitArea = function () {
        if (this._displayObj && this._displayObj.container) {
            this._displayObj.container.hitArea = this.getHitArea();
            if (Utils_1.debug) {
                var _a = this, _x = _a._x, _y = _a._y, _width = _a._width, _height = _a._height;
                var x = isNaN(_x) ? 0 : _x;
                var y = isNaN(_y) ? 0 : _y;
                var width = isNaN(_width) ? this._displayObj.width : _width;
                var height = isNaN(_height) ? this._displayObj.height : _height;
                var halfWidth = width >> 1;
                var halfHeight = height >> 1;
                !this._drawShape && (this._drawShape = new vf.Graphics());
                this._drawShape.clear();
                this._drawShape.lineStyle(1, 0x00ffff, 1);
                this._drawShape.beginFill(0xff0000, 0.5);
                switch (this.type) {
                    case "rect":
                        this._drawShape.drawRect(x, y, width, height);
                        break;
                    case "ellipse":
                        this._drawShape.drawEllipse(x + halfWidth, y + halfHeight, halfWidth, halfHeight);
                        break;
                }
                this._drawShape.endFill();
                !this._drawShape.parent && this._displayObj.container.addChild(this._drawShape);
            }
        }
    };
    HitArea.prototype.getHitArea = function () {
        var _a = this, _x = _a._x, _y = _a._y, _width = _a._width, _height = _a._height;
        var x = isNaN(_x) ? 0 : _x;
        var y = isNaN(_y) ? 0 : _y;
        var width = isNaN(_width) ? this._displayObj.width : _width;
        var height = isNaN(_height) ? this._displayObj.height : _height;
        var halfWidth = width >> 1;
        var halfHeight = height >> 1;
        switch (this.type) {
            case "rect":
                this._sprite = new vf.Rectangle(x, y, width, height);
                break;
            case "ellipse":
                this._sprite = new vf.Ellipse(x + halfWidth, y + halfHeight, halfWidth, halfHeight);
                break;
        }
        return this._sprite;
    };
    HitArea.prototype.load = function () {
        //
    };
    HitArea.prototype.release = function () {
        this._type = "rect";
        this._x = NaN;
        this._y = NaN;
        this._width = NaN;
        this._height = NaN;
        this._sprite = undefined;
        this._displayObj = undefined;
        if (this._drawShape) {
            if (this._drawShape.parent) {
                this._drawShape.parent.removeChild(this._drawShape);
            }
            this._drawShape.destroy();
            this._drawShape = undefined;
        }
    };
    HitArea.key = "HitArea";
    return HitArea;
}());
exports.HitArea = HitArea;


/***/ }),

/***/ "./src/core/plugs/LineGradient.ts":
/*!****************************************!*\
  !*** ./src/core/plugs/LineGradient.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTextureFill = void 0;
/**
 * 设置渐变
 * @param type
 * @param stops
 * @param color
 * @returns
 */
function updateTextureFill(_display, fillParam) {
    var _a;
    var display = fillParam || {
        style: {}
    };
    // if (fillParam === undefined) {
    //     const ds = (_display as any) as TextureFillParamType;
    //     display.canvas = ds.canvas;
    //     display.context = ds.context;
    //     display.texture = ds.texture;
    //     display.width = ds.width;
    //     display.height = ds.height;
    //     display.anchorX = ds.anchorX;
    //     display.anchorY = ds.anchorY;
    //     display.style.fillColor = ds.style.fillColor;
    //     display.style.fillGradientStopsr = ds.style.fillGradientStopsr || [];
    //     display.style.fillGradientType = ds.style.fillGradientType;
    // }
    if (display.canvas === undefined || display.context === undefined) {
        return undefined;
    }
    var fillColor = display.style.fillColor;
    if (fillColor && !Array.isArray(fillColor[0])) {
        return undefined; // 单色，无需渐变
    }
    if (typeof fillColor === 'number') {
        return undefined; // 写法有错误的为了兼容，单色，无需渐变
    }
    var fill = [];
    var fillGradientStops = display.style.fillGradientStops.slice();
    fillColor.forEach(function (item) {
        fill.push("rgba(" + item[0] + ", " + item[1] + ", " + item[2] + ", " + item[3] + ")");
    });
    // const resolution = display.stage?.app.renderer.resolution || 1;
    var width = Math.ceil(display.width);
    var height = Math.ceil(display.height);
    //display.context.scale(2, 2);
    display.canvas.width = width;
    display.canvas.height = height;
    display.context.clearRect(0, 0, width, height);
    // 不设置stops，则平均分布颜色 ，值为0.25, 0.5 and 0.75
    if (!fillGradientStops.length) {
        var lengthPlus1 = fill.length + 1;
        for (var i = 1; i < lengthPlus1; ++i) {
            fillGradientStops.push(i / lengthPlus1);
        }
    }
    var gradient;
    if (display.style.fillGradientType === vf.TEXT_GRADIENT.LINEAR_VERTICAL) {
        gradient = display.context.createLinearGradient(width / 2, 0, width / 2, height);
        for (var i = 0; i < fill.length; i++) {
            var lineStop = 0;
            if (typeof fillGradientStops[i] === 'number') {
                lineStop = fillGradientStops[i];
            }
            else {
                lineStop = i / fill.length;
            }
            lineStop = Math.min(lineStop, 1);
            gradient.addColorStop(lineStop, fill[i]);
        }
    }
    else {
        gradient = display.context.createLinearGradient(0, height / 2, width, height / 2);
        var totalIterations = fill.length + 1;
        var currentIteration = 1;
        for (var i = 0; i < fill.length; i++) {
            var stop_1 = void 0;
            if (typeof fillGradientStops[i] === 'number') {
                stop_1 = fillGradientStops[i];
            }
            else {
                stop_1 = currentIteration / totalIterations;
            }
            gradient.addColorStop(Math.min(stop_1, 1), fill[i]);
            currentIteration++;
        }
    }
    display.context.fillStyle = gradient;
    display.context.fillRect(0, 0, width, height);
    (_a = display.texture) === null || _a === void 0 ? void 0 : _a.update();
    var matrix = new vf.Matrix();
    matrix.tx = -width * display.anchorX;
    matrix.ty = -height * display.anchorY;
    _display.beginTextureFill({ texture: display.texture, matrix: matrix });
    //display.container.addChild(new vf.Sprite(display.texture));
    return display;
}
exports.updateTextureFill = updateTextureFill;


/***/ }),

/***/ "./src/core/plugs/UIBaseDrag.ts":
/*!**************************************!*\
  !*** ./src/core/plugs/UIBaseDrag.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIBaseDrag = void 0;
var Index_1 = __webpack_require__(/*! ../../interaction/Index */ "./src/interaction/Index.ts");
var DisplayObjectAbstract_1 = __webpack_require__(/*! ../DisplayObjectAbstract */ "./src/core/DisplayObjectAbstract.ts");
var Utils_1 = __webpack_require__(/*! ../../utils/Utils */ "./src/utils/Utils.ts");
var SyncManager_1 = __webpack_require__(/*! ../../interaction/SyncManager */ "./src/interaction/SyncManager.ts");
/**
 *  组件的拖拽操作
 *
 */
var UIBaseDrag = /** @class */ (function () {
    /**
     * 构造函数
     */
    function UIBaseDrag(target) {
        this.oldInteractiveChildren = true;
        /**
         * 可拖动初始化
         *  @default
         */
        this.dragInitialized = false;
        /**
         * 可被掉落初始化
         * @default
        */
        this.dropInitialized = false;
        /**
         * 临时属性，为了解决同步时的动作补齐
         * 0 没有操作
         * 1 开始拖动
         * 2 拖动中
         * 3 拖动结束
         * 4 拖动到目标
         */
        this._dragState = 0;
        /**
         * 位置
         *
         */
        this._dragPosition = new vf.Point();
        /**
         * 掉落容器的位置
         */
        this._dropPosition = new vf.Point();
        /**
         * 开始的偏移量
         */
        this._startOffset = new vf.Point(0, 0);
        /**
         * 是否拖动中
         * @default
         */
        this.dragging = false;
        /**
         * 是否碰撞检测
         */
        this.collision = false;
        /**
         * 是否设置边界
         * @default false
         */
        this.dragBoundary = false;
        /**
         * 是否启用回弹，在移动到非接收方时，回弹到原始位置
         */
        this.dragBounces = false;
        /**
         * 拖拽时的鼠标状态
         */
        this.dragMoveCursor = 'pointer';
        /**
         * 接收拖动掉落的分组名
         */
        this._dropGroup = '';
        this.oldWorldTransform = new vf.Matrix();
        this.oldLocalTransform = new vf.Matrix();
        this.target = target;
        target.plugs.set(UIBaseDrag.key, this);
        target.dragStopPropagation = true;
    }
    Object.defineProperty(UIBaseDrag.prototype, "dragDropEventId", {
        /**
         * 当前拖动组件的事件ID，用于处理DragDropController中多组件的选定
         */
        get: function () {
            if (this.target) {
                return this.target.attach.dragDropEventId;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIBaseDrag.prototype, "draggable", {
        /**
         * 是否开启拖动
         * @default false
         */
        set: function (value) {
            if (value)
                this.initDraggable();
            else
                this.clearDraggable();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIBaseDrag.prototype, "dragRestrictAxis", {
        get: function () {
            return this._dragRestrictAxis;
        },
        set: function (value) {
            this._dragRestrictAxis = value;
            if (this.drag) {
                this.drag.dragRestrictAxis = this._dragRestrictAxis;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIBaseDrag.prototype, "dragGroup", {
        /**
         * 拖动分组
         */
        get: function () {
            if (this.target) {
                return this.target.attach.dragGroup;
            }
            return "";
        },
        set: function (value) {
            if (this.target)
                this.target.attach.dragGroup = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIBaseDrag.prototype, "dragContainer", {
        get: function () {
            return this._dragContainer;
        },
        set: function (value) {
            this._dragContainer = Utils_1.getDisplayObject(value, this.target);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIBaseDrag.prototype, "droppable", {
        /**
         * 是否开启拖动掉落接收
         */
        set: function (value) {
            if (value)
                this.initDroppable();
            else
                this.clearDroppable();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIBaseDrag.prototype, "droppableReparent", {
        get: function () {
            return this._droppableReparent;
        },
        set: function (value) {
            this._droppableReparent = Utils_1.getDisplayObject(value, this.target);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UIBaseDrag.prototype, "dropGroup", {
        get: function () {
            return this._dropGroup;
        },
        set: function (value) {
            this._dropGroup = value;
            if (this.target) {
                Index_1.DragDropController.addDropTarget(value, this.target);
            }
        },
        enumerable: false,
        configurable: true
    });
    UIBaseDrag.prototype.clearDraggable = function () {
        if (this.dragInitialized) {
            this.dragInitialized = false;
            if (this.drag) {
                this.drag.stopEvent();
            }
        }
        if (this.target) {
            this.target.interactiveChildren = this.oldInteractiveChildren;
            Index_1.DragDropController.remove(this.target);
        }
        this.dragging = false;
        this._dragState = 0;
    };
    UIBaseDrag.prototype.initDraggable = function () {
        var _this = this;
        if (this.target == undefined) {
            return;
        }
        if (!this.dragInitialized) {
            this.dragInitialized = true;
            this._dragPosition.set(0, 0);
            this.drag = new Index_1.DragEvent(this.target);
            this.drag.dragRestrictAxis = this._dragRestrictAxis;
            this.drag.onDragPress = function (e, isPress) {
                if (_this.target == undefined) {
                    return;
                }
                var target = _this.target;
                if (target.stage === undefined) {
                    return;
                }
                if (isPress) {
                    target.emit(Index_1.ComponentEvent.DRAG_DOWN, target, e);
                }
                else {
                    target.emit(Index_1.ComponentEvent.DRAG_UP, target, e);
                }
            };
            this.drag.onDragHover = function (e, isHover) {
                if (_this.target == undefined) {
                    return;
                }
                var target = _this.target;
                target.emit(Index_1.ComponentEvent.DRAG_HOVER, target, e, isHover);
                if (isHover) {
                    target.emit(Index_1.ComponentEvent.DRAG_MOUSEENTER, target, e);
                }
                else {
                    target.emit(Index_1.ComponentEvent.DRAG_MOUSELEAVE, target, e);
                }
            };
            this.drag.onDragStart = function (e) {
                if (_this.target == undefined) {
                    return;
                }
                _this._dragState = 1;
                var target = _this.target;
                _this.$targetParent = target.parent;
                _this.oldInteractiveChildren = target.interactiveChildren;
                if (_this._dragContainer == undefined) {
                    _this._dragContainer = _this.target.stage;
                }
                var added = Index_1.DragDropController.add(target, e);
                if (!_this.dragging && added) {
                    target.emit(Index_1.ComponentEvent.DRAG_START_BEFORE, target, e);
                    _this.dragging = true;
                    target.interactive = false;
                    target.interactiveChildren = false;
                    _this.oldWorldTransform = Utils_1.toWorldTransform(target).clone();
                    _this.oldLocalTransform = Utils_1.toLoacalTransform(target).clone();
                    if (_this._dragContainer) {
                        var c = void 0;
                        if (_this._dragContainer instanceof DisplayObjectAbstract_1.DisplayObjectAbstract) {
                            c = _this._dragContainer;
                        }
                        if (c && target.parent) {
                            c.addChild(target);
                            target.scaleX = _this.oldWorldTransform.a * (1 / c.container.scale.x) / target.container.transform._cx; // this.oldWorldTransform.a;
                            target.scaleY = _this.oldWorldTransform.d * (1 / c.container.scale.y) / target.container.transform._sy; // this.oldWorldTransform.d ;
                            var local = Utils_1.toLocal(new vf.Point(_this.oldWorldTransform.tx, _this.oldWorldTransform.ty), c);
                            target.setPosition(local.x + ((target.container.transform.pivot.x * _this.oldWorldTransform.a) + (target.container.transform.pivot.y * _this.oldWorldTransform.c)), local.y + ((target.container.transform.pivot.x * _this.oldWorldTransform.b) + (target.container.transform.pivot.y * _this.oldWorldTransform.d))); //by ziye+
                            // target.setPosition((local.x + (target.pivotX * target.scaleX) - (target.width * target._anchorX)), (local.y + (target.pivotY * target.scaleY) - (target.height * target._anchorY)));
                        }
                    }
                    if (Utils_1.debug) { //debug 模式下，日志信息
                        var stage = target.stage;
                        if (stage) {
                            stage.sendToPlayer({
                                code: Index_1.ComponentEvent.DRAG_START,
                                level: 'info', target: target,
                                data: [target.parent, target.x, target.y],
                                action: e.type,
                                message: 'parent,start,offset pos',
                            });
                        }
                    }
                    _this._startOffset.set(target.x, target.y);
                    target.emit(Index_1.ComponentEvent.DRAG_START, target, e);
                }
            };
            this.drag.onDragMove = function (e, offset) {
                if (_this.target == undefined) {
                    return;
                }
                var target = _this.target;
                if (target.stage && target.stage.app) {
                    var interaction = target.stage.app.renderer.plugins.interaction;
                    interaction.cursor = _this.dragMoveCursor;
                }
                if (_this.dragging && target.stage) {
                    var x = _this._startOffset.x + (offset.x / target.stage.scaleX);
                    var y = _this._startOffset.y + (offset.y / target.stage.scaleY);
                    var dragPosition = _this._dragPosition;
                    if (_this.dragRestrictAxis == "x") {
                        dragPosition.set(x, target.y);
                    }
                    else if (_this.dragRestrictAxis == "y") {
                        dragPosition.set(target.x, y);
                    }
                    else {
                        _this._dragPosition.set(x, y);
                    }
                    if (_this.dragBoundary && target.parent) {
                        var pivotX = target.pivotX, pivotY = target.pivotY, scaleX = target.scaleX, scaleY = target.scaleY, _anchorX = target._anchorX, _anchorY = target._anchorY, width = target.width, height = target.height, parent_1 = target.parent;
                        dragPosition.x = Math.max(pivotX * scaleX + width * _anchorX * scaleX, dragPosition.x);
                        dragPosition.x = Math.min(dragPosition.x, parent_1.width - (width - pivotX) * scaleX + width * _anchorX * scaleX);
                        dragPosition.y = Math.max(pivotY * scaleY + height * _anchorY * scaleY, dragPosition.y);
                        dragPosition.y = Math.min(dragPosition.y, parent_1.height - (height - pivotY) * scaleY + height * _anchorY * scaleY);
                    }
                    if (Utils_1.debug) { //debug 模式下，日志信息
                        var stage = target.stage;
                        if (stage) {
                            stage.sendToPlayer({
                                code: Index_1.ComponentEvent.DRAG_MOVE,
                                level: 'info',
                                target: target,
                                data: [target.parent, dragPosition.x, dragPosition.y],
                                action: e.type,
                                message: 'parent,move pos'
                            });
                        }
                    }
                    _this._dragState = 2;
                    target.setPosition(dragPosition.x, dragPosition.y);
                    target.emit(Index_1.ComponentEvent.DRAG_MOVE, target, e);
                }
            };
            this.drag.onDragEnd = function (e) {
                if (_this.dragging && _this.collision) {
                    _this.checkCollision(e);
                }
                if (_this.dragging) {
                    _this.dragging = false;
                    //如果没有可被放置掉落的容器，0秒后返回原容器
                    // TickerShared.addOnce(() => {
                    if (_this.target == undefined) {
                        return;
                    }
                    //dragBounces
                    var target = _this.target;
                    var parent_2 = _this.$targetParent;
                    target.interactive = true;
                    target.interactiveChildren = _this.oldInteractiveChildren;
                    var item = Index_1.DragDropController.getItem(target);
                    var dragPosition = _this._dragPosition;
                    target.emit(Index_1.ComponentEvent.DRAG_END_BEFORE, target, e);
                    if (item && parent_2) {
                        if (target.parent !== parent_2 && target.parent) {
                            parent_2.container.toLocal(target.container.position, target.container.parent, dragPosition);
                            parent_2.addChild(target);
                            target.x = dragPosition.x;
                            target.y = dragPosition.y;
                        }
                        target.scaleX = _this.oldLocalTransform.a / target.container.transform._cx;
                        target.scaleY = _this.oldLocalTransform.d / target.container.transform._sy;
                        if (_this.dragBounces) {
                            // target.x = this.oldLocalTransform.tx;
                            // target.y = this.oldLocalTransform.ty;
                            target.setPosition(_this.oldLocalTransform.tx + ((target.container.transform.pivot.x * _this.oldLocalTransform.a) + (target.container.transform.pivot.y * _this.oldLocalTransform.c)), _this.oldLocalTransform.ty + ((target.container.transform.pivot.x * _this.oldLocalTransform.b) + (target.container.transform.pivot.y * _this.oldLocalTransform.d))); //by ziye+
                        }
                    }
                    if (Utils_1.debug) { //debug 模式下，日志信息
                        var stage = target.stage;
                        if (stage) {
                            stage.sendToPlayer({
                                code: Index_1.ComponentEvent.DRAG_END,
                                level: 'info',
                                target: target,
                                data: [target.parent, target.x, target.y],
                                action: e.type,
                                message: 'parent,end pos'
                            });
                        }
                    }
                    if (target.stage && target.stage.app) {
                        target.stage.app.view.style.cursor = target.style.cursor;
                    }
                    _this._dragState = 3;
                    e.data.tiltX = dragPosition.x;
                    e.data.tiltY = dragPosition.y;
                    target.emit(Index_1.ComponentEvent.DRAG_END, target, e);
                    // }, this)
                }
            };
        }
    };
    UIBaseDrag.prototype.checkCollision = function (e) {
        if (!this.target)
            return;
        var dragTarget = this.target;
        var dropTargets = Index_1.DragDropController.getDropTargets(this.dragGroup);
        if (dropTargets.length == 0)
            return;
        var dragTargetRect = new vf.Rectangle();
        var offset = 0;
        if (dragTarget.anchorX !== undefined) {
            offset = dragTarget.container.width * dragTarget.anchorX - dragTarget.pivotX * dragTarget.scaleX;
        }
        dragTargetRect.x = dragTarget.x - offset;
        if (dragTarget.anchorY !== undefined) {
            offset = dragTarget.container.height * dragTarget.anchorY - dragTarget.pivotY * dragTarget.scaleY;
        }
        dragTargetRect.y = dragTarget.y - offset;
        dragTargetRect.width = dragTarget.container.width;
        dragTargetRect.height = dragTarget.container.height;
        for (var i = 0; i < dropTargets.length; ++i) {
            var dropTarget = dropTargets[i];
            dragTarget.parent && dragTarget.parent.container.toLocal(dropTarget.container.position, dropTarget.container.parent, this._dropPosition);
            var dropTargetRect = new vf.Rectangle();
            var offset_1 = 0;
            if (dropTarget.anchorX !== undefined) {
                offset_1 = dropTarget.width * dropTarget.scaleX * dropTarget.anchorX - dropTarget.pivotX * dropTarget.scaleX;
            }
            dropTargetRect.x = this._dropPosition.x - offset_1;
            if (dropTarget.anchorY !== undefined) {
                offset_1 = dropTarget.height * dropTarget.scaleY * dropTarget.anchorY - dropTarget.pivotY * dropTarget.scaleY;
            }
            dropTargetRect.y = this._dropPosition.y - offset_1;
            dropTargetRect.width = dropTarget.width * dropTarget.scaleX;
            dropTargetRect.height = dropTarget.height * dropTarget.scaleY;
            if (this.checkBump(dragTargetRect, dropTargetRect)) {
                //碰撞检测通过，掉落
                dropTarget.dragOption.onDrop(e);
                break;
            }
        }
    };
    UIBaseDrag.prototype.checkBump = function (origin, target) {
        if (origin.y > target.y + target.height || // 在目标下方
            origin.y + origin.height < target.y || // 在目标上方
            origin.x > target.x + target.width || // 在目标右边
            origin.x + origin.width < target.x // 在目标左边
        ) {
            return false;
        }
        else {
            console.log('dragAndDrop-----collision----true');
            return true;
        }
    };
    UIBaseDrag.prototype.clearDroppable = function () {
        if (this.target == undefined) {
            return;
        }
        var target = this.target;
        if (this.dropInitialized) {
            this.dropInitialized = false;
            target.container.off("mouseup" /* mouseup */, this.onDrop, this);
            target.container.off("touchend" /* touchend */, this.onDrop, this);
        }
        Index_1.DragDropController.removeDropTarget(target); // by ziye+
    };
    UIBaseDrag.prototype.initDroppable = function () {
        if (this.target == undefined) {
            return;
        }
        var target = this.target;
        if (!this.dropInitialized) {
            this.dropInitialized = true;
            var container = target.container;
            //self = this;
            container.interactive = true;
            container.on("mouseup" /* mouseup */, this.onDrop, this);
            container.on("touchend" /* touchend */, this.onDrop, this);
        }
    };
    UIBaseDrag.prototype.onDrop = function (e) {
        if (this.target == undefined) {
            return;
        }
        if (this.target.stage && this.target.stage.syncInteractiveFlag) {
            SyncManager_1.SyncManager.getInstance(this.target.stage).collectEvent(e, this.target);
        }
        var target = this.target;
        var item = Index_1.DragDropController.getEventItem(e, this.dropGroup);
        if (item && item.dragOption.dragging) {
            item.dragOption.dragging = false;
            item.interactive = true;
            var dragPosition = this._dragPosition;
            var parent_3 = item.dragOption.droppableReparent !== undefined ? item.dragOption.droppableReparent : target;
            if (parent_3) {
                parent_3.container.toLocal(item.container.position, item.container.parent, dragPosition);
                item.x = dragPosition.x;
                item.y = dragPosition.y;
                // item.scaleX = this.oldLocalTransform.a;
                // item.scaleY = this.oldLocalTransform.d;
                item.scaleX = this.oldLocalTransform.a / item.container.transform._cx;
                item.scaleY = this.oldLocalTransform.d / item.container.transform._sy;
                // debugger
                if (parent_3 != item.parent) {
                    parent_3.addChild(item);
                    parent_3.emit(Index_1.ComponentEvent.DROP_TARGET, parent_3, item, e);
                }
                item.dragOption.$targetParent = parent_3;
            }
            if (Utils_1.debug) { //debug 模式下，日志信息
                var stage = target.stage;
                if (stage) {
                    stage.sendToPlayer({
                        code: Index_1.ComponentEvent.DRAG_TARGET,
                        level: 'info',
                        target: item,
                        data: [target.parent, item.x, item.y],
                        action: e.type,
                        message: 'drag target,item pos'
                    });
                }
            }
            if (target.stage && target.stage.app) {
                var interaction = target.stage.app.renderer.plugins.interaction;
                interaction.cursor = target.style.cursor;
            }
            this._dragState = 4;
            e.data.tiltX = dragPosition.x;
            e.data.tiltY = dragPosition.y;
            item.invalidateParentLayout();
            item.emit(Index_1.ComponentEvent.DRAG_TARGET, item, e);
        }
    };
    /**
     * 同步数据临时的方法
     */
    UIBaseDrag.prototype.executeDrop = function (e, parsentPath) {
        if (this.target && this.target.stage && parsentPath) {
            var parent_4 = this.target.stage.getChildByPath(parsentPath);
            var item = this.target;
            item.dragOption.dragging = false;
            item.interactive = true;
            if (parent_4) {
                item.x = this._dragPosition.x;
                item.y = this._dragPosition.y;
                if (parent_4 != item.parent) {
                    parent_4.addChild(item);
                    parent_4.emit(Index_1.ComponentEvent.DROP_TARGET, parent_4, item, e);
                }
                this.$targetParent = parent_4;
                item.emit(Index_1.ComponentEvent.DRAG_TARGET, item, e);
            }
        }
    };
    UIBaseDrag.prototype.load = function () {
        //
    };
    UIBaseDrag.prototype.release = function () {
        this.clearDraggable();
        this.clearDroppable();
        if (this.target) {
            this.target.plugs.delete(UIBaseDrag.key);
            this.target = undefined;
            this.$targetParent = undefined;
            this.dragContainer = undefined;
        }
    };
    UIBaseDrag.key = "UIBaseDrag";
    return UIBaseDrag;
}());
exports.UIBaseDrag = UIBaseDrag;


/***/ }),

/***/ "./src/core/plugs/UIClick.ts":
/*!***********************************!*\
  !*** ./src/core/plugs/UIClick.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIClick = void 0;
var Index_1 = __webpack_require__(/*! ../../interaction/Index */ "./src/interaction/Index.ts");
/**
 *  组件的单击操作
 *
 */
var UIClick = /** @class */ (function () {
    /**
     * 构造函数
     */
    function UIClick(target) {
        this._target = target;
        this._target.plugs.set(UIClick.key, this);
        this._clickEvent = new Index_1.ClickEvent(target, true);
    }
    Object.defineProperty(UIClick.prototype, "double", {
        get: function () {
            return this._clickEvent.double;
        },
        set: function (value) {
            this._clickEvent.double = value;
        },
        enumerable: false,
        configurable: true
    });
    UIClick.prototype.load = function () {
        //
    };
    UIClick.prototype.release = function () {
        this._clickEvent.remove();
        if (this._target) {
            this._target.plugs.delete(UIClick.key);
            this._target = undefined;
        }
    };
    UIClick.key = "UIClick";
    return UIClick;
}());
exports.UIClick = UIClick;


/***/ }),

/***/ "./src/display/Alert.ts":
/*!******************************!*\
  !*** ./src/display/Alert.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Alert = void 0;
/**
 * 需求分析：
 * 1.皮肤可以自定义，包括背景、每个按钮、关闭按钮
 * 2.按钮数量可以自定义
 * 3.可以没有关闭按钮
 * 4.同一个弹框对象可以修改属性，包括title、content、button
 * 5.按钮的回调
 * 6.持续时间，到期后自动关闭
 */
var Label_1 = __webpack_require__(/*! ./Label */ "./src/display/Label.ts");
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Image_1 = __webpack_require__(/*! ./Image */ "./src/display/Image.ts");
var Rect_1 = __webpack_require__(/*! ./Rect */ "./src/display/Rect.ts");
var Scheduler_1 = __webpack_require__(/*! ../core/Scheduler */ "./src/core/Scheduler.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var Container_1 = __webpack_require__(/*! ./Container */ "./src/display/Container.ts");
var Alert = /** @class */ (function (_super) {
    __extends(Alert, _super);
    function Alert() {
        var _this = _super.call(this) || this;
        /**
         * 弹框标题
         */
        _this._title = "";
        /**
         * 弹框内容
         */
        _this._content = "";
        /**
         * 按钮内容
         */
        _this._buttons = [];
        _this._imgButtons = [];
        /**
         * 自动弹出
         */
        _this.autoShow = false;
        /**
         * 自动释放
         */
        _this.autoRelease = false;
        /**
         * 持续时间
         */
        _this.duration = 0;
        /**
         * 内容对齐方式  //left  center
         */
        _this.textAlign = 'left';
        /**
         * 按钮默认宽高
         */
        _this.buttonWidth = 80;
        _this.buttonHeight = 30;
        /**
         * 背景遮罩颜色透明度
         */
        _this.maskColor = 0;
        _this.maskOpacity = 0.1;
        _this.backgroundColor = 0xeeeeee;
        _this.titleColor = 0;
        _this.contentColor = 0x333333;
        _this.btnColors = [0x1057d5, 0xdddddd, 0xd10043, 0xdddddd];
        _this.btnTextColors = [0xeeeeee, 0x333333, 0xeeeeee, 0x333333];
        /**
         * 显示状态
         */
        _this._isShowing = false;
        _this._buttonsDisplays = [];
        _this.visible = false;
        _this.scaleX = _this.scaleY = 0.01;
        _this.width = 300;
        _this.height = 100;
        return _this;
    }
    Alert.show = function (container, content, textAlign, duration, icon, title, buttons, x, y) {
        if (textAlign === void 0) { textAlign = 'center'; }
        if (duration === void 0) { duration = 2000; }
        var alert = new Alert();
        alert.title = title || '';
        alert.content = content || '';
        alert.buttons = buttons || [];
        alert.duration = duration || 0;
        alert.icon = icon;
        alert.autoShow = true;
        alert.textAlign = textAlign;
        alert.x = x || (container.width / 2);
        alert.y = y || (container.height / 2);
        container.addChild(alert);
        return alert;
    };
    Object.defineProperty(Alert.prototype, "title", {
        get: function () {
            return this._title;
        },
        set: function (value) {
            this._title = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Alert.prototype, "content", {
        get: function () {
            return this._content;
        },
        set: function (value) {
            this._content = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Alert.prototype, "buttons", {
        get: function () {
            return this._buttons;
        },
        set: function (value) {
            this._buttons = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Alert.prototype, "imgButtons", {
        get: function () {
            return this._imgButtons;
        },
        set: function (value) {
            this._imgButtons = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Alert.prototype.commitProperties = function () {
        this.initDisplay();
        if (this.autoShow) {
            this.show();
        }
    };
    /**
     * 初始化显示
     */
    Alert.prototype.initDisplay = function () {
        var _this = this;
        //mask
        var mask = new Rect_1.Rect();
        mask.color = this.maskColor;
        mask.alpha = this.maskOpacity;
        mask.width = mask.height = 2000;
        mask.anchorX = mask.anchorY = 0.5;
        mask.interactabled = true;
        mask.on(Index_1.TouchMouseEvent.onPress, function () {
            //do nothing
        });
        this.addChild(mask);
        //bg
        if (this.background !== undefined && this.background !== '') {
            this._bgDisplay = new Image_1.Image();
            this._bgDisplay.src = this.background;
        }
        else {
            this._bgDisplay = new Rect_1.Rect();
            this._bgDisplay.color = this.backgroundColor;
            this._bgDisplay.radius = 10; //圆角
        }
        this._bgDisplay.anchorX = 0.5;
        this._bgDisplay.anchorY = 0.5;
        this.addChild(this._bgDisplay);
        //icon
        if (this.icon !== undefined && this.icon !== '') {
            this._iconDisplay = new Image_1.Image();
            this._iconDisplay.src = this.icon;
            this._iconDisplay.anchorX = this._iconDisplay.anchorY = 0.5;
            this._iconDisplay.width = 50;
            this._iconDisplay.height = 50;
            this.addChild(this._iconDisplay);
        }
        if (this.title) {
            this._titleDisplay = new Label_1.Label();
            this._titleDisplay.text = this.title;
            this.addChild(this._titleDisplay);
            this._titleDisplay.style.fontSize = 20;
            this._titleDisplay.color = this.titleColor;
            this._lineDisplay = new Rect_1.Rect();
            this._lineDisplay.width = this.width - 40;
            this._lineDisplay.height = 2;
            this._lineDisplay.color = this.titleColor;
            this._lineDisplay.anchorY = this._lineDisplay._anchorX = 0.5;
            this._lineDisplay.alpha = 0.2;
            this.addChild(this._lineDisplay);
        }
        if (this.content) {
            this._contentDisplay = new Label_1.Label();
            this._contentDisplay.text = this.content;
            this._contentDisplay.color = this.contentColor;
            this._contentDisplay.style.fontSize = 19;
            if (this._iconDisplay) {
                this._contentDisplay.style.wordWrap = true;
                this._contentDisplay.style.wordWrapWidth = this.width - 60 - 80; //有icon时，内容靠右显示
            }
            else {
                this._contentDisplay.style.wordWrap = true;
                this._contentDisplay.style.wordWrapWidth = this.width - 60;
            }
            this.addChild(this._contentDisplay);
        }
        //buttons
        if (this.imgButtons.length > 0) {
            this.imgButtons.forEach(function (item, index) {
                var btnContainer = new Container_1.Container();
                _this.addChild(btnContainer);
                var btn = new Image_1.Image();
                btn.src = item.btnNormal;
                btnContainer.addChild(btn);
                btn.id = index + "_imgButton";
                btn.interactabled = true;
                btn.anchorY = btn.anchorX = 0.5;
                btn.width = _this.buttonWidth;
                btn.height = _this.buttonHeight;
                _this._buttonsDisplays.push(btn);
                btn.on(Index_1.TouchMouseEvent.onHover, _this.onHover, _this);
                btn.on(Index_1.TouchMouseEvent.onPress, _this.onPress, _this);
                btn.on(Index_1.TouchMouseEvent.onClick, _this.onClick, _this);
                if (item.text) {
                    var label = new Label_1.Label();
                    label.text = item.text;
                    label.style.fontSize = 20;
                    label.color = _this.btnTextColors[index];
                    btnContainer.addChild(label);
                    label.pivotX = label.width / 2;
                    label.pivotY = label.height / 2;
                    if (btn.width < label.width + 20) {
                        btn.width = label.width + 20;
                    }
                }
                btn.height = 35;
            });
        }
        else if (this.buttons.length > 0) {
            this.buttons.forEach(function (item, index) {
                var btnContainer = new Container_1.Container();
                _this.addChild(btnContainer);
                var btn = null;
                if (_this.btnNormal !== undefined && _this.btnNormal !== '') {
                    btn = new Image_1.Image();
                    btn.src = _this.btnNormal;
                    btn.id = index + "_image";
                }
                else {
                    btn = new Rect_1.Rect();
                    if (_this.btnColors.length > index) {
                        btn.color = _this.btnColors[index];
                    }
                    btn.radius = 5;
                    btn.lineWidth = 1;
                    btn.lineColor = 0x888888;
                    btn.id = index + "_rect";
                }
                btn.interactabled = true;
                btn.anchorY = btn.anchorX = 0.5;
                btnContainer.addChild(btn);
                _this._buttonsDisplays.push(btn);
                btn.on(Index_1.TouchMouseEvent.onHover, _this.onHover, _this);
                btn.on(Index_1.TouchMouseEvent.onPress, _this.onPress, _this);
                btn.on(Index_1.TouchMouseEvent.onClick, _this.onClick, _this);
                var label = new Label_1.Label();
                label.text = item;
                label.style.fontSize = 20;
                label.color = _this.btnTextColors[index];
                btnContainer.addChild(label);
                label.pivotX = label.width / 2;
                label.pivotY = label.height / 2;
                btn.height = 30;
                btn.width = label.width + 20;
            });
        }
        this._updateDisplayList();
    };
    Alert.prototype._updateDisplayList = function () {
        //实现布局
        var _height = 0; // title
        if (this._titleDisplay) {
            _height += 40;
        }
        _height += 90;
        if (this._contentDisplay) {
            var offsetY = this._contentDisplay.height - 50 > 0 ? this._contentDisplay.height - 50 : 0;
            _height += offsetY;
        }
        if (this._buttonsDisplays.length > 0) {
            _height += 40; // buttons
        }
        this.height = _height;
        if (this._bgDisplay) {
            this._bgDisplay.width = this.width;
            this._bgDisplay.height = this.height;
        }
        var offY = -this.height / 2;
        var offX = 0;
        if (this._titleDisplay) {
            this._titleDisplay.pivotX = this._titleDisplay.width / 2;
            this._titleDisplay.pivotY = this._titleDisplay.height / 2;
            this._titleDisplay.x = 0;
            this._titleDisplay.y = offY + 25;
            offY += 40;
            if (this._lineDisplay) {
                this._lineDisplay.y = offY;
            }
        }
        if (this._iconDisplay) {
            this._iconDisplay.x = -this.width / 2 + 60;
            if (this._contentDisplay) {
                var offsetY = this._contentDisplay.height - 50 > 0 ? this._contentDisplay.height - 50 : 0;
                this._iconDisplay.y = offY + 45 + offsetY / 2;
            }
        }
        if (this._contentDisplay) {
            this._contentDisplay.pivotX = this._contentDisplay.width / 2;
            this._contentDisplay.pivotY = this._contentDisplay.height / 2;
            var offsetY = this._contentDisplay.height - 50 > 0 ? this._contentDisplay.height - 50 : 0;
            this._contentDisplay.y = offY + 45 + offsetY / 2;
            if (this._iconDisplay) {
                this._contentDisplay.x = -this.width / 2 + 80 + 30 + this._contentDisplay.width / 2;
            }
            else {
                if (this.textAlign == 'left') {
                    this._contentDisplay.x = -this.width / 2 + 30 + this._contentDisplay.width / 2;
                }
                else {
                    this._contentDisplay.x = 0;
                }
            }
            offY += offsetY;
        }
        offY += 90;
        //计算最宽的button
        var maxWidth = 0;
        for (var i = 0; i < this._buttonsDisplays.length; ++i) {
            var item = this._buttonsDisplays[i];
            if (item.width > maxWidth) {
                maxWidth = item.width;
            }
        }
        var btnX = -(this._buttonsDisplays.length * (maxWidth + 20) - 20) / 2;
        for (var i = 0; i < this._buttonsDisplays.length; ++i) {
            var item = this._buttonsDisplays[i];
            var btnContainer = item.parent;
            item.width = maxWidth;
            btnContainer.x = btnX + maxWidth / 2;
            btnX += maxWidth + 20;
            btnContainer.y = offY + item.height / 2;
        }
        this.scaleX = this.scaleY = 1;
    };
    /**
     * 显示弹出框
     */
    Alert.prototype.show = function () {
        var _this = this;
        if (this._isShowing)
            return;
        this.emit('SHOWED', this);
        this._isShowing = true;
        this.visible = true;
        this.scaleX = this.scaleY = 1;
        if (this.duration > 0) {
            Scheduler_1.Scheduler.setTimeout(this.duration, function () {
                _this.close();
            });
        }
    };
    /**
     * 关闭弹出框
     */
    Alert.prototype.close = function () {
        if (!this._isShowing)
            return;
        this.emit('CLOSED', this);
        this._isShowing = false;
        this.visible = false;
        if (this.autoRelease) {
            this.releaseAll();
        }
    };
    /**
     * 释放
     */
    Alert.prototype.release = function () {
        _super.prototype.release.call(this);
    };
    Alert.prototype.onHover = function (e, thisObj, over) {
        var arr = thisObj.id.split('_');
        var index = parseInt(arr[0]);
        var type = arr[1];
        if (over) {
            thisObj.style.cursor = 'pointer';
            if (type == 'rect') {
                thisObj.alpha = 0.9;
            }
            else if (type == 'image') {
                thisObj.src = this.btnHover;
            }
            else {
                thisObj.src = this.imgButtons[index].btnHover;
            }
        }
        else {
            thisObj.style.cursor = '';
            if (type == 'rect') {
                thisObj.alpha = 1;
            }
            else if (type == 'image') {
                thisObj.src = this.btnNormal;
            }
            else {
                thisObj.src = this.imgButtons[index].btnNormal;
            }
        }
    };
    Alert.prototype.onPress = function (e, thisObj, isPressed) {
        var arr = thisObj.id.split('_');
        var index = parseInt(arr[0]);
        var type = arr[1];
        if (isPressed) {
            if (type == 'rect') {
                thisObj.alpha = 0.8;
            }
            else if (type == 'image') {
                thisObj.src = this.btnPressed;
            }
            else {
                thisObj.src = this.imgButtons[index].btnPressed;
            }
        }
        else {
            if (type == 'rect') {
                thisObj.alpha = 1;
            }
            else if (type == 'image') {
                thisObj.src = this.btnNormal;
            }
            else {
                thisObj.src = this.imgButtons[index].btnNormal;
            }
        }
    };
    Alert.prototype.onClick = function (e, thisObj) {
        var arr = thisObj.id.split('_');
        var buttonIndex = parseInt(arr[0]);
        this.emit('CLICKBUTTON', this, buttonIndex);
    };
    return Alert;
}(DisplayObject_1.DisplayObject));
exports.Alert = Alert;


/***/ }),

/***/ "./src/display/Arrow.ts":
/*!******************************!*\
  !*** ./src/display/Arrow.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Arrow = void 0;
var LineGradient_1 = __webpack_require__(/*! ../core/plugs/LineGradient */ "./src/core/plugs/LineGradient.ts");
var GraphBase_1 = __webpack_require__(/*! ./private/GraphBase */ "./src/display/private/GraphBase.ts");
var Arrow = /** @class */ (function (_super) {
    __extends(Arrow, _super);
    function Arrow() {
        var _this = _super.call(this) || this;
        _this._angle = Math.PI / 6; //长边与其中一边夹角30度
        return _this;
    }
    Arrow.prototype.drawGraph = function () {
        var graphics = this.graphics;
        graphics.clear();
        if (this._lineWidth < 0) {
            console.log("属性错误，线宽需要大于0");
            return;
        }
        graphics.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha, 0.5, false, this.lineType);
        if (this.width > 0 && this.height > 0) {
            //长线
            var w = this._anchorX ? this.width * this._anchorX : 0;
            var h = this._anchorY ? this.height * this._anchorY : 0;
            graphics.moveTo(0 - w, this.height * 0.5 - h);
            graphics.lineTo(this.width - w, this.height * 0.5 - h);
            // 三角
            var path = this.getArrowPath();
            var full = false;
            if (this.color) {
                graphics.beginFill(this._color, this._fillAlpha);
                full = true;
            }
            else {
                if (LineGradient_1.updateTextureFill(this.graphics, this)) { // 按整个箭头的宽高进行填充，并不是三角形箭头部分
                    full = true;
                }
            }
            graphics.drawPolygonOne(path, full);
            graphics.endFill();
        }
    };
    Arrow.prototype.getArrowPath = function () {
        var w = this._anchorX ? this.width * this._anchorX : 0;
        var h = this._anchorY ? this.height * this._anchorY : 0;
        var path = [];
        var angle = this._angle;
        var height = this.height;
        var width = this.width;
        var xD = height * 0.5 * Math.tan(Math.PI / 2 - angle);
        var yD = height * 0.5;
        var x = width - xD;
        var point1 = new vf.Point(x - w, 0 - h);
        var point2 = new vf.Point(width - w, yD - h);
        var point3 = new vf.Point(x - w, yD * 2 - h);
        path.push(point1, point2, point3);
        return path;
    };
    return Arrow;
}(GraphBase_1.GraphBase));
exports.Arrow = Arrow;


/***/ }),

/***/ "./src/display/Audio.ts":
/*!******************************!*\
  !*** ./src/display/Audio.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Audio = exports.PlayerStates = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var AudioGroupController_1 = __webpack_require__(/*! ../interaction/AudioGroupController */ "./src/interaction/AudioGroupController.ts");
/**
 * 音频组件
 *
 * 准备完成 canplaythrough
 *
 * 播放事件 play
 *
 * 暂停事件 pause
 *
 * 错误事件 error
 *
 * 播放时间改变 timeupdate
 *
 * 播放完成 ended
 *
 * @example let audio = new vf.gui.Audio();
 *
 *
 */
var PlayerStates;
(function (PlayerStates) {
    PlayerStates["init"] = "init";
    PlayerStates["play"] = "play";
    PlayerStates["pause"] = "pause";
    PlayerStates["end"] = "end"; //结束
})(PlayerStates = exports.PlayerStates || (exports.PlayerStates = {}));
var Audio = /** @class */ (function (_super) {
    __extends(Audio, _super);
    function Audio() {
        var _this = _super.call(this) || this;
        _this._autoplay = false;
        _this._loop = false;
        _this._playbackRate = 1;
        _this._volume = 1;
        _this._audioUid = ""; // IAudio 的唯一id
        _this._playerStates = PlayerStates.init;
        _this._id = Utils_1.now().toString();
        _this._audioUid = _this.uuid.toString();
        _this.audioGroup = "";
        vf.utils.deprecation("1.0.0", "在互动课件环境，Audio组件仅支持最基础的播放、暂停功能。");
        return _this;
    }
    Object.defineProperty(Audio.prototype, "audioUid", {
        set: function (value) {
            this._audioUid = value;
        },
        enumerable: false,
        configurable: true
    });
    Audio.prototype.initAudio = function () {
        var _this = this;
        var o = {
            autoplay: this._autoplay,
            loop: this._loop,
            playbackRate: this._playbackRate,
            volume: this._volume
        };
        this.audio = vf.AudioEngine.Ins().createAudio(this._audioUid, this._src, o);
        /**
        * 需要上报的事件
        */
        this.audio.on("canplay", function (e) {
            _this.emit("canplay", e);
        }, this);
        this.audio.on("canplaythrough", function (e) {
            _this.emit("canplaythrough", e);
        }, this);
        this.audio.on("play", function (e) {
            _this.emit("play", e);
        }, this);
        this.audio.on("pause", function (e) {
            _this.emit("pause", e);
        }, this);
        this.audio.on("error", function (e) {
            _this.emit("error", e);
        }), this;
        this.audio.on("timeupdate", function (e, f) {
            _this.emit("timeupdate", e, f);
        });
        this.audio.on("ended", function (e) {
            _this.emit("ended", e);
            _this.dispose();
        }, this);
    };
    Object.defineProperty(Audio.prototype, "src", {
        get: function () {
            return this._src;
        },
        //支持的参数们~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        /**
        * 设置src 支持3种 url base64 arraybuffer;
        */
        set: function (value) {
            var o = Utils_1.getSound(value);
            if (typeof (o) === "object" && o.url) {
                this._src = o.url;
            }
            else {
                this._src = value;
            }
            this.audio && this.dispose();
            this._playerStates = PlayerStates.init;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Audio.prototype, "autoplay", {
        get: function () {
            return this._autoplay;
        },
        set: function (value) {
            this._autoplay = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Audio.prototype, "loop", {
        get: function () {
            if (this.audio) {
                return this.audio.loop;
            }
            return false;
        },
        set: function (value) {
            this._loop = value;
            if (this.audio) {
                this.audio.loop = this._loop;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Audio.prototype, "playbackRate", {
        get: function () {
            if (this.audio) {
                return this.audio.playbackRate;
            }
            return 0;
        },
        set: function (value) {
            this._playbackRate = value;
            if (this.audio) {
                this.audio.playbackRate = this._playbackRate;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Audio.prototype, "volume", {
        get: function () {
            if (this.audio) {
                return this.audio.volume;
            }
            return 0;
        },
        set: function (value) {
            this._volume = value;
            if (this.audio) {
                this.audio.volume = this._volume;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Audio.prototype, "duration", {
        /*只读的属性们*/
        get: function () {
            if (this.audio) {
                return this.audio.duration;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Audio.prototype, "paused", {
        get: function () {
            if (this.audio) {
                return this.audio.paused;
            }
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Audio.prototype, "audioGroup", {
        /**
        * 设置分组名
        */
        get: function () {
            return this._groupName;
        },
        set: function (value) {
            if (value === undefined) {
                AudioGroupController_1.unRegistrerAudioGroup(this);
            }
            if (this._groupName == value) {
                return;
            }
            this._groupName = value; //需要在registrerCheckGroup之前
            AudioGroupController_1.registrerAudioGroup(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Audio.prototype, "playerStates", {
        get: function () {
            return this._playerStates;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Audio.prototype, "isPlaying", {
        get: function () {
            if (this._playerStates === PlayerStates.play) {
                return true;
            }
            return false;
        },
        enumerable: false,
        configurable: true
    });
    /**
    * 支持的方法们~~~··~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    *    */
    /**
     * 声音播放接口
     *
     *  await sound.play()
     * @param {number} [time] - 声音延迟开始
     * @param {number} [offset] - 声音的开始偏移值
     * @param {number} [length] - 声音持续时间（以秒为单位）
     */
    Audio.prototype.play = function (time, offset, length) {
        var _a;
        //如果处于恢复状态，不播放声音
        this._playerStates = PlayerStates.play;
        AudioGroupController_1.updateAudioGroupStates(this);
        if (((_a = this.stage) === null || _a === void 0 ? void 0 : _a.syncManager) && this.stage.syncManager.resumeStatusFlag) {
            return;
        }
        //在教室环境，使用nativeAudio
        if (this.useNativeAudio()) {
            this.nativeEmit(this._src, 'playAudio');
            this.emit("play", this);
            return;
        }
        if (!this.audio) {
            this.initAudio();
        }
        if (this.audio) {
            this.audio.play(time, offset, length);
        }
    };
    /**
    * 停止声音
    * @param time (optional) X秒后停止声音。默认情况下立即停止
    */
    Audio.prototype.stop = function (time) {
        //如果处于恢复状态，不播放声音
        var _this = this;
        var _a;
        if (((_a = this.stage) === null || _a === void 0 ? void 0 : _a.syncManager) && this.stage.syncManager.resumeStatusFlag) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var that = this;
        if (this.stoping)
            clearTimeout(this.stoping);
        if (time) {
            this.stoping = setTimeout(function () {
                _this._playerStates = PlayerStates.end;
                that.emit("stop", that); //这个事件貌似没有用 因为已经对外抛了end事件 以防万一 保留
            }, time);
        }
        else {
            this._playerStates = PlayerStates.end;
            this.emit("stop", this);
        }
        //在教室环境，使用nativeAudio
        if (this.useNativeAudio()) {
            this.nativeEmit(this._src, 'pauseAudio');
            return;
        }
        this.audio && this.audio.stop(time);
    };
    /**
    * 暂停声音
    */
    Audio.prototype.pause = function () {
        var _a;
        this._playerStates = PlayerStates.pause;
        //如果处于恢复状态，不播放声音
        if (((_a = this.stage) === null || _a === void 0 ? void 0 : _a.syncManager) && this.stage.syncManager.resumeStatusFlag) {
            return;
        }
        //在教室环境，使用nativeAudio
        if (this.useNativeAudio()) {
            this.nativeEmit(this._src, 'pauseAudio');
            this.emit("pause", this);
            return;
        }
        this.audio && this.audio.pause();
    };
    /**
    * 释放
    */
    Audio.prototype.dispose = function () {
        this._playerStates = PlayerStates.end;
        if (this.audio) {
            vf.AudioEngine.Ins().map.delete(this._audioUid);
            this.audio.removeAllListeners();
            this.audio.dispose();
            this.audio = undefined;
        }
        if (this.parent) {
            this.parent.removeChild(this);
        }
        //在教室环境，使用nativeAudio
        if (this.useNativeAudio()) {
            this.nativeEmit(this._src, 'pauseAudio');
            return;
        }
    };
    Audio.prototype.release = function () {
        _super.prototype.release.call(this);
        this.dispose();
    };
    /**
    * 各种可取参数.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    */
    Audio.prototype.commitProperties = function () {
        if (!this.audio) {
            this.initAudio();
        }
        if (this._autoplay) {
            this.play();
        }
    };
    Audio.prototype.useNativeAudio = function () {
        var _a, _b;
        return (_b = (_a = this.stage) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.vfvars.useNativeAudio;
    };
    Audio.prototype.nativeEmit = function (url, typeTag) {
        var _a;
        (_a = this.stage) === null || _a === void 0 ? void 0 : _a.getSystemEvent().emit('message', {
            code: 'native',
            type: 'native',
            level: 'command',
            data: {
                type: typeTag,
                src: url,
                id: this._audioUid,
                mode: 'sound',
                signalling: false,
            }
        });
    };
    return Audio;
}(DisplayObject_1.DisplayObject));
exports.Audio = Audio;


/***/ }),

/***/ "./src/display/AutoContainer.ts":
/*!**************************************!*\
  !*** ./src/display/AutoContainer.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoContainer = void 0;
var Scheduler_1 = __webpack_require__(/*! ../core/Scheduler */ "./src/core/Scheduler.ts");
var TimeLine_1 = __webpack_require__(/*! ../tween/TimeLine */ "./src/tween/TimeLine.ts");
var Tween_1 = __webpack_require__(/*! ../tween/Tween */ "./src/tween/Tween.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Container_1 = __webpack_require__(/*! ./Container */ "./src/display/Container.ts");
/**
 * 自动容器，提供各种组件的构造接口， timeline、tween、schedule的自动释放
 * 手写代码构建scene的最佳实践：
 * class Scene extends vf.gui.AutoContainer{
 *
 * }
 */
var AutoContainer = /** @class */ (function (_super) {
    __extends(AutoContainer, _super);
    function AutoContainer() {
        var _this = _super.call(this) || this;
        _this.idCountDict = {}; // id计数字典，用于生产不同的id
        _this.timeLineList = [];
        _this.tweenList = [];
        _this.schedulerList = [];
        return _this;
    }
    AutoContainer.prototype.createDisplayObject = function (moduleName, option, parent) {
        if (!parent) {
            parent = this;
        }
        if (!option.id) {
            this.idCountDict[moduleName] = this.idCountDict[moduleName] || 1;
            option.id = moduleName + "_" + this.idCountDict[moduleName]++;
        }
        return Utils_1.createDisplayObject(moduleName, option, parent);
    };
    AutoContainer.prototype.createTimeLine = function (option) {
        var timeLine = new TimeLine_1.TimeLine(option);
        this.timeLineList.push(timeLine);
        return timeLine;
    };
    AutoContainer.prototype.createTween = function (object) {
        var tween = new Tween_1.Tween(object);
        this.tweenList.push(tween);
        return tween;
    };
    AutoContainer.prototype.setTimeout = function (time, callFunc) {
        var scheduler = Scheduler_1.Scheduler.setTimeout(time, callFunc);
        this.schedulerList.push(scheduler);
        return scheduler;
    };
    AutoContainer.prototype.setInterval = function (time, callFunc) {
        var scheduler = Scheduler_1.Scheduler.setInterval(time, callFunc);
        this.schedulerList.push(scheduler);
        return scheduler;
    };
    AutoContainer.prototype.setEnterFrame = function (callFunc) {
        var scheduler = Scheduler_1.Scheduler.setEnterFrame(callFunc);
        this.schedulerList.push(scheduler);
        return scheduler;
    };
    AutoContainer.prototype.release = function () {
        this.idCountDict = {};
        for (var i = 0; i < this.timeLineList.length; ++i) {
            if (this.timeLineList[i]) {
                this.timeLineList[i].release();
            }
        }
        this.timeLineList = [];
        for (var i = 0; i < this.tweenList.length; ++i) {
            if (this.tweenList[i]) {
                this.tweenList[i].release();
            }
        }
        this.tweenList = [];
        for (var i = 0; i < this.schedulerList.length; ++i) {
            if (this.schedulerList[i]) {
                this.schedulerList[i].stop();
            }
        }
        this.schedulerList = [];
        _super.prototype.release.call(this);
    };
    return AutoContainer;
}(Container_1.Container));
exports.AutoContainer = AutoContainer;


/***/ }),

/***/ "./src/display/Button.ts":
/*!*******************************!*\
  !*** ./src/display/Button.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Button = void 0;
var Label_1 = __webpack_require__(/*! ./Label */ "./src/display/Label.ts");
var Image_1 = __webpack_require__(/*! ./Image */ "./src/display/Image.ts");
var InputBase_1 = __webpack_require__(/*! ./private/InputBase */ "./src/display/private/InputBase.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
/**
 * 按钮
 *
 * @example let button = new vf.gui.Button();
 *
 *
 */
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button() {
        var _this = _super.call(this) || this;
        _this._selectedStr = "";
        _this._oldState = "";
        _this._offsetY = 0;
        /** 状态展示 */
        _this.img = new Image_1.Image();
        /** 文字展示 */
        _this.label = new Label_1.Label();
        _this._text = "";
        _this.container.buttonMode = true;
        _this.img.fillMode = "scale";
        _this.img.scale9Grid = [3, 3, 3, 3];
        _this.addChild(_this.img);
        _this.label.sprite.style.fontSize = 18;
        _this.addChild(_this.label);
        _this.on(Index_1.ComponentEvent.STATE_CHANGE, _this.onStateChange, _this);
        return _this;
    }
    Object.defineProperty(Button.prototype, "text", {
        /**
         * 设置按钮的文本内容
         */
        get: function () {
            return this.label.text;
        },
        set: function (value) {
            this._text = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "textOffsetY", {
        /**
         *  文本偏移
         */
        get: function () {
            return this._offsetY;
        },
        set: function (value) {
            if (this._offsetY === value) {
                return;
            }
            this._offsetY = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Button.prototype.setSelected = function (value) {
        this._oldState = "";
        if (value) {
            this._selectedStr = "AndSelected";
        }
        else {
            this._selectedStr = "";
        }
        this.emit(Index_1.ComponentEvent.CHANGE, this);
        this.onStateChange(this, this.currentState);
    };
    Button.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        if (isNaN(this.explicitWidth) && isNaN(this.explicitHeight)) {
            return;
        }
        _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
        this.container.hitArea = new vf.Rectangle(0, 0, unscaledWidth, unscaledHeight);
        var img = this.img;
        if (this.width !== img.width) {
            img.width = unscaledWidth;
        }
        if (this.height !== img.height) {
            img.height = unscaledHeight;
        }
        var vh = unscaledHeight + this._offsetY;
        if (this.label.width !== unscaledWidth)
            this.label.width = unscaledWidth;
        if (this.label.height !== vh)
            this.label.height = vh;
        if (this.label.text !== this._text) {
            this.label.text = this._text;
        }
        this.onStateChange(this, this.currentState);
    };
    Button.prototype.release = function () {
        this.offAll(Index_1.ComponentEvent.STATE_CHANGE);
        this.img && this.img.parent && this.img.parent.removeChild(this.img);
        this.img.release();
        this.img = undefined;
        this.label && this.label.parent && this.label.parent.removeChild(this.label);
        this.label.release();
        this.label = undefined;
        this.removeAllListeners();
        _super.prototype.release.call(this);
    };
    Button.prototype.onStateChange = function (label, state) {
        if (this._oldState == state) {
            return;
        }
        this._oldState = state;
        this.img.src = this[state + this._selectedStr];
    };
    return Button;
}(InputBase_1.InputBase));
exports.Button = Button;


/***/ }),

/***/ "./src/display/CheckBox.ts":
/*!*********************************!*\
  !*** ./src/display/CheckBox.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckBox = void 0;
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var Button_1 = __webpack_require__(/*! ./Button */ "./src/display/Button.ts");
/**
 * 单选\复选框
 *
 * 设置checkGroup后，进行分组。 分组后，可理解为复选框。
 *
 * @example let checkBox = new vf.gui.CheckBox();
 *
 *
 */
var CheckBox = /** @class */ (function (_super) {
    __extends(CheckBox, _super);
    function CheckBox() {
        var _this = _super.call(this) || this;
        /**
         * 设置值
         */
        _this._value = "";
        /**
         * 设置是否选中
         * */
        _this._checked = false;
        return _this;
    }
    Object.defineProperty(CheckBox.prototype, "selectedValue", {
        /**
         * 获取或设置当前选中的值
         */
        get: function () {
            if (this.checkGroup) {
                return Index_1.InputController.getCheckGroupSelectedValue(this.checkGroup);
            }
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CheckBox.prototype, "checkGroup", {
        /**
         * 设置分组名
         */
        get: function () {
            return this._groupName;
        },
        set: function (value) {
            if (value === undefined) {
                Index_1.InputController.unRegistrerCheckGroup(this);
            }
            if (this._groupName == value) {
                return;
            }
            this._groupName = value; //需要在registrerCheckGroup之前
            Index_1.InputController.registrerCheckGroup(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CheckBox.prototype, "value", {
        /**
         * 获取设置默认值
         */
        get: function () {
            return this._value;
        },
        set: function (value) {
            if (value === this._value) {
                return;
            }
            this._value = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CheckBox.prototype, "checked", {
        /**
         * 设置是否选中
         * @default false
         */
        get: function () {
            return this._checked;
        },
        set: function (value) {
            if (value !== this._checked) {
                if (this.checkGroup)
                    Index_1.InputController.updateCheckGroupSelected(this);
                this._checked = value;
                this.setSelected(value);
                this._oldState = "";
            }
        },
        enumerable: false,
        configurable: true
    });
    CheckBox.prototype.onClick = function (e) {
        _super.prototype.onClick.call(this, e);
        if (this.checkGroup && this.checked)
            return;
        this.checked = !this.checked;
    };
    CheckBox.prototype.onLabelChange = function (label) {
        label.style.left = this.width;
        label.style.top = this.height - label.height >> 1;
    };
    CheckBox.prototype.release = function () {
        Index_1.InputController.unRegistrerCheckGroup(this);
        _super.prototype.release.call(this);
    };
    return CheckBox;
}(Button_1.Button));
exports.CheckBox = CheckBox;


/***/ }),

/***/ "./src/display/Circle.ts":
/*!*******************************!*\
  !*** ./src/display/Circle.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Circle = void 0;
var LineGradient_1 = __webpack_require__(/*! ../core/plugs/LineGradient */ "./src/core/plugs/LineGradient.ts");
var GraphBase_1 = __webpack_require__(/*! ./private/GraphBase */ "./src/display/private/GraphBase.ts");
/**
 * 绘制圆形
 *
 * 不设置 lineWidth 或 color 圆形不可见
 *
 * @example let circle = new vf.gui.Circle();
 *
 *
 */
var Circle = /** @class */ (function (_super) {
    __extends(Circle, _super);
    function Circle() {
        var _this = _super.call(this) || this;
        /**
         * 开始绘制角度
         */
        _this._startAngle = 0;
        /**
         * 结束角度
         */
        _this._endAngle = 360;
        /**
         * 逆时针绘制
         */
        _this._anticlockwise = false;
        return _this;
    }
    Object.defineProperty(Circle.prototype, "startAngle", {
        get: function () {
            return this._startAngle;
        },
        set: function (value) {
            this._startAngle = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Circle.prototype, "endAngle", {
        get: function () {
            return this._endAngle;
        },
        set: function (value) {
            this._endAngle = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Circle.prototype, "anticlockwise", {
        get: function () {
            return this._anticlockwise;
        },
        set: function (value) {
            this._anticlockwise = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Circle.prototype.drawGraph = function () {
        var graphics = this.graphics;
        graphics.clear();
        if (this._lineWidth < 0) {
            console.log("属性错误，线宽小于0");
            return;
        }
        graphics.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha, this._alignment, false, this.lineType);
        var radius = Math.ceil(this.explicitWidth || this.explicitHeight || this._radius * 2) / 2;
        var diameter = radius * 2;
        this.setActualSize(diameter, diameter);
        if (this.color) {
            graphics.beginFill(this._color, this._fillAlpha);
        }
        else {
            LineGradient_1.updateTextureFill(this.graphics, this);
        }
        graphics.arc(this._anchorX ? (0.5 - this._anchorX) * diameter : radius, this._anchorY ? (0.5 - this._anchorY) * diameter : radius, radius, this._startAngle, this._endAngle, this._anticlockwise);
        graphics.endFill();
    };
    return Circle;
}(GraphBase_1.GraphBase));
exports.Circle = Circle;


/***/ }),

/***/ "./src/display/ConnectLine.ts":
/*!************************************!*\
  !*** ./src/display/ConnectLine.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectLine = exports.play = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Tween_1 = __webpack_require__(/*! ../tween/Tween */ "./src/tween/Tween.ts");
exports.play = Symbol("play");
/**
 * 连线组件
 *
 *
 * @example let connectLine = new vf.gui.ConnectLine();
 *
 */
var ConnectLine = /** @class */ (function (_super) {
    __extends(ConnectLine, _super);
    function ConnectLine() {
        var _this = _super.call(this) || this;
        _this._lastStartPos = { x: NaN, y: NaN };
        _this._lastEndPos = { x: NaN, y: NaN };
        _this._play = 1;
        _this._autoPlay = true;
        _this._sourcePostion = [0, 0];
        _this._targetPostion = [0, 0];
        /**
         * 线条颜色
         */
        _this._lineColor = 0xffffff;
        /**
         * 线条粗细
         */
        _this._lineWidth = 1;
        _this._isAnimation = false;
        _this._speed = 500;
        _this.line = new vf.Graphics();
        _this.container.addChild(_this.line);
        return _this;
    }
    Object.defineProperty(ConnectLine.prototype, "play", {
        /**
         *  触发画线操作
         *
         *  属性 play = 1 触发画线，线条从source->target.
         *  属性 play = 2 触发画线，线条从target->source.
         */
        get: function () {
            return this._play;
        },
        set: function (value) {
            this.$values[exports.play] = true;
            this._play = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectLine.prototype, "autoPlay", {
        /**
         *  默认 autoPlay = true
         *
         *  autoPlay = true时，组件在设置source,target,sourcePostion,targetPostion后自动触发画线，线条从source->target.
         *
         *  autoPlay = false时，设置source,target,sourcePostion,targetPostion后不会触发画线，需调用 play.
         */
        get: function () {
            return this._autoPlay;
        },
        set: function (value) {
            this._autoPlay = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectLine.prototype, "source", {
        /**
         * 设置源显示对象
         */
        get: function () {
            return this._source;
        },
        set: function (value) {
            if (this._source === Utils_1.getDisplayObject(value, this)) {
                return;
            }
            this._source = Utils_1.getDisplayObject(value, this);
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectLine.prototype, "sourcePostion", {
        /**
         * 设置源显示对象位置
         */
        get: function () {
            return this._sourcePostion;
        },
        set: function (value) {
            if (this._sourcePostion === value) {
                return;
            }
            this._sourcePostion = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectLine.prototype, "target", {
        /**
         * 设置目标显示对象
         */
        get: function () {
            return this._target;
        },
        set: function (value) {
            if (this._target === Utils_1.getDisplayObject(value, this)) {
                return;
            }
            this._target = Utils_1.getDisplayObject(value, this);
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectLine.prototype, "targetPostion", {
        /**
         * 设置目标显示对象位置
         */
        get: function () {
            return this._targetPostion;
        },
        set: function (value) {
            if (this._targetPostion === value) {
                return;
            }
            this._targetPostion = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectLine.prototype, "lineColor", {
        get: function () {
            return this._lineColor;
        },
        set: function (value) {
            if (this._lineColor === value) {
                return;
            }
            var color = 0xffffff;
            color = Utils_1.hexToInt(value, color);
            this._lineColor = color;
            this.invalidateProperties();
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectLine.prototype, "lineWidth", {
        get: function () {
            return this._lineWidth;
        },
        set: function (value) {
            if (this._lineWidth === value) {
                return;
            }
            this._lineWidth = value;
            this.invalidateProperties();
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectLine.prototype, "isAnimation", {
        /**
         * 线条位置改变时，是否有动画
         */
        get: function () {
            return this._isAnimation;
        },
        set: function (value) {
            if (this._isAnimation === value) {
                return;
            }
            this._isAnimation = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConnectLine.prototype, "speed", {
        /**
         * 设置获取连线速度
         */
        get: function () {
            return this._speed;
        },
        set: function (value) {
            if (this._speed === value) {
                return;
            }
            this._speed = value;
        },
        enumerable: false,
        configurable: true
    });
    ConnectLine.prototype.commitProperties = function () {
        this.line.lineStyle(this.lineWidth, this.lineColor, this.alpha);
    };
    ConnectLine.prototype.getLocalPos = function (_linePostion, display) {
        var pos = { x: 0, y: 0 };
        if (display) {
            if (display.container.position.x === 0 && display.container.position.y === 0) {
                display.validateNow();
            }
            var startPos = this.container.parent.toLocal(display.container.position, display.container.parent);
            switch (_linePostion) {
                case 'leftTop':
                    pos = Utils_1.pointPlus(startPos, { x: 0, y: 0 });
                    break;
                case 'leftCenter':
                    pos = Utils_1.pointPlus(startPos, { x: 0, y: display.height >> 1 });
                    break;
                case 'leftBottom':
                    pos = Utils_1.pointPlus(startPos, { x: 0, y: display.height });
                    break;
                case 'centerTop':
                    pos = Utils_1.pointPlus(startPos, { x: display.width >> 1, y: 0 });
                    break;
                case 'center':
                    pos = Utils_1.pointPlus(startPos, { x: display.width >> 1, y: display.height >> 1 });
                    break;
                case 'centerBottom':
                    pos = Utils_1.pointPlus(startPos, { x: display.width >> 1, y: display.height });
                    break;
                case 'rightTop':
                    pos = Utils_1.pointPlus(startPos, { x: display.width, y: 0 });
                    break;
                case "rightCenter":
                    pos = Utils_1.pointPlus(startPos, { x: display.width, y: display.height >> 1 });
                    break;
                case 'rightBottom':
                    pos = Utils_1.pointPlus(startPos, { x: display.width, y: display.height });
                    break;
                default:
                    pos.x = startPos.x + _linePostion[0];
                    pos.y = startPos.y + _linePostion[1];
            }
        }
        else {
            if (Array.isArray(_linePostion)) {
                pos.x = _linePostion[0];
                pos.y = _linePostion[1];
            }
        }
        return pos;
    };
    ConnectLine.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        var _a = this, _source = _a._source, _target = _a._target, _sourcePostion = _a._sourcePostion, _targetPostion = _a._targetPostion, _lastStartPos = _a._lastStartPos, _lastEndPos = _a._lastEndPos, line = _a.line;
        var startPos = this.getLocalPos(_sourcePostion, _source);
        var endPos = this.getLocalPos(_targetPostion, _target);
        if (_lastStartPos.x !== startPos.x ||
            _lastStartPos.y !== startPos.y ||
            _lastEndPos.x !== endPos.x ||
            _lastEndPos.y !== endPos.y) {
            this._lastStartPos = startPos;
            this._lastEndPos = endPos;
            if (this._autoPlay) {
                this.animation();
            }
        }
        if (this.$values[exports.play] === true && !this._autoPlay) {
            this.$values[exports.play] = false;
            this.animation();
        }
        //super.updateDisplayList(unscaledWidth, unscaledHeight);     
    };
    ConnectLine.prototype.animation = function () {
        var _this = this;
        var yoyo = this._play;
        var line = this.line;
        var startPos = yoyo === 1 ? this._lastStartPos : this._lastEndPos;
        var endPos = yoyo === 1 ? this._lastEndPos : this._lastStartPos;
        line.removeChildren();
        if (!this.isAnimation) {
            line.moveTo(startPos.x, startPos.y);
            line.lineTo(endPos.x, endPos.y);
            this.emit(Index_1.ComponentEvent.COMPLETE, this);
            return;
        }
        var distance = Utils_1.pointDistance(startPos, endPos);
        var lastPos = { x: startPos.x, y: startPos.y };
        var from = { dt: 0 };
        var to = { dt: distance };
        var tw = new Tween_1.Tween(from)
            .to(to, this._speed)
            .on(Tween_1.Tween.Event.update, function (obj) {
            var dt = Math.ceil(obj.dt);
            var x = (dt * (endPos.x - startPos.x)) / distance + startPos.x;
            var y = (dt * (endPos.y - startPos.y)) / distance + startPos.y;
            line.moveTo(lastPos.x, lastPos.y);
            line.lineTo(x, y);
            lastPos.x = x;
            lastPos.y = y;
        })
            .once(Tween_1.Tween.Event.complete, function (obj) {
            tw.removeAllListeners();
            tw.release();
            _this.emit(Index_1.ComponentEvent.COMPLETE, _this);
        })
            .start();
        this._tw = tw;
    };
    Object.defineProperty(ConnectLine.prototype, "isClear", {
        set: function (value) {
            this.clear();
        },
        enumerable: false,
        configurable: true
    });
    ConnectLine.prototype.clear = function () {
        var line = this.line;
        if (line) {
            line.clear();
        }
        this.commitProperties();
    };
    ConnectLine.prototype.release = function () {
        _super.prototype.release.call(this);
        this._tw && this._tw.release();
        this._tw = undefined;
        this._source = undefined;
        this._target = undefined;
        var line = this.line;
        if (line && line.clear) {
            line.clear();
            if (line.parent) {
                line.parent.removeChild(line).destroy();
            }
        }
        this.offAll(Index_1.ComponentEvent.COMPLETE);
    };
    return ConnectLine;
}(DisplayObject_1.DisplayObject));
exports.ConnectLine = ConnectLine;


/***/ }),

/***/ "./src/display/Container.ts":
/*!**********************************!*\
  !*** ./src/display/Container.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
/**
 * 基础容器
 *
 * 设置checkGroup后，进行分组。 分组后，可理解为复选框。
 *
 * @example let container = new vf.gui.Container();
 *
 */
var Container = /** @class */ (function (_super) {
    __extends(Container, _super);
    function Container() {
        var _this = _super.call(this) || this;
        _this.isContainer = true;
        return _this;
    }
    /**
     * 确定指定显示对象是 DisplayObjectContainer 实例的子项或该实例本身。搜索包括整个显示列表（其中包括此 DisplayObjectContainer 实例）。
     * 孙项、曾孙项等，每项都返回 true。
     * @param child 要测试的子对象。
     * @returns 如果 child 对象是 DisplayObjectContainer 的子项或容器本身，则为 true；否则为 false。
     */
    Container.prototype.contains = function (child) {
        while (child) {
            if (child == this) {
                return true;
            }
            if (child.parent instanceof DisplayObject_1.DisplayObject) {
                child = child.parent;
            }
            else {
                child = undefined;
            }
        }
        return false;
    };
    return Container;
}(DisplayObject_1.DisplayObject));
exports.Container = Container;


/***/ }),

/***/ "./src/display/Ellipse.ts":
/*!********************************!*\
  !*** ./src/display/Ellipse.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ellipse = void 0;
var LineGradient_1 = __webpack_require__(/*! ../core/plugs/LineGradient */ "./src/core/plugs/LineGradient.ts");
var GraphBase_1 = __webpack_require__(/*! ./private/GraphBase */ "./src/display/private/GraphBase.ts");
/**
 * 绘制椭圆
 *
 * 不设置 lineWidth 或 color 椭圆不可见
 *
 */
var Ellipse = /** @class */ (function (_super) {
    __extends(Ellipse, _super);
    function Ellipse() {
        return _super.call(this) || this;
    }
    Ellipse.prototype.drawGraph = function () {
        var graphics = this.graphics;
        graphics.clear();
        if (this._lineWidth < 0) {
            console.log("属性错误，线宽小于0");
            return;
        }
        graphics.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha, 0.5, false, this.lineType);
        if (this.color) {
            graphics.beginFill(this._color, this._fillAlpha);
        }
        else {
            LineGradient_1.updateTextureFill(this.graphics, this);
        }
        var centerX = (this._anchorX ? -this._anchorX * this.width : 0) + this.width * 0.5;
        var centerY = (this._anchorY ? -this._anchorY * this.height : 0) + this.height * 0.5;
        graphics.drawEllipse(centerX, centerY, this.width * 0.5, this.height * 0.5);
        graphics.endFill();
    };
    return Ellipse;
}(GraphBase_1.GraphBase));
exports.Ellipse = Ellipse;


/***/ }),

/***/ "./src/display/FollowLine.ts":
/*!***********************************!*\
  !*** ./src/display/FollowLine.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FollowLine = void 0;
/* eslint-disable no-case-declarations */
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Graphics_1 = __webpack_require__(/*! ./Graphics */ "./src/display/Graphics.ts");
var selectedBounds_1 = __webpack_require__(/*! ./private/selectedBounds */ "./src/display/private/selectedBounds.ts");
var tempLocalBounds = new vf.Rectangle();
/** 验证是否触发的距离 */
var POS_DISTANCE = 7;
/** 优化曲率，小于这个弧度视为直线，把当前点优化掉 */
var MAX_ARC = 0.09; // 5度
/** 点数字转换成字符的数位 */
var DIGIT = 87;
/** 字符列表 ascii */
var NUMBER_TO_STR = "$%&()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{}";
/** 压缩比例，有损压缩 */
var COMPRESS_RATE = 2;
/** 最大宽度 */
var MAX_WIDTH = 1500;
/** 为了把点都变成正数所用 */
var POSITIVE = 0;
/** 线条最大数量 */
var MAX_LINES = 200;
/** 将一个x，y坐标转换成3个字符，宽高不能超过MAX_WIDTH */
function getStrFromPos(x, y) {
    x = Math.min(Math.max(0, x), MAX_WIDTH);
    y = Math.min(Math.max(0, y), MAX_WIDTH);
    // 有损压缩
    var compX = Math.floor(x / COMPRESS_RATE);
    var compY = Math.floor(y / COMPRESS_RATE);
    var n1 = compX % DIGIT;
    var n2 = compY % DIGIT;
    var n3 = Math.floor(compX / DIGIT) * 10 + Math.floor(compY / DIGIT);
    return NUMBER_TO_STR[n1] + NUMBER_TO_STR[n2] + NUMBER_TO_STR[n3];
}
/** 将字符串转换成坐标数字列表 */
function getVecListFromStr(str, from, to) {
    var list = [];
    for (var index = from; index < to; index += 3) {
        var n1 = NUMBER_TO_STR.indexOf(str[index]);
        var n2 = NUMBER_TO_STR.indexOf(str[index + 1]);
        var n3 = NUMBER_TO_STR.indexOf(str[index + 2]);
        var n12 = Math.floor(n3 / 10);
        var n22 = n3 % 10;
        var compX = n1 + n12 * DIGIT;
        var compY = n2 + n22 * DIGIT;
        var realX = compX * COMPRESS_RATE;
        var realY = compY * COMPRESS_RATE;
        list.push(realX);
        list.push(realY);
    }
    return list;
}
/**
 * 跟随鼠标或触摸绘制线条
 *
 * @example let graphics = new vf.gui.FollowLine();
 *
 */
var FollowLine = /** @class */ (function (_super) {
    __extends(FollowLine, _super);
    function FollowLine() {
        var _this = _super.call(this) || this;
        /** 触摸的ID */
        _this._touchId = -1;
        /** 位置缓存，记录画线时候每一个点，最后画完优化 */
        _this._posCache = [];
        /** 保存已画线的key */
        _this._lineKeys = [];
        /**
         * 划线索引, 取时间戳
         */
        _this._curLineIndex = 0;
        /**
         * 需要处理的消息列表
         */
        _this._messageCache = [];
        /**
         * 线条颜色
         */
        _this.lineColor = 0xff0000;
        /**
         * 线条宽度
         */
        _this.lineWidth = 3;
        /**
         * 是否暂停，一些特殊情况，如拖拽时，可暂停
         */
        _this.isPause = false;
        /**
         * LINES instead of TRIANGLE_STRIP
         */
        _this.lineType = "full";
        /**
         * 是否启用橡皮檫
         */
        _this.isErasing = false;
        /** 角色状态 */
        _this.role = "T" /* teacher */;
        _this._lastPos = new vf.Point();
        _this._mouseOffset = new vf.Point();
        _this._lines = new Map();
        _this.addEvent();
        _this.addSelectedBound();
        return _this;
    }
    Object.defineProperty(FollowLine.prototype, "eraseLine", {
        get: function () {
            return this._eraseLine;
        },
        set: function (value) {
            var _a, _b;
            this._eraseLine = value;
            if (value) {
                var bounds = value.getLocalBounds();
                bounds.x += value.x;
                bounds.y += value.y;
                (_a = this._selectedBounds) === null || _a === void 0 ? void 0 : _a.show(this, bounds, value.scale.x, value.scale.y, value.angle, false);
            }
            else {
                (_b = this._selectedBounds) === null || _b === void 0 ? void 0 : _b.hide();
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @private
     * 提交属性，子类在调用完invalidateProperties()方法后，应覆盖此方法以应用属性
     */
    FollowLine.prototype.commitProperties = function () {
        this.onMessage();
        this.getCurLineByPos();
    };
    /**
     * 更新显示列表,子类重写，实现布局
     */
    FollowLine.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
        this.container.hitArea = new vf.Rectangle(0, 0, unscaledWidth, unscaledHeight);
    };
    /**
     * 添加选择框
     */
    FollowLine.prototype.addSelectedBound = function () {
        this._selectedBounds = new selectedBounds_1.SelectedBounds();
        // this._selectedBounds.on(BoundsEventType.selectedBoundsClicked, (value: boolean) => {
        // })
        // this._selectedBounds.on(BoundsEventType.boundsScale, (scaleX: number, scaleY: number) => {
        // })
        // this._selectedBounds.on(BoundsEventType.boundsAngle, (angle: number) => {
        // })
    };
    FollowLine.prototype.onMessage = function () {
        var _messageCache = this._messageCache;
        if (_messageCache.length > 0) {
            var message = void 0;
            var data = void 0;
            var role = void 0;
            var operate = void 0;
            var type = void 0;
            var lineId = void 0;
            while (_messageCache.length > 0) {
                message = _messageCache.shift();
                var infoArr = message.split('|');
                type = infoArr[0];
                operate = infoArr[1];
                role = infoArr[2];
                lineId = infoArr[3];
                this.lineWidth = parseInt(infoArr[4]);
                this.lineColor = parseInt(infoArr[5]);
                this.lineType = infoArr[6];
                data = infoArr[7];
                switch (operate) {
                    case "1" /* add */:
                        var graphics = this.getGraphics(lineId, role);
                        var posList = getVecListFromStr(data, 0, data.length);
                        if (type == "0") {
                            this.drawLine(graphics, posList);
                        }
                        break;
                    case "2" /* remove */:
                        this.removeLine(role + lineId);
                        break;
                    case "3" /* clear */:
                        this.clear();
                        break;
                    default:
                        break;
                }
            }
        }
    };
    FollowLine.prototype.addEvent = function () {
        this.on(Index_1.TouchMouseEvent.onPress, this.onPress);
        this.on(Index_1.TouchMouseEvent.onMove, this.onMove);
    };
    FollowLine.prototype.removeEvent = function () {
        this.off(Index_1.TouchMouseEvent.onPress, this.onPress);
        this.off(Index_1.TouchMouseEvent.onMove, this.onMove);
    };
    FollowLine.prototype.onPress = function (e, thisObj, isPress) {
        if (this.isPause) {
            return;
        }
        e.stopPropagation();
        e.local = this.container.toLocal(e.data.global);
        if (isPress) {
            if (this.parent === undefined)
                return;
            if (this.isErasing)
                return;
            if (this._touchId !== -1)
                return;
            this._touchId = e.data.identifier;
            var curLocal = this.container.toLocal(e.data.global);
            this._lastPos.copyFrom(curLocal);
            this._curLineIndex = Date.now();
            this._posCache = [this._lastPos.clone()];
        }
        else {
            // 清除操作
            if (this.isErasing && this.eraseLine) {
                var name_1 = this.eraseLine.name;
                this.removeLine(name_1);
                this.emitMsg("2" /* remove */, name_1.charAt(0), name_1.substr(1));
                this.eraseLine = undefined;
                return;
            }
            if (this._touchId === -1 || this._touchId != e.data.identifier)
                return;
            this._touchId = -1;
            if (this._posCache.length <= 1) { //划线失败
                //console.log('gui -> 移动距离过短，画线失败 >' + POS_DISTANCE);
                this._posCache.pop();
                return;
            }
            this.emitMsg("1" /* add */, this.role, this._curLineIndex.toString(), this.getDataStrByPosCache());
        }
    };
    FollowLine.prototype.onMove = function (e) {
        e.stopPropagation();
        e.local = this.container.toLocal(e.data.global);
        this._mouseOffset = e.local;
        if (this.isErasing) {
            if (this.role == "T" /* teacher */) {
                this.invalidateProperties();
            }
            return;
        }
        if (this._touchId === -1 || !this._lastPos || this._touchId != e.data.identifier)
            return;
        var _a = this, _lastPos = _a._lastPos, _posCache = _a._posCache;
        var len = Utils_1.pointDistance(_lastPos, this._mouseOffset);
        if (len < POS_DISTANCE) {
            return;
        }
        var brush = this.getGraphics(this._curLineIndex.toString(), this.role);
        brush.moveTo(_lastPos.x, _lastPos.y);
        brush.lineTo(this._mouseOffset.x, this._mouseOffset.y);
        _lastPos.copyFrom(this._mouseOffset);
        _posCache.push(_lastPos.clone());
    };
    /**
     * 发送操作事件
     * @param operate   1添加 2删除 3重置
     * @param role  Role
     * @param lineIndex 线段 ID
     */
    FollowLine.prototype.emitMsg = function (operate, role, lineId, data) {
        if (data === void 0) { data = ''; }
        var dataStr = "0|" + operate + "|" + role + "|" + lineId + "|" + this.lineWidth + "|" + this.lineColor + "|" + this.lineType + "|" + data;
        this.emit(Index_1.ComponentEvent.COMPLETE, this, dataStr);
        if (operate == "1" /* add */) {
            this.removeLine(role + lineId);
            this.setData(dataStr);
        }
    };
    /**
     *
     * @param name (name = role + lineId)
     * @param role
     */
    FollowLine.prototype.getGraphics = function (name, role) {
        var key = role + name;
        if (this._lines.has(key)) {
            return this._lines.get(key);
        }
        if (this._lines.size > MAX_LINES) {
            this.removeLine(this._lineKeys.shift());
        }
        var guiGraphic = new Graphics_1.Graphics();
        guiGraphic.id = key;
        this.addChild(guiGraphic);
        var graphics = guiGraphic.graphics;
        graphics.interactive = false;
        graphics.interactiveChildren = false;
        graphics.name = key;
        this._lineKeys.push(key);
        this._lines.set(key, graphics);
        graphics.lineStyle(this.lineWidth, this.lineColor, undefined, undefined, undefined, this.lineType);
        return graphics;
    };
    FollowLine.prototype.getCurLineByPos = function () {
        var _this = this;
        var _a = this, _lines = _a._lines, _mouseOffset = _a._mouseOffset;
        if (this.eraseLine) {
            this.eraseLine = undefined;
        }
        if (!this.isErasing) {
            return;
        }
        var lastDistance = 10000;
        _lines.forEach(function (value) {
            value.getLocalBounds(tempLocalBounds);
            tempLocalBounds.x += value.x;
            tempLocalBounds.y += value.y;
            if (tempLocalBounds.contains(_mouseOffset.x, _mouseOffset.y)) {
                var distance = Utils_1.pointDistance(_mouseOffset, { x: tempLocalBounds.x + tempLocalBounds.width * 0.5, y: tempLocalBounds.y + tempLocalBounds.height * 0.5 });
                if (distance < lastDistance) {
                    lastDistance = distance;
                    _this.eraseLine = value;
                }
            }
        });
    };
    FollowLine.prototype.getDataStrByPosCache = function () {
        var _posCache = this._posCache;
        if (_posCache.length == 0) {
            return;
        }
        // 稀疏位置点，通过曲率
        var finalX = [_posCache[0].x];
        var finalY = [_posCache[0].y];
        var lastLastPos = _posCache[0];
        var lastPos = _posCache[1];
        var sumAngle = 0;
        for (var index = 2; index < _posCache.length; index++) {
            var pos = _posCache[index];
            var pos1 = Utils_1.pointSub(lastPos, lastLastPos);
            var pos2 = Utils_1.pointSub(pos, lastPos);
            var angle = Utils_1.pointSignAngle(pos1, pos2);
            if (angle > MAX_ARC || angle < -MAX_ARC || sumAngle > MAX_ARC || sumAngle < -MAX_ARC) {
                finalX.push(lastPos.x);
                finalY.push(lastPos.y);
                sumAngle = 0;
            }
            else {
                sumAngle += angle;
            }
            lastLastPos = lastPos;
            lastPos = pos;
        }
        finalX.push(_posCache[_posCache.length - 1].x);
        finalY.push(_posCache[_posCache.length - 1].y);
        var finalStrList = [];
        for (var index = 0; index < finalX.length; index++) {
            var x = finalX[index] + POSITIVE;
            var y = finalY[index] + POSITIVE;
            var str = getStrFromPos(x, y);
            finalStrList.push(str);
        }
        var finalStr = finalStrList.join('');
        return finalStr;
    };
    FollowLine.prototype.drawLine = function (graphics, posList) {
        var lastX = posList[0] - POSITIVE;
        var lastY = posList[1] - POSITIVE;
        graphics.moveTo(lastX, lastY);
        // 利用贝塞尔将线平滑化
        var realList = [];
        for (var index = 2; index < posList.length; index += 2) {
            var x = posList[index] - POSITIVE;
            var y = posList[index + 1] - POSITIVE;
            var halfX = lastX + (x - lastX) * 0.5;
            var halfY = lastY + (y - lastY) * 0.5;
            realList.push(halfX, halfY, x, y);
            lastX = x;
            lastY = y;
        }
        graphics.lineTo(realList[0], realList[1]);
        for (var index = 2; index < realList.length - 2; index += 4) {
            var cx = realList[index];
            var cy = realList[index + 1];
            var x = realList[index + 2];
            var y = realList[index + 3];
            graphics.quadraticCurveTo(cx, cy, x, y);
        }
        graphics.lineTo(realList[realList.length - 2], realList[realList.length - 1]);
    };
    FollowLine.prototype.removeLine = function (key) {
        var delKeyIndex = this._lineKeys.indexOf(key);
        if (delKeyIndex !== -1) {
            this._lineKeys.splice(delKeyIndex, 1);
        }
        var line = this._lines.get(key);
        if (line) {
            this._lines.delete(key);
            if (line.parent) {
                line.parent.removeChild(line);
                line.destroy();
            }
            var obj = this._getChildById(key);
            obj && obj.release();
        }
    };
    FollowLine.prototype.clear = function () {
        this._lines.forEach(function (value, key) {
            if (value.parent) {
                value.parent.removeChild(value).destroy();
            }
        });
        this._lines.clear();
        this._posCache = [];
        this._lineKeys = [];
    };
    FollowLine.prototype.setData = function (data) {
        if (typeof data === 'string') {
            this._messageCache.push(data);
        }
        else {
            this._messageCache = this._messageCache.concat(data);
        }
        // this.invalidateProperties();
        this.onMessage();
    };
    FollowLine.prototype.reset = function () {
        this.emitMsg("3" /* clear */, this.role, "");
        this.clear();
    };
    FollowLine.prototype.release = function () {
        var _a;
        this.removeEvent();
        (_a = this._selectedBounds) === null || _a === void 0 ? void 0 : _a.release();
        _super.prototype.release.call(this);
    };
    return FollowLine;
}(DisplayObject_1.DisplayObject));
exports.FollowLine = FollowLine;


/***/ }),

/***/ "./src/display/Graphics.ts":
/*!*********************************!*\
  !*** ./src/display/Graphics.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graphics = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var GraphicsCore_1 = __webpack_require__(/*! ./private/GraphicsCore */ "./src/display/private/GraphicsCore.ts");
/**
 * 矢量绘制
 *
 * @example let graphics = new vf.gui.Graphics();
 *
 */
var Graphics = /** @class */ (function (_super) {
    __extends(Graphics, _super);
    function Graphics(geometry) {
        var _this = _super.call(this) || this;
        _this.graphics = new GraphicsCore_1.GraphicsCore(geometry);
        _this.container.addChild(_this.graphics);
        return _this;
    }
    return Graphics;
}(DisplayObject_1.DisplayObject));
exports.Graphics = Graphics;


/***/ }),

/***/ "./src/display/Image.ts":
/*!******************************!*\
  !*** ./src/display/Image.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Image = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var GifSprite_1 = __webpack_require__(/*! ./private/GifSprite */ "./src/display/private/GifSprite.ts");
var GifFrames_1 = __webpack_require__(/*! ../utils/GifFrames */ "./src/utils/GifFrames.ts");
/**
 * 图片
 *
 * @example let image = new vf.gui.Image();
 *
 */
var Image = /** @class */ (function (_super) {
    __extends(Image, _super);
    function Image() {
        var _this = _super.call(this) || this;
        _this._isGif = false;
        _this._fillMode = "no-repeat";
        return _this;
    }
    /** 可以支持遮罩的组件 */
    Image.prototype.maskSprite = function () {
        this.srcSystem();
        this.commitProperties();
        return this._sprite;
    };
    Object.defineProperty(Image.prototype, "src", {
        get: function () {
            return this._src;
        },
        set: function (value) {
            if (value === this._src) {
                return;
            }
            this._src = value;
            this.srcSystem();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "scale9Grid", {
        /**
         * 矩形区域，它定义素材对象的九个缩放区域。
         *
         * fillMode = scale 时，[leftWidth,rightWidth,topHeight,bottomHeight]
         *
         * fillMode = repeat 是，[scalex,scaley,x,y]
         */
        get: function () {
            return this._scale9Grid;
        },
        set: function (value) {
            if (value === this._scale9Grid) {
                return;
            }
            this._scale9Grid = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "fillMode", {
        /**
         * 填充模式
         * 设置scale后，可设置scale9Grid进行调整缩放区域
         */
        get: function () {
            return this._fillMode;
        },
        set: function (value) {
            if (value === this._fillMode) {
                return;
            }
            this._fillMode = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "anchorX", {
        /**
         * 锚点，调整位图的坐标中点 0-1
         */
        get: function () {
            return this._anchorX;
        },
        set: function (value) {
            if (value === this._anchorX) {
                return;
            }
            this._anchorX = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "anchorY", {
        /**
         * 锚点，调整位图的坐标中点 0-1
         */
        get: function () {
            return this._anchorY;
        },
        set: function (value) {
            if (value === this.anchorY) {
                return;
            }
            this._anchorY = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Image.prototype.setSpeiteSize = function (unscaledWidth, unscaledHeight) {
        var sprite = this._sprite;
        if (sprite) {
            if (unscaledWidth)
                sprite.width = unscaledWidth;
            if (unscaledHeight)
                sprite.height = unscaledHeight;
            this.setActualSize(sprite.width, sprite.height, false);
        }
    };
    Image.prototype.measure = function () {
        if (this._texture) {
            this.setMeasuredSize(this._texture.width, this._texture.height);
        }
        else {
            this.setMeasuredSize(0, 0);
        }
    };
    Image.prototype.srcSystem = function () {
        var _this = this;
        if (this._oldSrc === this._src) {
            return;
        }
        this._oldSrc = this._src;
        if (this._src === undefined || this._src === '') {
            if (this._sprite && this._texture) {
                this._sprite.destroy();
                this._sprite = undefined;
                this._oldFillMode = undefined;
                this._oldScale9Grid = undefined;
                this._texture.baseTexture.dispose();
                this._texture.removeAllListeners && this._texture.removeAllListeners();
                this._texture = undefined;
            }
            return;
        }
        if (this._texture && this._texture.removeAllListeners) {
            this._texture.removeAllListeners();
        }
        var texture = this._texture = Utils_1.getTexture(this.src);
        if (!texture)
            return; //by ziye+
        this._isGif = false;
        if (texture["extension"] && texture["extension"] === 'gif') {
            this._isGif = true;
            texture = texture.texture;
        }
        if (texture.frame.width > 1 && texture.frame.height > 1) {
            this.invalidateProperties();
            this.invalidateSize();
            this.invalidateDisplayList(); // todo: 后续上层修改流程，本条可以删除
        }
        texture.once("update", function () {
            _this.invalidateProperties();
            _this.invalidateSize();
            _this.invalidateDisplayList(); // todo: 后续上层修改流程，本条可以删除
            _this.emit(Index_1.ComponentEvent.COMPLETE, _this);
        }, this);
    };
    Image.prototype.commitProperties = function () {
        if (this._texture === undefined) {
            return;
        }
        var sprite = this._sprite;
        var oldSprite = this._sprite;
        var texture = this._texture;
        if (((this._oldFillMode !== this._fillMode || (oldSprite instanceof GifSprite_1.GifSprite)) && this._isGif === false)) {
            this._oldFillMode = this._fillMode;
            try {
                if (this.fillMode === "no-repeat") {
                    sprite = new vf.Sprite(texture);
                }
                else if (this.fillMode === "repeat") {
                    sprite = new vf.TilingSprite(texture);
                }
                else if (this.fillMode === "scale") {
                    sprite = new vf.NineSlicePlane(texture);
                }
            }
            catch (e) {
                sprite = vf.Sprite.from(texture);
            }
        }
        else if ((!(oldSprite instanceof GifSprite_1.GifSprite) || !oldSprite) && this._isGif === true) {
            var resource = this._texture;
            if (resource.data && this._isGif === true) {
                var frames_1 = new GifFrames_1.GifFrames(resource);
                resource['frames'] = frames_1;
                resource.texture = frames_1.getFrame(0).texture;
            }
            sprite = new GifSprite_1.GifSprite(resource);
        }
        if (sprite !== oldSprite) {
            this._oldScale9Grid = undefined;
            if (oldSprite && oldSprite !== sprite) {
                this.container.removeChild(oldSprite);
                if (sprite) {
                    sprite.width = oldSprite.width;
                    sprite.height = oldSprite.height;
                }
                oldSprite.removeAllListeners();
                oldSprite.destroy();
            }
            if (sprite && !sprite.parent) {
                this._sprite = this.container.addChild(sprite);
            }
        }
        if (sprite === undefined) {
            return;
        }
        if (sprite.texture !== texture && this._isGif === false) {
            sprite.texture = texture;
        }
        if (sprite.tint !== this.tint) {
            sprite.tint = this.tint;
        }
        if (this.blendMode) {
            sprite.blendMode = this.blendMode;
        }
        if (this._oldScale9Grid !== this._scale9Grid) {
            this._oldScale9Grid = this._scale9Grid;
            var temp = this._scale9Grid;
            if (temp === undefined) {
                temp = [undefined, undefined, undefined, undefined];
            }
            if (sprite instanceof vf.TilingSprite) {
                sprite.tileScale.set(temp[0] || 1, temp[1] || 1);
                sprite.tilePosition.set(temp[2], temp[3]);
            }
            else if (sprite instanceof vf.NineSlicePlane) {
                sprite.leftWidth = temp[0] || 10;
                sprite.rightWidth = temp[1] || 10;
                sprite.topHeight = temp[2] || 10;
                sprite.bottomHeight = temp[3] || 10;
            }
        }
        if (this._anchorX || this._anchorY) {
            sprite.y = -Math.floor(sprite.height * this._anchorY);
            sprite.x = -Math.floor(sprite.width * this._anchorX);
        }
        else {
            sprite.x = 0;
            sprite.y = 0;
        }
    };
    Image.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        if (unscaledWidth === 0 && unscaledHeight === 0) {
            return;
        }
        if (unscaledWidth === 1 && unscaledHeight === 1) {
            return;
        }
        var sprite = this._sprite;
        if (sprite) {
            sprite.width = unscaledWidth;
            sprite.height = unscaledHeight;
            if (this._anchorX || this._anchorY) {
                sprite.y = -Math.floor(sprite.height * this._anchorY);
                sprite.x = -Math.floor(sprite.width * this._anchorX);
            }
            else {
                sprite.x = 0;
                sprite.y = 0;
            }
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
        }
    };
    Image.prototype.release = function () {
        _super.prototype.release.call(this);
        this.offAll(Index_1.ComponentEvent.COMPLETE);
        if (this._sprite && this._sprite.parent) {
            this._sprite.removeAllListeners();
            this._sprite.parent.removeChild(this._sprite).destroy();
        }
        this._sprite = undefined;
        if (this._texture) {
            this._texture.removeAllListeners();
            // this._texture.destroy(); //会把当前使用的纹理清掉
            this._texture = undefined;
        }
        this._source = undefined;
        this._src = undefined;
        this._oldSrc = undefined;
    };
    return Image;
}(DisplayObject_1.DisplayObject));
exports.Image = Image;


/***/ }),

/***/ "./src/display/Isosceles.ts":
/*!**********************************!*\
  !*** ./src/display/Isosceles.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Isosceles = void 0;
var LineGradient_1 = __webpack_require__(/*! ../core/plugs/LineGradient */ "./src/core/plugs/LineGradient.ts");
var GraphBase_1 = __webpack_require__(/*! ./private/GraphBase */ "./src/display/private/GraphBase.ts");
/**
 * 等腰梯形和等腰三角形(上边长度为0)
 *
 * 梯形上边的中点为中心点
 *
 * 不设置 lineWidth 或 color 矩形不可见
 *
 */
var Isosceles = /** @class */ (function (_super) {
    __extends(Isosceles, _super);
    function Isosceles() {
        var _this = _super.call(this) || this;
        _this._upLine = 0;
        _this._downLine = 0;
        _this._path = [];
        return _this;
    }
    Object.defineProperty(Isosceles.prototype, "upLine", {
        get: function () {
            return this._upLine;
        },
        set: function (value) {
            this._upLine = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Isosceles.prototype, "downLine", {
        get: function () {
            return this._downLine;
        },
        set: function (value) {
            this._downLine = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Isosceles.prototype.drawGraph = function () {
        var graphics = this.graphics;
        graphics.clear();
        if (this._lineWidth < 0) {
            console.log("属性错误，线宽小于0");
            return;
        }
        graphics.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha, 0.5, false, this.lineType);
        if (this.color) {
            graphics.beginFill(this._color, this._fillAlpha);
        }
        else {
            LineGradient_1.updateTextureFill(this.graphics, this);
        }
        this.setIsosPath();
        graphics.drawPolygonOne(this._path);
        graphics.endFill();
    };
    Isosceles.prototype.setIsosPath = function () {
        this._path = [];
        var upWidth = this._upLine;
        var downWidth = this._downLine;
        var longWidth = Math.max(upWidth, downWidth);
        var height = this.height > 0 ? this.height : longWidth;
        var scaleWidth = (this.width > 0 ? this.width / longWidth : 1);
        var w = this._anchorX ? this.width * this._anchorX : 0;
        var h = this._anchorY ? this.height * this._anchorY : 0;
        var upY = 0 - h;
        var downY = height - h;
        var point1 = new vf.Point((longWidth - upWidth) * 0.5 * scaleWidth - w, upY);
        var point2 = new vf.Point((longWidth - downWidth) * 0.5 * scaleWidth - w, downY);
        var point3 = new vf.Point((longWidth * 0.5 + downWidth * 0.5) * scaleWidth - w, downY);
        var point4 = new vf.Point((longWidth * 0.5 + upWidth * 0.5) * scaleWidth - w, upY);
        this._path.push(point1, point2, point3, point4);
    };
    return Isosceles;
}(GraphBase_1.GraphBase));
exports.Isosceles = Isosceles;


/***/ }),

/***/ "./src/display/Label.ts":
/*!******************************!*\
  !*** ./src/display/Label.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Label = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var UIKeys = __webpack_require__(/*! ../core/DisplayLayoutKeys */ "./src/core/DisplayLayoutKeys.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
/**
 * 文本
 *
 * 中文换行特殊处理 xxxx.style.breakWords = true;
 *
 * 当文本容器设置宽高后，文字默认会根据文本容器宽高居中.
 *
 * 当文本容器设置宽高后，可通过 style.textAlign 进行文字位置调整
 *
 * @example let label = new vf.gui.Label();
 *
 */
var Label = /** @class */ (function (_super) {
    __extends(Label, _super);
    function Label(text) {
        if (text === void 0) { text = ''; }
        var _this = _super.call(this) || this;
        _this._textDecorationWidth = 3; //线条宽度
        _this._textDecorationStyle = 'Solid'; //线条样式
        _this._textAlpha = 1;
        _this._defaultColor = 0xffffff;
        _this._color = _this._defaultColor;
        _this.sprite = new vf.Text(text, { breakWords: true, fill: '0xffffff', align: _this.style.textAlign });
        _this.container.addChild(_this.sprite);
        _this.on(Index_1.ComponentEvent.WIDTH_CHANGE, _this.onWidthChange, _this);
        return _this;
    }
    Object.defineProperty(Label.prototype, "widthNoShadow", {
        get: function () {
            var width = this.sprite.width;
            var style = this.sprite.style;
            var shadowW = Math.max(0, Math.cos(style.dropShadowAngle) * style.dropShadowDistance);
            if (!style.dropShadow) {
                return width;
            }
            return Math.ceil(width - shadowW);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "heightNoShadow", {
        get: function () {
            var height = this.sprite.height;
            var style = this.sprite.style;
            var shadowH = Math.max(0, Math.sin(style.dropShadowAngle) * style.dropShadowDistance);
            if (!style.dropShadow) {
                return height;
            }
            return Math.ceil(height - shadowH);
        },
        enumerable: false,
        configurable: true
    });
    Label.prototype.onWidthChange = function (width) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (isNaN(this.style.wordWrapWidth)) {
            this.sprite.style.wordWrapWidth = width;
        }
    };
    Object.defineProperty(Label.prototype, "resolution", {
        /**
         * 设置分辨力比例
         */
        get: function () {
            return this.sprite.resolution;
        },
        set: function (value) {
            this.sprite.resolution = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "fillColor", {
        get: function () {
            return this.style.fillColor;
        },
        set: function (value) {
            if (value.length === 0) {
                this.sprite.style.fill = undefined;
            }
            else {
                if (Array.isArray(value[0])) {
                    this.sprite.style.fill = [];
                    var items_1 = [];
                    value.forEach(function (item) {
                        items_1.push("rgba(" + item[0] + ", " + item[1] + ", " + item[2] + ", " + item[3] + ")");
                    });
                    this.sprite.style.fill = items_1;
                }
                else {
                    this.sprite.style.fill = "rgba(" + value[0] + ", " + value[1] + ", " + value[2] + ", " + value[3] + ")";
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "fillAlpha", {
        set: function (value) {
            // 不需要单独实现
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "color", {
        /**
         * 文本颜色
         */
        get: function () {
            return this._color;
        },
        set: function (value) {
            var color = Utils_1.hexListToIntList(value, undefined);
            if (this._color === color) {
                return;
            }
            this.sprite.style.fill = this._color = color;
            // this.style.color 不要直接这样赋值，会递归
            this.style._color = color;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "textAlpha", {
        /**
         * 文字透明度
         */
        get: function () {
            return this._textAlpha;
        },
        set: function (value) {
            if (this._textAlpha === value) {
                return;
            }
            this.sprite.alpha = this._textAlpha = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "textDecorationStyle", {
        get: function () {
            return this._textDecorationStyle;
        },
        set: function (value) {
            if (this._textDecorationStyle === value) {
                return;
            }
            this._textDecorationStyle = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "text", {
        /**
         * 文本内容
         */
        get: function () {
            return this.sprite.text;
        },
        set: function (value) {
            if (this.sprite.text === value) {
                return;
            }
            this.sprite.text = value;
            this.setActualSize(this.widthNoShadow, this.heightNoShadow);
            this.invalidateSize();
            this.invalidateDisplayList();
            this.emit(Index_1.ComponentEvent.CHANGE, this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "fontCssStyle", {
        set: function (value) {
            if (value.color) {
                value.fill = value.color;
            }
            value.breakWords = true;
            this.sprite.style = value;
            if (value.fontFamily) {
                this.sprite.style.fontFamily = value.fontFamily;
            }
            this.setActualSize(this.widthNoShadow, this.heightNoShadow);
            this.invalidateSize();
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Label.prototype.setLine = function () {
        var type = this.style.textDecoration;
        this.clearLineGraphics();
        if (type == 'None' ||
            !this.sprite ||
            !this.sprite.text ||
            this.sprite.text == '') {
            return;
        }
        else {
            this.cacheOldData();
            this.showUnderLine();
        }
    };
    Label.prototype.showUnderLine = function () {
        if (!this._lineGraphics) {
            this._lineGraphics = new vf.Graphics();
        }
        if (!this._lineGraphics.parent) {
            this.container.addChild(this._lineGraphics);
        }
        //画线
        this.autoDrawLine();
    };
    Label.prototype.autoDrawLine = function () {
        var vfMeasured = this.sprite.vfMeasured; //vf.TextMetrics.measureText(this.text, this.sprite.style, this.style.wordWrap);////
        if (vfMeasured == null) {
            console.log('文本渲染参数未初始化');
            return;
        }
        this._textDecorationWidth = this.style.fontSize / 10 + 1;
        var leftX = Number.MAX_VALUE;
        var lineInfo = []; //线条的信息
        var linesNum = vfMeasured.lines.length;
        for (var i = 0; i < linesNum; i++) {
            var x = this.getStartPosX(vfMeasured.lineWidths[i]);
            var liney = this.getStartPosY(vfMeasured.lineHeight, i);
            leftX = leftX < x ? leftX : x;
            lineInfo.push({
                leftX: x,
                lineY: liney,
                lineWidths: vfMeasured.lineWidths[i],
            });
        }
        var spriteY = this.sprite.y;
        for (var i = 0; i < lineInfo.length; i++) {
            var infoItem = lineInfo[i];
            var x = infoItem.leftX;
            this.drawLine(x, infoItem.lineY + spriteY, infoItem.lineWidths);
        }
    };
    Label.prototype.getStartPosX = function (width) {
        var textAlign = this.style.textAlign; //整体在容器的位置
        var startPosX = 0;
        switch (textAlign) {
            case 'left':
                startPosX = 0;
                break;
            case 'right':
                startPosX = this.width - width;
                break;
            case 'center':
                startPosX = (this.width - width) * 0.5;
                break;
        }
        return startPosX;
    };
    Label.prototype.getStartPosY = function (height, lineIndex) {
        var vfMeasured = this.sprite.vfMeasured;
        var startPosY = 0;
        var type = this.style.textDecoration;
        var strok = this.sprite.style.strokeThickness;
        var dis = vfMeasured.fontProperties.fontSize + strok;
        var lineOffsetY = 1;
        switch (type) {
            case 'None':
                break;
            case 'UnderLine':
                startPosY = (lineIndex) * height + lineOffsetY + dis;
                break;
            case 'LineThrough':
                startPosY = (lineIndex) * height + dis * 0.5;
                break;
            case 'Overline':
                startPosY = lineIndex * height;
                break;
        }
        return startPosY;
    };
    Label.prototype.drawLine = function (startPosX, startPosY, lineWidth) {
        var lineG = this._lineGraphics;
        var style = this._textDecorationStyle;
        switch (style) {
            case 'Solid':
                lineG.lineStyle(this._textDecorationWidth, this.style.textDecorationColor);
                lineG.moveTo(startPosX, startPosY);
                lineG.lineTo(startPosX + lineWidth, startPosY);
                break;
            case 'Double':
                lineG.lineStyle(this._textDecorationWidth * 0.5, this.style.textDecorationColor);
                lineG.moveTo(startPosX, startPosY);
                lineG.lineTo(startPosX + lineWidth, startPosY);
                lineG.moveTo(startPosX, startPosY + this._textDecorationWidth * 1);
                lineG.lineTo(startPosX + lineWidth, startPosY + this._textDecorationWidth * 1);
                break;
        }
    };
    /**
     * 测量显示对象宽高，如果子类没有重写，默认是this.container.width..
     */
    Label.prototype.measure = function () {
        var values = this.$values;
        values[UIKeys.measuredWidth] = this.widthNoShadow;
        values[UIKeys.measuredHeight] = this.heightNoShadow;
    };
    Label.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
        var values = this.$values;
        if (!isNaN(values[UIKeys.explicitWidth])) {
            switch (this.style.textAlign) {
                case 'left':
                    this.sprite.x = 0;
                    break;
                case 'right':
                    this.sprite.x =
                        values[UIKeys.explicitWidth] - this.widthNoShadow;
                    break;
                case 'center':
                    this.sprite.x =
                        (values[UIKeys.explicitWidth] - this.widthNoShadow) >> 1;
                    break;
            }
        }
        if (!isNaN(values[UIKeys.explicitHeight])) {
            switch (this.style.verticalAlign) {
                case 'top':
                    this.sprite.y = 0;
                    break;
                case 'bottom':
                    this.sprite.y =
                        values[UIKeys.explicitHeight] - this.sprite.height;
                    break;
                case 'middle':
                    this.sprite.y =
                        (values[UIKeys.explicitHeight] - this.sprite.height) >>
                            1;
                    break;
            }
        }
        this.setLine();
    };
    Label.prototype.cacheOldData = function () {
        if (isNaN(this.style.textDecorationColor) || this.style.textDecorationColor === undefined || this.style.textDecorationColor === null) {
            var color = this._defaultColor;
            if (this.style.color !== undefined) {
                if (typeof this.style.color === 'number') {
                    color = this.style.color;
                }
                else {
                    var color_1 = this.style
                        .color[0].toString();
                    color_1 = Utils_1.hexToInt(color_1, color_1);
                }
                this.style.textDecorationColor = color;
            }
            this.style.textDecorationColor = color;
        }
    };
    Label.prototype.clearLineGraphics = function () {
        var graphics = this._lineGraphics;
        if (graphics) {
            if (graphics.parent) {
                graphics.parent.removeChild(this._lineGraphics);
            }
            graphics.clear();
        }
    };
    Label.prototype.release = function () {
        _super.prototype.release.call(this);
        var sprite = this.sprite;
        if (sprite && sprite.parent) {
            sprite.parent.removeChild(sprite).destroy();
        }
        this.offAll(Index_1.ComponentEvent.CHANGE);
        this.clearLineGraphics();
        this._textDecorationStyle = 'Solid';
        this._textDecorationWidth = 3;
        this.off(Index_1.ComponentEvent.WIDTH_CHANGE, this.onWidthChange, this);
        this._color = 0xfffff0;
    };
    return Label;
}(DisplayObject_1.DisplayObject));
exports.Label = Label;


/***/ }),

/***/ "./src/display/PathGraphics.ts":
/*!*************************************!*\
  !*** ./src/display/PathGraphics.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathGraphics = exports.ArrowType = void 0;
var GraphBase_1 = __webpack_require__(/*! ./private/GraphBase */ "./src/display/private/GraphBase.ts");
var GraphicsCore_1 = __webpack_require__(/*! ./private/GraphicsCore */ "./src/display/private/GraphicsCore.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
// export class ParseDataItem {
//     type: "M" | "L" | "Q" | "C" = "M";
//     x = 0;
//     y = 0;
//     ct1X = 0;
//     ct1Y = 0;
//     ct2X = 0;
//     ct2Y = 0;
// }
var ArrowType;
(function (ArrowType) {
    ArrowType[ArrowType["None"] = 0] = "None";
    ArrowType[ArrowType["HollowCircle"] = 1] = "HollowCircle";
    ArrowType[ArrowType["FullCircle"] = 2] = "FullCircle";
    ArrowType[ArrowType["HollowRect"] = 3] = "HollowRect";
    ArrowType[ArrowType["FullRect"] = 4] = "FullRect";
    ArrowType[ArrowType["HollowArrow"] = 5] = "HollowArrow";
    ArrowType[ArrowType["FullArrow"] = 6] = "FullArrow";
    ArrowType[ArrowType["line"] = 7] = "line";
})(ArrowType = exports.ArrowType || (exports.ArrowType = {}));
/**
 * 矢量绘制
 *
 * @example let graphics = new vf.gui.Graphics();
 *
 */
var PathGraphics = /** @class */ (function (_super) {
    __extends(PathGraphics, _super);
    function PathGraphics() {
        var _this = _super.call(this) || this;
        _this._path = "";
        _this._pathData = [];
        _this._beginPort = ArrowType.None;
        _this._endPort = ArrowType.None;
        _this._beginRotation = NaN;
        _this._endRotation = NaN;
        _this._isSvgPath = true;
        _this._graphicsBegin = new GraphicsCore_1.GraphicsCore();
        _this.container.addChild(_this._graphicsBegin);
        _this._graphicsEnd = new GraphicsCore_1.GraphicsCore();
        _this.container.addChild(_this._graphicsEnd);
        return _this;
    }
    Object.defineProperty(PathGraphics.prototype, "path", {
        get: function () {
            return this._path;
        },
        set: function (value) {
            if (this._path === value) {
                return;
            }
            this._path = value;
            if (Array.isArray(value)) {
                this._isSvgPath = false;
                this._pathData = value;
            }
            else {
                this._isSvgPath = true;
                this._pathData = Utils_1.path2shapes(value);
            }
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGraphics.prototype, "beginPort", {
        get: function () {
            return this._beginPort;
        },
        set: function (value) {
            if (this._beginPort === value) {
                return;
            }
            this._beginPort = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathGraphics.prototype, "endPort", {
        get: function () {
            return this._endPort;
        },
        set: function (value) {
            if (this._endPort === value) {
                return;
            }
            this._endPort = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    PathGraphics.prototype.drawGraph = function () {
        var _a = this, graphics = _a.graphics, _graphicsBegin = _a._graphicsBegin, _graphicsEnd = _a._graphicsEnd;
        graphics.clear();
        _graphicsBegin.clear();
        _graphicsEnd.clear();
        if (this._lineWidth < 0) {
            console.log("属性错误，线宽小于0");
            return;
        }
        graphics.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha, 0.5, false, this.lineType);
        _graphicsBegin.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha);
        _graphicsEnd.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha);
        var length = this._pathData.length;
        if (length <= 0) {
            return;
        }
        if (this._color !== undefined)
            graphics.beginFill(this._color, this._fillAlpha);
        this.drawInfoData();
        graphics.endFill();
        if (this._beginPort !== ArrowType.None) {
            var beginShapeList = this._pathData[0];
            var beginShape = beginShapeList[0];
            this._beginRotation = graphics.getLineRotation(this.getType(beginShape), true, beginShape[0], beginShape[1], beginShape[6], beginShape[7], beginShape[2], beginShape[3], beginShape[4], beginShape[5]);
            this.drawBeginPort();
        }
        if (this._endPort !== ArrowType.None) {
            var endShapeList = this._pathData[this._pathData.length - 1];
            var endShape = endShapeList[endShapeList.length - 1];
            this._endRotation = graphics.getLineRotation(this.getType(endShape), false, endShape[0], endShape[1], endShape[6], endShape[7], endShape[2], endShape[3], endShape[4], endShape[5]);
            this.drawEndPort();
        }
    };
    PathGraphics.prototype.getType = function (data) {
        if (data[2] === data[4] && data[3] === data[5]) {
            return "Q";
        }
        return "C";
    };
    /**
     * 新的解析方式
     */
    PathGraphics.prototype.drawInfoData = function () {
        var _this = this;
        var graphics = this.graphics;
        var lastPoint = {};
        this._pathData.map(function (shape) {
            shape.forEach(function (point, idx) {
                if (!idx) {
                    /*
                     * 若是第一个点数组，那么对该点数组的处理是前面加M,然后前两个点后面加C
                     * */
                    graphics.moveTo(Math.ceil(point[0]), Math.ceil(point[1]));
                    lastPoint.x = Math.ceil(point[0]);
                    lastPoint.y = Math.ceil(point[1]);
                }
                /*
                 * 除了第一个点数据外,所有的点数组的前两个点是初始点
                 * */
                if (_this.getType(point) === "Q") {
                    graphics.quadraticCurveTo(point[2], point[3], Math.ceil(point[6]), Math.ceil(point[7]));
                }
                else {
                    graphics.bezierCurveTo(point[2], point[3], point[4], point[5], Math.ceil(point[6]), Math.ceil(point[7]));
                }
                lastPoint.x = Math.ceil(point[6]);
                lastPoint.y = Math.ceil(point[7]);
            });
        });
    };
    // private drawInfo() {
    //     const { graphics } = this;
    //     const lastPoint: any = {};
    //     for (let i = 0; i < length; i++) {
    //         const item = this._pathData[i];
    //         switch (item.type) {
    //             case "M":
    //                 graphics.moveTo(item.x, item.y);
    //                 lastPoint.x = item.x;
    //                 lastPoint.y = item.y;
    //                 break;
    //             case "L":
    //                 graphics.lineTo(item.x, item.y);
    //                 break;
    //             case "Q":
    //                 graphics.quadraticCurveTo(item.ct1X, item.ct1Y, item.x, item.y);
    //                 break;
    //             case "C":
    //                 graphics.moveTo(lastPoint.x, lastPoint.y);
    //                 if (item.ct1X === item.ct2X && item.ct1Y === item.ct2Y) {
    //                     graphics.quadraticCurveTo(item.ct1X, item.ct1Y, item.x, item.y);
    //                     break;
    //                 }
    //                 graphics.bezierCurveTo(item.ct1X, item.ct1Y, item.ct2X, item.ct2Y, item.x, item.y);
    //                 break;
    //         }
    //         lastPoint.x = item.x;
    //         lastPoint.y = item.y;
    //     }
    //     const beginLine = this._pathData[1];
    //     const endLine = this._pathData[length - 1];
    //     this._beginRotation = graphics.getLineRotation(beginLine.type, true, this._pathData[0].x, this._pathData[0].y, beginLine.x, beginLine.y, beginLine.ct1X, beginLine.ct1Y, beginLine.ct2X, beginLine.ct2Y);//this.setBeiginRotation();
    //     this._endRotation = graphics.getLineRotation(endLine.type, false, this._pathData[length - 2].x, this._pathData[length - 2].y, endLine.x, endLine.y, endLine.ct1X, endLine.ct1Y, endLine.ct2X, endLine.ct2Y);//this.setBeiginRotation();
    //     this.drawPortShape();
    // }
    // private drawPortShape() {
    //     this.drawBeginPort();
    //     this.drawEndPort();
    // }
    PathGraphics.prototype.drawBeginPort = function () {
        this.drawShape(this.beginPort, true);
    };
    PathGraphics.prototype.drawEndPort = function () {
        this.drawShape(this.endPort, false);
    };
    PathGraphics.prototype.drawShape = function (shapeType, isBegin) {
        if (isBegin === void 0) { isBegin = true; }
        var graphics = isBegin ? this._graphicsBegin : this._graphicsEnd;
        var pathData = this._pathData;
        var lineWidth = this._lineWidth;
        var shapeList = pathData[0];
        var shapeData = shapeList[0];
        if (!isBegin) {
            shapeList = pathData[pathData.length - 1];
            shapeData = shapeList[shapeList.length - 1];
        }
        var centerPoint = isBegin ? new vf.Point(shapeData[0], shapeData[1]) : new vf.Point(shapeData[6], shapeData[7]);
        graphics.x = centerPoint.x;
        graphics.y = centerPoint.y;
        var rotation = isBegin ? this._beginRotation : this._endRotation;
        graphics.rotation = rotation; //isNaN(rotation) ? 0 : rotation;
        var point1;
        var point2;
        var point3;
        switch (shapeType) {
            case ArrowType.FullRect:
            case ArrowType.HollowRect:
                shapeType === ArrowType.FullRect && graphics.beginFill(this.lineColor, this._fillAlpha);
                graphics.drawRect(-lineWidth * 5, 0, lineWidth * 10, lineWidth * 10);
                graphics.endFill();
                break;
            case ArrowType.FullCircle:
            case ArrowType.HollowCircle:
                shapeType === ArrowType.FullCircle && graphics.beginFill(this.lineColor, this._fillAlpha);
                graphics.drawCircle(-lineWidth * 5, 0, lineWidth * 5);
                graphics.endFill();
                graphics.rotation -= Math.PI * 0.5;
                break;
            case ArrowType.FullArrow:
            case ArrowType.HollowArrow:
                shapeType === ArrowType.FullArrow && graphics.beginFill(this.lineColor, this._fillAlpha);
                point1 = new vf.Point(-lineWidth * 5, -lineWidth * 5);
                point2 = new vf.Point(0, 0);
                point3 = new vf.Point(lineWidth * 5, -lineWidth * 5);
                graphics.drawPolygonOne([point1, point2, point3], false);
                graphics.endFill();
                break;
            case ArrowType.line:
                graphics.moveTo(-lineWidth * 5, 0);
                graphics.lineTo(lineWidth * 5, 0);
                break;
        }
    };
    /**
  * svg格式线条 解析
  *
  * M 表示MoveTo
   *   L 表示LineTo，
   *   Q表示二次贝塞尔曲线
   *   C 表示三次贝塞尔曲线
  */
    // private parseSvgPath(p: string) {
    //     let pathList = [];
    //     const tempList = [];
    //     if (p && p.length > 0) {
    //         p = p.replace(/,+/g, ' ');
    //         p = p.replace(/M+/g, ' M ');
    //         p = p.replace(/Q+/g, ' Q ');
    //         p = p.replace(/L+/g, ' L ');
    //         p = p.replace(/C+/g, ' C ');
    //         p = p.replace(/\s+/g, ' ');
    //         p = p.toUpperCase();
    //         pathList = p.split(" ");
    //         // list to json
    //         let dis = 1;
    //         for (let i = 0; i < pathList.length; i = i + dis) {
    //             const item = pathList[i];
    //             if (item !== "M" && item !== "Q" && item !== "L" && item !== "C") {
    //                 dis = 1;
    //                 continue;
    //             }
    //             if (item === "Q") {
    //                 dis = 4;
    //             } else if (item === "C") {
    //                 dis = 6;
    //             } else {
    //                 dis = 2;
    //             }
    //             const dataItem = new ParseDataItem();
    //             dataItem.type = item;
    //             switch (item) {
    //                 case "M":
    //                 case "L":
    //                     if (pathList[i + 1] && pathList[i + 2]) {
    //                         dataItem.x = Number(pathList[i + 1]);
    //                         dataItem.y = Number(pathList[i + 2]);
    //                     }
    //                     break;
    //                 case "Q":
    //                     if (pathList[i + 1] && pathList[i + 2] && pathList[i + 3] && pathList[i + 4]) {
    //                         dataItem.ct1X = Number(pathList[i + 1]);
    //                         dataItem.ct1Y = Number(pathList[i + 2]);
    //                         dataItem.x = Number(pathList[i + 3]);
    //                         dataItem.y = Number(pathList[i + 4]);
    //                     }
    //                     dis = 4;
    //                     break;
    //                 case "C":
    //                     if (pathList[i + 1] && pathList[i + 2] && pathList[i + 3] && pathList[i + 4] && pathList[i + 5] && pathList[i + 6]) {
    //                         dataItem.ct1X = Number(pathList[i + 1]);
    //                         dataItem.ct1Y = Number(pathList[i + 2]);
    //                         dataItem.ct2X = Number(pathList[i + 3]);
    //                         dataItem.ct2Y = Number(pathList[i + 4]);
    //                         dataItem.x = Number(pathList[i + 5]);
    //                         dataItem.y = Number(pathList[i + 6]);
    //                     }
    //                     dis = 6;
    //                     break;
    //             }
    //             tempList.push(dataItem);
    //         }
    //     }
    //     return tempList;
    // }
    PathGraphics.prototype.release = function () {
        this._path = "";
        this._pathData = [];
        this._beginPort = ArrowType.None;
        this._endPort = ArrowType.None;
        this._beginRotation = NaN;
        this._endRotation = NaN;
        if (this._graphicsBegin.parent) {
            this._graphicsBegin.parent.removeChild(this._graphicsBegin).destroy();
        }
        if (this._graphicsEnd.parent) {
            this._graphicsEnd.parent.removeChild(this._graphicsEnd).destroy();
        }
        _super.prototype.release.call(this);
    };
    return PathGraphics;
}(GraphBase_1.GraphBase));
exports.PathGraphics = PathGraphics;


/***/ }),

/***/ "./src/display/Polygon.ts":
/*!********************************!*\
  !*** ./src/display/Polygon.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Polygon = void 0;
var LineGradient_1 = __webpack_require__(/*! ../core/plugs/LineGradient */ "./src/core/plugs/LineGradient.ts");
var GraphBase_1 = __webpack_require__(/*! ./private/GraphBase */ "./src/display/private/GraphBase.ts");
var Polygon = /** @class */ (function (_super) {
    __extends(Polygon, _super);
    function Polygon() {
        var _this = _super.call(this) || this;
        _this.path = [];
        _this.PI_2 = Math.PI * 2;
        _this._triangleNum = 5; // 默认角数  这个值需要大于1才行
        _this.RADIUS_V = 1; //外半径默认值
        return _this;
    }
    Polygon.prototype.drawGraph = function () {
        var graphics = this.graphics;
        graphics.clear();
        this.path = [];
        if (this._triangleNum <= 1 || this._lineWidth < 0) {
            console.log("属性错误，线宽小于0或者角数错误");
            return;
        }
        graphics.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha, 0.5, false, this.lineType);
        this.setStarPath();
        if (this.color) {
            graphics.beginFill(this._color, this._fillAlpha);
        }
        else {
            LineGradient_1.updateTextureFill(this.graphics, this);
        }
        graphics.drawPolygonOne(this.path);
        graphics.endFill();
    };
    Object.defineProperty(Polygon.prototype, "triangleNum", {
        get: function () {
            return this._triangleNum;
        },
        set: function (value) {
            this._triangleNum = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Polygon.prototype.setStarPath = function () {
        var radius = this.RADIUS_V;
        var triangleNum = this._triangleNum;
        var PI_2 = this.PI_2;
        var startAngle = (-1 * Math.PI / 2);
        var len = triangleNum;
        var delta = PI_2 / len;
        var scaleWidth = this.width > 0 ? this.width / (radius * 2) : 1;
        var scaleHeight = this.height > 0 ? this.height / (radius * 2) : 1;
        var anchorX = this._anchorX ? this._anchorX : 0;
        var anchorY = this._anchorY ? this._anchorY : 0;
        for (var i = 0; i < len; i++) {
            var angle = (i * delta) + startAngle;
            var pX = (radius * Math.cos(angle) + anchorX + radius) * scaleWidth;
            var pY = (radius * Math.sin(angle) + anchorY + radius) * scaleHeight;
            var point = new vf.Point(pX, pY);
            this.path.push(point);
        }
    };
    return Polygon;
}(GraphBase_1.GraphBase));
exports.Polygon = Polygon;


/***/ }),

/***/ "./src/display/Rect.ts":
/*!*****************************!*\
  !*** ./src/display/Rect.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rect = void 0;
var LineGradient_1 = __webpack_require__(/*! ../core/plugs/LineGradient */ "./src/core/plugs/LineGradient.ts");
var GraphBase_1 = __webpack_require__(/*! ./private/GraphBase */ "./src/display/private/GraphBase.ts");
/**
 * 绘制矩形或圆角矩形
 *
 * 不设置 lineWidth 或 color 矩形不可见
 *
 * @example let rect = new vf.gui.Rect();
 *
 */
var Rect = /** @class */ (function (_super) {
    __extends(Rect, _super);
    function Rect() {
        return _super.call(this) || this;
    }
    Rect.prototype.drawGraph = function () {
        var graphics = this.graphics;
        graphics.clear();
        if (this._lineWidth < 0) {
            console.log("属性错误，线宽小于0");
            return;
        }
        graphics.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha, 0.5, false, this.lineType);
        if (this.color) {
            graphics.beginFill(this._color, this._fillAlpha);
        }
        else {
            LineGradient_1.updateTextureFill(this.graphics, this);
        }
        graphics.drawRoundedRect(this._anchorX ? -this._anchorX * this.width : 0, this._anchorY ? -this._anchorY * this.height : 0, this.width, this.height, this._radius); // 去掉_radius最小15限制，部分设备可能出现问题
        graphics.endFill();
    };
    return Rect;
}(GraphBase_1.GraphBase));
exports.Rect = Rect;


/***/ }),

/***/ "./src/display/ScrollBar.ts":
/*!**********************************!*\
  !*** ./src/display/ScrollBar.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScrollBar = void 0;
var Slider_1 = __webpack_require__(/*! ./Slider */ "./src/display/Slider.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var Utils = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
/**
 * UI 带有滚动条的容器
 */
var ScrollBar = /** @class */ (function (_super) {
    __extends(ScrollBar, _super);
    function ScrollBar() {
        var _this = _super.call(this) || this;
        /**
         * 是的自动隐藏滚动条
         */
        _this.autohide = true;
        _this._hidden = false;
        _this._dragScrolling = true;
        _this.thumbImg.on(Index_1.ComponentEvent.COMPLETE, _this.onThumbLoadComplete, _this);
        return _this;
    }
    ScrollBar.prototype.toggleHidden = function (hidden) {
        if (this.autohide) {
            if (hidden && !this._hidden) {
                //Tween.to(this, { alpha: 0 }, 200).start();
                this.alpha = 0;
                this._hidden = true;
            }
            else if (!hidden && this._hidden) {
                //Tween.to(this, { alpha: 1 }, 200).start();
                this.alpha = 1;
                this._hidden = false;
            }
        }
    };
    ScrollBar.prototype.onThumbLoadComplete = function (rectangle, source) {
        this.alignToContainer();
    };
    ScrollBar.prototype.triggerValueChanging = function () {
        _super.prototype.triggerValueChanging.call(this);
        var scrollingContainer = this._scrollingContainer;
        if (scrollingContainer) {
            var sizeAmt = scrollingContainer.explicitHeight / scrollingContainer.innerContainer.height || 0.001;
            if (sizeAmt < 1)
                scrollingContainer.forcePctPosition(this.vertical ? "y" : "x", this._amt);
        }
    };
    Object.defineProperty(ScrollBar.prototype, "source", {
        get: function () {
            return this._source;
        },
        set: function (value) {
            if (this._source === value) {
                return;
            }
            this._source = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ScrollBar.prototype, "dragScrolling", {
        get: function () {
            return this._source;
        },
        set: function (value) {
            if (this._dragScrolling === value) {
                return;
            }
            this._dragScrolling = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    ScrollBar.prototype.commitProperties = function () {
        if (this._scrollingContainer !== Utils.getDisplayObject(this._source, this)) {
            if (this._scrollingContainer) {
                this._scrollingContainer.off(Index_1.ComponentEvent.CHANGE, this.alignToContainer, this);
                this._scrollingContainer.off(Index_1.ComponentEvent.RESIZE, this.alignToContainer, this);
            }
            var scrollingContainer_1 = this._scrollingContainer = Utils.getDisplayObject(this._source, this);
            scrollingContainer_1.expandMask = 2;
            scrollingContainer_1.softness = 0.2;
            scrollingContainer_1.on(Index_1.ComponentEvent.CHANGE, this.alignToContainer, this);
            scrollingContainer_1.on(Index_1.ComponentEvent.RESIZE, this.alignToContainer, this);
        }
        var scrollingContainer = this._scrollingContainer;
        if (scrollingContainer) {
            scrollingContainer.dragScrolling = this._dragScrolling;
            if (this.vertical) {
                scrollingContainer.scrollY = true;
                if (this.parent)
                    this.height = this.parent.height;
            }
            else {
                scrollingContainer.scrollX = true;
                if (this.parent)
                    this.width = this.parent.width;
            }
            this.alignToContainer();
        }
    };
    ScrollBar.prototype.alignToContainer = function () {
        if (this._scrollingContainer) {
            var _thumb = this.thumbImg;
            if (this.vertical) {
                _thumb.style.width = '100%';
            }
            else {
                _thumb.style.height = '100%';
            }
            var newPos = void 0;
            var size = void 0;
            var xORy = this.vertical ? "y" : "x";
            var widthORheight = this.vertical ? "height" : "width";
            var topORleft = this.vertical ? "top" : "left";
            var scrollingContainer = this._scrollingContainer;
            var innerContainer = scrollingContainer.innerContainer;
            var _posAmt = !innerContainer[widthORheight] ? 0 : -(innerContainer[xORy] / innerContainer[widthORheight]);
            var sizeAmt = !innerContainer[widthORheight] ? 1 : scrollingContainer[widthORheight] / innerContainer[widthORheight];
            //update amt
            var diff = innerContainer[widthORheight] - scrollingContainer[widthORheight];
            this._amt = !scrollingContainer[widthORheight] || !diff ? 0 : -(innerContainer[xORy] / diff);
            var self_1 = this;
            var wh = self_1[widthORheight];
            if (sizeAmt >= 1) {
                size = wh;
                this.toggleHidden(true);
            }
            else {
                size = wh * sizeAmt;
                if (this._amt > 1) {
                    size -= (wh - size) * (this._amt - 1);
                }
                else if (this._amt < 0) {
                    size -= (wh - size) * -this._amt;
                }
                this.toggleHidden(false);
            }
            _thumb[widthORheight] = size;
            if (size == _thumb[widthORheight]) {
                this.updatePosition();
            }
        }
    };
    ScrollBar.prototype.onDragMove = function (event, offset) {
        if (this._thumbDrag.id == event.data.identifier) {
            this._amt = !this._maxPosition ? 0 : Math.max(0, Math.min(1, this._startValue + ((this.vertical ? offset.y : offset.x) / this._maxPosition)));
            // if(this._amt < 0.26){
            //     this._amt = 0;
            // }
            // if(this._amt > 0.75){
            //     this._amt = 1;
            // }
            this.triggerValueChanging();
            this.updatePosition();
        }
        else if (this._trackDrag && this._trackDrag.id == event.data.identifier) {
            this.updatePositionToMouse(event.data.global, false);
        }
    };
    ScrollBar.prototype.updatePosition = function (soft) {
        this.updateLayout();
        var val = 0;
        var thumbImg = this.thumbImg;
        var tracklightImg = this.tracklightImg;
        if (this.vertical) {
            val = this.explicitHeight * this._amt;
            var minheight = thumbImg.height / 2;
            var maxheight = this.height - minheight;
            if (val < minheight) {
                val = minheight;
            }
            if (val > maxheight) {
                val = maxheight;
            }
            thumbImg.x = this.width / 2;
            thumbImg.y = val;
        }
        else {
            val = this.explicitWidth * this._amt;
            var thumbImgWidth = thumbImg.width / 2;
            var maxwidth = this.width - thumbImgWidth;
            if (val < thumbImgWidth) {
                val = thumbImgWidth;
            }
            if (val > maxwidth) {
                val = maxwidth;
            }
            thumbImg.y = this.height / 2;
            thumbImg.x = val;
        }
    };
    ScrollBar.prototype.release = function () {
        _super.prototype.release.call(this);
        //this.offAll();
        this.thumbImg.off(Index_1.ComponentEvent.COMPLETE);
        this._scrollingContainer = undefined;
        this._source = undefined;
    };
    return ScrollBar;
}(Slider_1.Slider));
exports.ScrollBar = ScrollBar;


/***/ }),

/***/ "./src/display/ScrollingContainer.ts":
/*!*******************************************!*\
  !*** ./src/display/ScrollingContainer.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScrollingContainer = void 0;
var Container_1 = __webpack_require__(/*! ./Container */ "./src/display/Container.ts");
var Ticker_1 = __webpack_require__(/*! ../core/Ticker */ "./src/core/Ticker.ts");
var Utils = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var DragEvent_1 = __webpack_require__(/*! ../interaction/DragEvent */ "./src/interaction/DragEvent.ts");
var MouseScrollEvent_1 = __webpack_require__(/*! ../interaction/MouseScrollEvent */ "./src/interaction/MouseScrollEvent.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var ContainerBase_1 = __webpack_require__(/*! ../core/ContainerBase */ "./src/core/ContainerBase.ts");
var ScrollBar_1 = __webpack_require__(/*! ./ScrollBar */ "./src/display/ScrollBar.ts");
/**
 * 可滚动的容器
 *
 * @example let scrollingContainer = new vf.gui.ScrollingContainer();
 *
 */
var ScrollingContainer = /** @class */ (function (_super) {
    __extends(ScrollingContainer, _super);
    function ScrollingContainer() {
        var _this = _super.call(this) || this;
        /**
         * 是否启动拖拽滚动
         * @default true
         */
        _this._dragScrolling = false;
        /**
         * 滚动的阻力或柔度 (0-1)
         * @default 0.5
         */
        _this.softness = 0.5;
        /**
         * 滚动条的圆角半径 设置0时，滚动条为直角长方形
         * @default 0
         */
        _this.radius = 0;
        /**
         * 遮罩的扩充范围
         */
        _this.expandMask = 0;
        /**
         * 是否开启滚动动画
         * @default false
         */
        _this.animating = false;
        /**
         * 是否启用水平滚动
         * @default false
         */
        _this.scrollX = false;
        /**
         * 是否滚动中
         */
        _this.scrollY = false;
        /**
         * 内容容器
         * @private
         */
        _this._innerContainer = new ContainerBase_1.ContainerBase();
        /**
         * 内容的宽高
         */
        _this.innerBounds = new vf.Rectangle();
        /**
         * 是否滚动中
         */
        _this.scrolling = false;
        /**
         * 临时方案，设置时间间隔，跳转容器宽高
         */
        _this._boundCached = Utils_1.now() - 1000;
        _this._lastWidth = 0;
        _this._lastHeight = 0;
        _this._isInitScrolling = false;
        _this._containerStart = new vf.Point();
        _this._targetPosition = new vf.Point();
        _this._lastPosition = new vf.Point();
        _this._Position = new vf.Point();
        _this._Speed = new vf.Point();
        _this._stop = false;
        _this.isInitDrag = false;
        var innerContainer = _this._innerContainer;
        _this.container.addChild(innerContainer);
        _this.container.name = "ScrollingContainer";
        innerContainer.name = "innerContainer";
        innerContainer.on("added", _this.$onAddStage, _this);
        innerContainer.on("removed", _this.$onRemoveStage, _this);
        _this.scrollMask = new vf.Graphics();
        return _this;
    }
    Object.defineProperty(ScrollingContainer.prototype, "dragScrolling", {
        get: function () {
            return this._dragScrolling;
        },
        set: function (value) {
            this._dragScrolling = value;
            //Drag scroll and Mouse scroll
            if (value) {
                this.initDrag();
                this.mouseScrollEvent && this.mouseScrollEvent.startEvent();
                this.dragEvent && this.dragEvent.startEvent();
            }
            else {
                this.mouseScrollEvent && this.mouseScrollEvent.stopEvent();
                this.dragEvent && this.dragEvent.stopEvent();
            }
        },
        enumerable: false,
        configurable: true
    });
    ScrollingContainer.prototype.initDrag = function () {
        var _this = this;
        if (this.isInitDrag) {
            return;
        }
        this.dragEvent = new DragEvent_1.DragEvent(this);
        this.mouseScrollEvent = new MouseScrollEvent_1.MouseScrollEvent(this, true);
        this.isInitDrag = true;
        var _graphics = this.scrollMask = new vf.Graphics();
        _graphics.clear();
        _graphics.beginFill(0xffcc00);
        _graphics.drawRoundedRect(0, 0, 200, 200, 0);
        _graphics.endFill();
        this.container.addChild(_graphics);
        this.container.mask = _graphics;
        this.dragEvent.onDragStart = function () {
            if (!_this.scrolling) {
                _this._containerStart.copyFrom(_this._innerContainer.position);
                _this._Position.copyFrom(_this._innerContainer.position);
                _this.scrolling = true;
                _this.setScrollPosition();
                Ticker_1.TickerShared.add(_this.updateScrollPosition, _this);
            }
        };
        this.dragEvent.onDragMove = function (e, offset) {
            if (_this.scrollX)
                _this._targetPosition.x = _this._containerStart.x + offset.x;
            if (_this.scrollY)
                _this._targetPosition.y = _this._containerStart.y + offset.y;
        };
        this.dragEvent.onDragEnd = function () {
            if (_this.scrolling) {
                _this.scrolling = false;
                Ticker_1.TickerShared.remove(_this.updateScrollPosition, _this);
            }
        };
        var scrollSpeed = new vf.Point();
        this.mouseScrollEvent.onMouseScroll = function (e, delta) {
            scrollSpeed.set(-delta.x * 0.2, -delta.y * 0.2);
            _this.setScrollPosition(scrollSpeed);
        };
    };
    ScrollingContainer.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        if (this._lastWidth != unscaledWidth || this._lastHeight != unscaledHeight) {
            _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
            this._lastWidth = this._innerContainer.width;
            this._lastHeight = this._innerContainer.height;
            var scrollMask = this.scrollMask;
            if (this._dragScrolling && (scrollMask.width !== unscaledWidth || scrollMask.height !== unscaledHeight)) {
                scrollMask.x = scrollMask.y = this.expandMask;
                scrollMask.width = unscaledWidth;
                scrollMask.height = unscaledHeight;
            }
            this.setScrollPosition();
            this.emit(Index_1.ComponentEvent.RESIZE, this);
        }
    };
    ScrollingContainer.prototype.setScrollPosition = function (speed) {
        if (speed) {
            this._Speed = speed;
        }
        if (!this.animating) {
            this.animating = true;
            this._lastPosition.copyFrom(this._innerContainer.position);
            this._targetPosition.copyFrom(this._innerContainer.position);
            this.updateScrollPosition(0);
        }
    };
    Object.defineProperty(ScrollingContainer.prototype, "innerContainer", {
        get: function () {
            return this._innerContainer;
        },
        enumerable: false,
        configurable: true
    });
    ScrollingContainer.prototype.addChild = function (item) {
        if (this._innerContainer.children.length !== this.uiChildren.length) {
            return this.addChildAt(item, this._innerContainer.children.length);
        }
        else {
            return this.addChildAt(item, this.uiChildren.length);
        }
    };
    ScrollingContainer.prototype.addChildAt = function (item, index) {
        if (item.parent) {
            item.parent.removeChild(item);
        }
        item.parent = this;
        item.$nestLevel = this.$nestLevel + 1;
        if (!item.initialized) {
            item.initialized = true;
            item.$onInit();
        }
        this.emit(Index_1.ComponentEvent.ADD, this);
        if (item instanceof ScrollBar_1.ScrollBar) {
            //index = this.uiChildren.push(item);
            //index = Math.min(this.container.children.length,index);
            this.container.addChild(item.container);
        }
        else {
            index = Math.min(this._innerContainer.children.length, index);
            this.uiChildren.splice(index, 0, item);
            this._innerContainer.addChildAt(item.container, index);
        }
        this.getInnerBounds(true);
        return item;
    };
    ScrollingContainer.prototype.getInnerBounds = function (force) {
        //this is a temporary fix, because we cant rely on innercontainer height if the children is positioned > 0 y.
        if (force || Utils_1.now() - this._boundCached > 1000) {
            this._innerContainer.getLocalBounds(this.innerBounds);
            this.innerBounds.height = this.innerBounds.y + this._innerContainer.height;
            this.innerBounds.width = this.innerBounds.x + this._innerContainer.width;
            this._boundCached = Utils_1.now();
        }
        return this.innerBounds;
    };
    ScrollingContainer.prototype.$onInit = function () {
        _super.prototype.$onInit.call(this);
        this.initScrolling();
    };
    ScrollingContainer.prototype.initScrolling = function () {
        this._isInitScrolling = true;
        this.updateScrollBars();
    };
    ScrollingContainer.prototype.updateScrollBars = function () {
        this.emit(Index_1.ComponentEvent.CHANGE, this);
    };
    /**
     * 百分比设置位置
     * @param direction 方向
     * @param pct 百分比0-1
     */
    ScrollingContainer.prototype.forcePctPosition = function (direction, pct) {
        var bounds = this.getInnerBounds();
        if (this.scrollX && direction == "x") {
            this._innerContainer.position[direction] = -((bounds.width - this.explicitWidth) * pct);
        }
        if (this.scrollY && direction == "y") {
            this._innerContainer[direction] = -((bounds.height - this.explicitHeight) * pct);
        }
        this._Position[direction] = this._targetPosition[direction] = this._innerContainer.position[direction];
    };
    /** 根据焦点设置位置 */
    ScrollingContainer.prototype.focusPosition = function (pos) {
        var bounds = this.getInnerBounds();
        var dif;
        if (this.scrollX) {
            var x = Math.max(0, (Math.min(bounds.width, pos.x)));
            if (x + this._innerContainer.x > this.explicitWidth) {
                dif = x - this.explicitWidth;
                this._innerContainer.x = -dif;
            }
            else if (x + this._innerContainer.x < 0) {
                dif = x + this._innerContainer.x;
                this._innerContainer.x -= dif;
            }
        }
        if (this.scrollY) {
            var y = Math.max(0, (Math.min(bounds.height, pos.y)));
            if (y + this._innerContainer.y > this.explicitHeight) {
                dif = y - this.explicitHeight;
                this._innerContainer.y = -dif;
            }
            else if (y + this._innerContainer.y < 0) {
                dif = y + this._innerContainer.y;
                this._innerContainer.y -= dif;
            }
        }
        this._lastPosition.copyFrom(this._innerContainer.position);
        this._targetPosition.copyFrom(this._innerContainer.position);
        this._Position.copyFrom(this._innerContainer.position);
        this.updateScrollBars();
    };
    ScrollingContainer.prototype.updateScrollPosition = function (delta) {
        this._stop = true;
        if (this.scrollX)
            this.updateDirection("x", delta);
        if (this.scrollY)
            this.updateDirection("y", delta);
        //if (this._stop) {
        this.animating = false;
        //}
    };
    ScrollingContainer.prototype.updateDirection = function (direction, delta) {
        delta = delta * 0.001;
        var bounds = this.getInnerBounds();
        var min;
        if (direction == "y")
            min = Math.round(Math.min(0, this.explicitHeight - bounds.height));
        else
            min = Math.round(Math.min(0, this.explicitWidth - bounds.width));
        if (!this.scrolling && Math.round(this._Speed[direction]) !== 0) {
            this._targetPosition[direction] += this._Speed[direction];
            this._Speed[direction] = Utils.Lerp(this._Speed[direction], 0, (5 + 2.5 / Math.max(this.softness, 0.01)) * delta);
            if (this._targetPosition[direction] > 0) {
                this._targetPosition[direction] = 0;
            }
            else if (this._targetPosition[direction] < min) {
                this._targetPosition[direction] = min;
            }
        }
        if (!this.scrolling && Math.round(this._Speed[direction]) === 0 && (this._innerContainer[direction] > 0 || this._innerContainer[direction] < min)) {
            var target = this._Position[direction] > 0 ? 0 : min;
            this._Position[direction] = Utils.Lerp(this._Position[direction], target, (40 - (30 * this.softness)) * delta);
            this._stop = false;
        }
        else if (this.scrolling || Math.round(this._Speed[direction]) !== 0) {
            if (this.scrolling) {
                this._Speed[direction] = this._Position[direction] - this._lastPosition[direction];
                this._lastPosition.copyFrom(this._Position);
            }
            if (this._targetPosition[direction] > 0) {
                this._Speed[direction] = 0;
                this._Position[direction] = 100 * this.softness * (1 - Math.exp(this._targetPosition[direction] / -200));
            }
            else if (this._targetPosition[direction] < min) {
                this._Speed[direction] = 0;
                this._Position[direction] = min - (100 * this.softness * (1 - Math.exp((min - this._targetPosition[direction]) / -200)));
            }
            else {
                this._Position[direction] = this._targetPosition[direction];
            }
            this._stop = false;
        }
        this._innerContainer.position[direction] = Math.round(this._Position[direction]);
        this.updateScrollBars();
    };
    ScrollingContainer.prototype.release = function () {
        _super.prototype.release.call(this);
        //this.offAll();
        Ticker_1.TickerShared.remove(this.updateScrollPosition, this);
        this.dragEvent && this.dragEvent.remove();
        this.mouseScrollEvent && this.mouseScrollEvent.remove();
    };
    return ScrollingContainer;
}(Container_1.Container));
exports.ScrollingContainer = ScrollingContainer;


/***/ }),

/***/ "./src/display/Slider.ts":
/*!*******************************!*\
  !*** ./src/display/Slider.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Slider = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Image_1 = __webpack_require__(/*! ./Image */ "./src/display/Image.ts");
var Utils = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var Tween_1 = __webpack_require__(/*! ../tween/Tween */ "./src/tween/Tween.ts");
var Easing_1 = __webpack_require__(/*! ../tween/Easing */ "./src/tween/Easing.ts");
/**
 * 滑动条/进度条
 *
 * @example let slider = new vf.gui.Slider();
 *
 */
var Slider = /** @class */ (function (_super) {
    __extends(Slider, _super);
    function Slider() {
        var _this = _super.call(this) || this;
        /**
         * 当前值
         */
        _this._amt = 0;
        /**
         * 小数的保留位，0不保留
         * @default 0
         */
        _this._decimals = 0;
        _this._startValue = 0;
        _this._maxPosition = 0;
        _this._lastChange = 0;
        _this._lastChanging = 0;
        _this._localMousePosition = new vf.Point();
        /** 状态展示 */
        _this.trackImg = new Image_1.Image();
        _this.thumbImg = new Image_1.Image();
        _this.tracklightImg = new Image_1.Image();
        _this._thumbDrag = new Index_1.DragEvent(_this.thumbImg);
        _this._trackDrag = new Index_1.DragEvent(_this.trackImg);
        /**
         * 最小值
         */
        _this._minValue = 0;
        /**
         * 最大值
         */
        _this._maxValue = 100;
        /**
         * 是否垂直,滑块方向
         */
        _this._vertical = false;
        _this.thumbImg.container.name = "thumbImg";
        _this.thumbImg.fillMode = "scale";
        _this.thumbImg.scale9Grid = [0, 0, 0, 0];
        _this.thumbImg.anchorX = 0.5;
        _this.thumbImg.anchorY = 0.5;
        _this.thumbImg.on(Index_1.ComponentEvent.COMPLETE, _this.onImgload, _this);
        _this.trackImg.container.name = "trackImg";
        _this.trackImg.fillMode = "scale";
        _this.trackImg.scale9Grid = [2, 2, 2, 2];
        _this.trackImg.style.width = "100%";
        _this.trackImg.style.height = "100%";
        _this.trackImg.on(Index_1.ComponentEvent.COMPLETE, _this.onImgload, _this);
        _this.tracklightImg.container.name = "tracklightImg";
        _this.tracklightImg.fillMode = "scale";
        _this.tracklightImg.scale9Grid = [2, 2, 2, 2];
        //this.tracklightImg.on(ComponentEvent.COMPLETE,this.onImgload, this);
        _this.addChild(_this.trackImg);
        _this.addChild(_this.tracklightImg);
        _this.addChild(_this.thumbImg);
        _this._thumbDrag.onDragPress = _this.onPress.bind(_this);
        _this._thumbDrag.onDragStart = _this.onDragStart.bind(_this);
        _this._thumbDrag.onDragMove = _this.onDragMove.bind(_this);
        _this._thumbDrag.onDragEnd = _this.onDragEnd.bind(_this);
        _this._trackDrag.onDragPress = _this.onPress.bind(_this);
        return _this;
    }
    Object.defineProperty(Slider.prototype, "value", {
        /**
         * 当前值
         */
        get: function () {
            return Utils.Round(Utils.Lerp(this.minValue, this.maxValue, this._amt), this._decimals);
        },
        set: function (value) {
            this.valueSystem(value);
        },
        enumerable: false,
        configurable: true
    });
    Slider.prototype.valueSystem = function (value) {
        if (value === void 0) { value = 0; }
        this._amt = (Math.max(this.minValue, Math.min(this.maxValue, value)) - this.minValue) / (this.maxValue - this.minValue);
        this.invalidateDisplayList();
    };
    Object.defineProperty(Slider.prototype, "minValue", {
        get: function () {
            return this._minValue;
        },
        set: function (value) {
            if (this._minValue === value) {
                return;
            }
            this._minValue = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "maxValue", {
        get: function () {
            return this._maxValue;
        },
        set: function (value) {
            if (this._maxValue === value) {
                return;
            }
            this._maxValue = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "vertical", {
        get: function () {
            return this._vertical;
        },
        set: function (value) {
            if (this._vertical === value) {
                return;
            }
            this._vertical = value;
            this.invalidateProperties();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "track", {
        get: function () {
            return this._track;
        },
        set: function (value) {
            if (value !== this._track) {
                this._track = value;
                this.trackImg.src = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "thumb", {
        get: function () {
            return this._thumb;
        },
        set: function (value) {
            if (value !== this._thumb) {
                this._thumb = value;
                this.thumbImg.src = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "tracklight", {
        get: function () {
            return this._tracklight;
        },
        set: function (value) {
            if (value !== this._tracklight) {
                this._tracklight = value;
                this.tracklightImg.src = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Slider.prototype.onImgload = function () {
        this.invalidateProperties();
    };
    Slider.prototype.updatePosition = function (soft) {
        var val = 0;
        var thumbImg = this.thumbImg;
        var tracklightImg = this.tracklightImg;
        if (this.vertical) {
            val = this.explicitHeight * this._amt;
            if (soft) {
                Tween_1.Tween.to({ y: thumbImg.y, height: tracklightImg.height }, { y: val, height: val }, 300).easing(Easing_1.Easing.Linear.None)
                    .on(Tween_1.Tween.Event.update, function (obj) {
                    thumbImg.y = obj.y;
                    //tracklightImg.height = obj.height;
                    tracklightImg.setSpeiteSize(undefined, obj.height);
                }).start();
            }
            else {
                thumbImg.y = val;
                tracklightImg.height = val;
            }
        }
        else {
            val = this.explicitWidth * this._amt;
            if (soft) {
                Tween_1.Tween.to({ x: thumbImg.x, width: tracklightImg.width }, { x: val, width: val }, 300).easing(Easing_1.Easing.Linear.None)
                    .on(Tween_1.Tween.Event.update, function (obj) {
                    thumbImg.x = obj.x;
                    //tracklightImg.width = obj.width;
                    tracklightImg.setSpeiteSize(obj.width);
                }).start();
            }
            else {
                thumbImg.x = val;
                tracklightImg.width = val;
            }
        }
    };
    Slider.prototype.onPress = function (event, isPressed, dragEvent) {
        event.stopPropagation();
        if (this._trackDrag == dragEvent && this._trackDrag.id == event.data.identifier) {
            if (isPressed) {
                this.updatePositionToMouse(event.data.global, true);
            }
        }
    };
    Slider.prototype.onDragStart = function (event) {
        if (this._thumbDrag.id == event.data.identifier) {
            this._startValue = this._amt;
            this._maxPosition = this.vertical ? this.explicitHeight : this.explicitWidth;
        }
    };
    Slider.prototype.onDragMove = function (event, offset) {
        if (this._thumbDrag.id == event.data.identifier) {
            this._amt = !this._maxPosition ? 0 : Math.max(0, Math.min(1, this._startValue + ((this.vertical ? offset.y : offset.x) / this._maxPosition)));
            this.triggerValueChanging();
            this.updatePosition();
        }
        else if (this._trackDrag && this._trackDrag.id == event.data.identifier) {
            this.updatePositionToMouse(event.data.global, false);
        }
    };
    Slider.prototype.onDragEnd = function (event) {
        if (this._thumbDrag.id == event.data.identifier) {
            this.triggerValueChange();
            this.updatePosition();
        }
        else if (this._trackDrag && this._trackDrag.id == event.data.identifier) {
            this.triggerValueChange();
        }
    };
    Slider.prototype.updatePositionToMouse = function (mousePosition, soft) {
        this.trackImg.container.toLocal(mousePosition, undefined, this._localMousePosition, true);
        var newPos = this.vertical ? this._localMousePosition.y : this._localMousePosition.x;
        var maxPos = this.vertical ? this.explicitHeight : this.explicitWidth;
        this._amt = !maxPos ? 0 : Math.max(0, Math.min(1, newPos / maxPos));
        this.updatePosition(soft);
        this.triggerValueChanging();
    };
    Slider.prototype.triggerValueChange = function () {
        var value = this.value;
        this.emit(Index_1.ComponentEvent.CHANGE, this, value, this._lastChange);
        if (this._lastChange != value) {
            this._lastChange = value;
        }
    };
    Slider.prototype.triggerValueChanging = function () {
        var value = this.value;
        this.emit(Index_1.ComponentEvent.CHANGEING, this, value, this._lastChanging);
        if (this._lastChanging != value) {
            this._lastChanging = value;
        }
    };
    Slider.prototype.updateLayout = function () {
        this.invalidateProperties();
    };
    Slider.prototype.commitProperties = function () {
        var thumbImg = this.thumbImg;
        var tracklightImg = this.tracklightImg;
        if (this.vertical) {
            thumbImg.y = this._amt;
            thumbImg.x = this.explicitWidth >> 1;
            tracklightImg.width = this.width;
            tracklightImg.height = this._amt * this.height;
        }
        else {
            thumbImg.x = this._amt;
            thumbImg.y = this.explicitHeight >> 1;
            tracklightImg.height = this.height;
            tracklightImg.width = this._amt * this.width;
        }
    };
    Slider.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        this.commitProperties();
        this.updatePosition();
        _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
    };
    Slider.prototype.release = function () {
        _super.prototype.release.call(this);
        this.trackImg.release();
        this.thumbImg.release();
        this.tracklightImg.release();
    };
    return Slider;
}(DisplayObject_1.DisplayObject));
exports.Slider = Slider;


/***/ }),

/***/ "./src/display/SpriteAnimated.ts":
/*!***************************************!*\
  !*** ./src/display/SpriteAnimated.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpriteAnimated = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
/**
 * 序列图动画
 *
 * 支持使用texturepacker导出以及处理轴点
 *
 * @example let spriteAnimated = new vf.gui.SpriteAnimated();
 *
 */
var SpriteAnimated = /** @class */ (function (_super) {
    __extends(SpriteAnimated, _super);
    function SpriteAnimated() {
        var _this = _super.call(this) || this;
        _this._lastAnimatedName = "";
        _this._curFrameNumber = 0;
        _this._setTimeoutId = -1;
        /**
         * 要播放的动作名
         */
        _this._animationName = "default";
        /**
         * 动画速度
         */
        _this._animationSpeed = 0.1;
        /**
         * 是的循环
         */
        _this._loop = false;
        _this._playCount = 0;
        /**
         * 循环次数
         */
        _this._loopCount = 0;
        /**
         * 是否播放中
         */
        _this._playing = false;
        _this._animatedSprites = new Map();
        return _this;
    }
    Object.defineProperty(SpriteAnimated.prototype, "animationName", {
        get: function () {
            return this._animationName;
        },
        set: function (value) {
            if (this._animationName == value) {
                return;
            }
            this._animationName = value;
            this.animatedNameSystem();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimated.prototype, "src", {
        get: function () {
            return this._src;
        },
        set: function (value) {
            this._src = value;
            if (value === undefined) {
                this.releaseAnimate();
            }
            else {
                this.srcSystem();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimated.prototype, "animationSpeed", {
        get: function () {
            return this._animationSpeed;
        },
        set: function (value) {
            this._animationSpeed = value;
            this.attribSystem();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimated.prototype, "loop", {
        get: function () {
            return this._loop;
        },
        set: function (value) {
            this._loop = value;
            this.attribSystem();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimated.prototype, "loopCount", {
        get: function () {
            return this._loopCount;
        },
        set: function (value) {
            this._loopCount = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimated.prototype, "playing", {
        get: function () {
            return this._playing;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimated.prototype, "anchorX", {
        /**
         * 锚点，调整位图的坐标中点 0-1, 可通过 TexturePacker输出sheet图并设置好 anchor
         */
        get: function () {
            return this._anchorX;
        },
        set: function (value) {
            this._anchorX = value;
            this.attribSystem();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimated.prototype, "anchorY", {
        /**
         * 锚点，调整位图的坐标中点 0-1, 可通过 TexturePacker输出sheet图并设置好 anchor
         */
        get: function () {
            return this._anchorY;
        },
        set: function (value) {
            this._anchorY = value;
            this.attribSystem();
        },
        enumerable: false,
        configurable: true
    });
    /** 跳转到第N帧并播放 */
    SpriteAnimated.prototype.gotoAndPlay = function (frameNumber) {
        this._curFrameNumber = frameNumber;
        this._playing = true;
        this.playSystem();
    };
    /** 跳转到第N帧并停止 */
    SpriteAnimated.prototype.gotoAndStop = function (frameNumber) {
        this._curFrameNumber = frameNumber;
        this._playing = false;
        this.playSystem();
    };
    /** 停止 */
    SpriteAnimated.prototype.stop = function () {
        this._playCount = 0;
        this._curFrameNumber = 0;
        this._playing = false;
        this.playSystem();
    };
    /** 播放 */
    SpriteAnimated.prototype.play = function () {
        this._playCount = 0;
        this._curFrameNumber = 0;
        this._playing = true;
        this.playSystem();
    };
    Object.defineProperty(SpriteAnimated.prototype, "autoPlay", {
        /**
         * 请在构造函数后立即设置
         */
        get: function () {
            return this._playing;
        },
        set: function (value) {
            this._playing = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimated.prototype, "isPlay", {
        set: function (value) {
            if (value) {
                this.play();
            }
            else {
                this.stop();
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 添加动画
     */
    SpriteAnimated.prototype.addAnimated = function (animationName, textures) {
        var sp = this._animatedSprites.get(animationName);
        if (sp) {
            if (sp.parent)
                sp.parent.removeChild(sp);
            sp.removeAllListeners();
            sp.destroy();
        }
        this._animatedSprites.set(animationName, new vf.AnimatedSprite(textures));
    };
    SpriteAnimated.prototype.release = function () {
        if (this._setTimeoutId) {
            clearTimeout(this._setTimeoutId);
        }
        _super.prototype.release.call(this);
        this.releaseAnimate();
        this.src = undefined;
    };
    SpriteAnimated.prototype.releaseAnimate = function () {
        this._lastAnimatedName = '';
        this._animatedSprites.forEach(function (element) {
            if (element.parent) {
                element.parent.removeChild(element);
            }
            element.removeAllListeners();
            element.destroy();
        });
        this._animatedSprites.clear();
    };
    SpriteAnimated.prototype.srcSystem = function () {
        this.releaseAnimate();
        var src = Utils_1.getSheet(this.src);
        if (src) {
            if (Array.isArray(src)) {
                var textures_1 = [];
                src.forEach(function (value) {
                    if (value.time) {
                        value.texture = Utils_1.getTexture(value.texture);
                        textures_1.push(value);
                    }
                    else {
                        textures_1.push(Utils_1.getTexture(value));
                    }
                });
                this.addAnimated("default", textures_1);
            }
            else {
                for (var key in src.animations) {
                    this.addAnimated(key, src.animations[key]);
                }
            }
            this.animatedNameSystem();
        }
    };
    SpriteAnimated.prototype.animatedNameSystem = function () {
        var _this = this;
        if (this._animatedSprites.size == 0) {
            return;
        }
        if (this.animationName === this._lastAnimatedName) {
            return;
        }
        var animatedSp = this._animatedSprites.get(this.animationName);
        if (animatedSp == undefined) {
            Utils_1.log("Warning SpriteAnimated -> _animatedSprites[" + this.animationName + "] == undefined");
            return;
        }
        var lastAnimated = this._animatedSprites.get(this._lastAnimatedName);
        animatedSp.onLoop = function () {
            _this.emit(Index_1.ComponentEvent.LOOP, _this);
            _this._playCount++;
            if (_this._loopCount !== 0 && _this._playCount >= _this._loopCount) {
                _this.stop();
            }
        };
        animatedSp.onComplete = function () {
            _this.emit(Index_1.ComponentEvent.COMPLETE, _this);
        };
        if (animatedSp.parent == undefined) {
            clearTimeout(this._setTimeoutId);
            this._setTimeoutId = setTimeout(function () {
                //绘制会闪烁，与下一帧渲染有关，先临时解决，设置setTimeout
                _this.container.addChild(animatedSp);
            }, 0);
        }
        if (lastAnimated && lastAnimated.parent) {
            lastAnimated.stop();
            lastAnimated.parent.removeChild(lastAnimated);
        }
        this._lastAnimatedName = this.animationName;
        this._curFrameNumber = 0;
        this.emit(Index_1.ComponentEvent.CHANGE, this, this.animationName);
        this.attribSystem();
        this.playSystem();
    };
    SpriteAnimated.prototype.playSystem = function () {
        var animatedSp = this._animatedSprites.get(this.animationName);
        if (animatedSp) {
            if (this.playing) {
                animatedSp.gotoAndPlay(this._curFrameNumber);
            }
            else {
                animatedSp.gotoAndStop(this._curFrameNumber);
            }
        }
    };
    SpriteAnimated.prototype.attribSystem = function () {
        var animatedSp = this._animatedSprites.get(this.animationName);
        if (animatedSp) {
            animatedSp.loop = this.loop;
            animatedSp.animationSpeed = this.animationSpeed;
            animatedSp.anchor.set(this.anchorX, this.anchorY);
        }
    };
    return SpriteAnimated;
}(DisplayObject_1.DisplayObject));
exports.SpriteAnimated = SpriteAnimated;


/***/ }),

/***/ "./src/display/Star.ts":
/*!*****************************!*\
  !*** ./src/display/Star.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Star = void 0;
var LineGradient_1 = __webpack_require__(/*! ../core/plugs/LineGradient */ "./src/core/plugs/LineGradient.ts");
var GraphBase_1 = __webpack_require__(/*! ./private/GraphBase */ "./src/display/private/GraphBase.ts");
var Star = /** @class */ (function (_super) {
    __extends(Star, _super);
    function Star() {
        var _this = _super.call(this) || this;
        _this.path = [];
        _this.PI_2 = Math.PI * 2;
        _this._triangleNum = 5; // 默认角数  这个值需要大于1才行
        _this.RADIUS_V = 1; //外半径默认值
        _this._innerRadius = _this.RADIUS_V / 2;
        return _this;
    }
    Star.prototype.drawGraph = function () {
        var graphics = this.graphics;
        graphics.clear();
        this.path = [];
        if (this._triangleNum <= 1 || this._lineWidth < 0) {
            console.log("属性错误，线宽小于0或者角数错误");
            return;
        }
        graphics.lineStyle(this._lineWidth, this._lineColor, this._lineAlpha, 0.5, false, this.lineType);
        this.setStarPath();
        if (this.color) {
            graphics.beginFill(this._color, this._fillAlpha);
        }
        else {
            LineGradient_1.updateTextureFill(this.graphics, this);
        }
        graphics.drawPolygonOne(this.path);
        graphics.endFill();
    };
    Object.defineProperty(Star.prototype, "triangleNum", {
        get: function () {
            return this._triangleNum;
        },
        set: function (value) {
            this._triangleNum = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Star.prototype, "innerRadius", {
        get: function () {
            return this._innerRadius;
        },
        set: function (value) {
            this._innerRadius = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Star.prototype.setStarPath = function () {
        var radius = this.RADIUS_V;
        if (isNaN(this.innerRadius)) {
            this.innerRadius = radius / 2;
        }
        var innerRadius = this.innerRadius;
        var triangleNum = this._triangleNum;
        var PI_2 = this.PI_2;
        var startAngle = (-1 * Math.PI / 2);
        var len = triangleNum * 2;
        var delta = PI_2 / len;
        // let maxX = Number.MIN_VALUE;
        // let minX = Number.MAX_VALUE;
        // let maxY = Number.MIN_VALUE;
        // let minY = Number.MAX_VALUE;
        var scaleWidth = this.width > 0 ? this.width / (radius * 2) : 1;
        var scaleHeight = this.height > 0 ? this.height / (radius * 2) : 1;
        var anchorX = this._anchorX ? this._anchorX : 0;
        var anchorY = this._anchorY ? this._anchorY : 0;
        for (var i = 0; i < len; i++) {
            var r = i % 2 ? innerRadius : radius;
            var angle = (i * delta) + startAngle;
            var pX = (r * Math.cos(angle) + anchorX + radius) * scaleWidth;
            var pY = (r * Math.sin(angle) + anchorY + radius) * scaleHeight;
            var point = new vf.Point(pX, pY);
            // maxX = maxX < pX ? pX : maxX;
            // minX = minX > pX ? pX : minX;
            // maxY = maxY < pY ? pY : maxY;
            // minY = minY > pY ? pY : minY;
            this.path.push(point);
        }
        // -----------这个功能有需要再放开  保证上下左右全部贴边---------------
        // this.autoSizeShape(maxX, minX, maxY, minY);
    };
    return Star;
}(GraphBase_1.GraphBase));
exports.Star = Star;


/***/ }),

/***/ "./src/display/TextInput.ts":
/*!**********************************!*\
  !*** ./src/display/TextInput.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextInput = void 0;
var HtmlInput_1 = __webpack_require__(/*! ./private/HtmlInput */ "./src/display/private/HtmlInput.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var InputBase_1 = __webpack_require__(/*! ./private/InputBase */ "./src/display/private/InputBase.ts");
var Image_1 = __webpack_require__(/*! ./Image */ "./src/display/Image.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
/**
 * 文本输入
 *
 * @example let textInput = new vf.gui.TextInput(true|false);//单行或多行
 *
 */
var TextInput = /** @class */ (function (_super) {
    __extends(TextInput, _super);
    function TextInput(multiline) {
        if (multiline === void 0) { multiline = false; }
        var _this = _super.call(this) || this;
        _this._oldState = "";
        _this._resolution = 1;
        _this._previous = {};
        /**
         * 预览文字的样式
         */
        _this.placeholderColor = 0xa9a9a9;
        _this._domVisible = true;
        _this.state = 'DEFAULT';
        /**
         * 预览文字
         */
        _this._placeholder = '';
        /**
         * 设置最大可输入
         */
        _this._maxLength = 99999;
        /**
         * 状态展示
        */
        _this.img = new Image_1.Image();
        _this.container.interactiveChildren = true;
        _this._inputStyle = Object.assign({
            position: 'absolute',
            background: 'none',
            border: 'none',
            outline: 'none',
            transformOrigin: '0 0',
            padding: '5px 8px',
            color: '#26272e',
            lineHeight: '1',
            fontSize: "25px"
        }, {
            multiline: multiline
        });
        _this.htmlInputShared = new HtmlInput_1.default(_this._inputStyle.multiline);
        _this.htmlInputShared.setStyle(_this._inputStyle);
        _this.htmlInputShared.on("input" /* input */, _this._onInputInput, _this);
        _this.htmlInputShared.on('focus', _this._onFocused, _this);
        _this.htmlInputShared.on('blur', _this._onBlurred, _this);
        _this.img.fillMode = "scale";
        _this.img.scale9Grid = [3, 3, 3, 3];
        _this.addChild(_this.img);
        _this._textHitbox = new vf.Graphics();
        _this._textHitbox.name = "_textHitbox";
        _this._textHitbox.alpha = 0;
        _this._textHitbox.interactive = true;
        _this._textHitbox.cursor = 'text';
        _this._textHitbox.on('pointerdown', _this._ontextFocus, _this);
        _this.container.addChild(_this._textHitbox);
        _this._textMask = new vf.Graphics();
        _this._textMask.name = "_textMask";
        _this.container.addChild(_this._textMask);
        _this._text = new vf.Text('', {});
        _this._text.name = "_text";
        _this._text.visible = false;
        _this._text.mask = _this._textMask;
        _this.container.addChild(_this._text);
        _this._domVisible = false;
        _this.on(Index_1.ComponentEvent.STATE_CHANGE, _this.onStateChange, _this);
        _this.container.isEmitRender = false;
        _this.container.on("renderChange", _this.updateSystem, _this);
        return _this;
    }
    Object.defineProperty(TextInput.prototype, "text", {
        /**
         * 设置文本
         */
        get: function () {
            return this._text.text;
        },
        set: function (value) {
            this.container.isEmitRender = true;
            this._text.text = value;
            this.htmlInputShared.value = value;
            if (this.stage) {
                this.updateSystem(this.stage.app.renderer);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextInput.prototype, "placeholder", {
        get: function () {
            return this._placeholder;
        },
        set: function (value) {
            this._placeholder = value;
            this.container.isEmitRender = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextInput.prototype, "maxLength", {
        get: function () {
            return this._maxLength;
        },
        set: function (value) {
            this._maxLength = value;
            this.container.isEmitRender = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextInput.prototype, "restrict", {
        get: function () {
            return this._restrict;
        },
        set: function (value) {
            this._restrict = value;
            this.container.isEmitRender = true;
        },
        enumerable: false,
        configurable: true
    });
    // GETTERS & SETTERS
    TextInput.prototype.updateSystem = function (renderer) {
        if (renderer === undefined) {
            return;
        }
        var htmlInputShared = this.htmlInputShared;
        htmlInputShared.maxlength = this.maxLength;
        htmlInputShared.placeholder = this.placeholder;
        htmlInputShared.disabled = !this.enabled;
        htmlInputShared.restrict = this.restrict;
        this.setInputStyle("fontFamily", this.style.fontFamily);
        this.setInputStyle("fontSize", this.style.fontSize);
        this.setInputStyle("color", this.style.color);
        this.setInputStyle("width", this.explicitWidth + "px");
        this.setInputStyle("height", this.explicitHeight + "px");
        this.render(renderer);
        this.onStateChange(this, this.currentState);
        this.container.isEmitRender = false;
    };
    /**
     * 设置焦点
     */
    TextInput.prototype.focus = function () {
        this.htmlInputShared.focus();
    };
    /**
     * 失去焦点
     */
    TextInput.prototype.blur = function () {
        this.htmlInputShared.blur();
    };
    /**
     * 设置css style样式
     * @param key 健
     * @param value 值
     */
    TextInput.prototype.setInputStyle = function (key, value) {
        if (key === "fontSize") {
            value = value + "px";
        }
        if (key === "color") {
            value = "#" + Utils_1.componentToHex(value);
        }
        this._inputStyle[key] = value;
        this.htmlInputShared.setStyleValue(key, value);
    };
    TextInput.prototype.onStateChange = function (ui, state) {
        if (this._oldState == state) {
            return;
        }
        if (!this.enabled) {
            this.currentState = "disabled";
        }
        this._oldState = state;
        var img = this.img;
        img.src = this[state];
    };
    // SETUP
    TextInput.prototype._onInputInput = function () {
        this._updateSubstitution();
    };
    TextInput.prototype._onFocused = function () {
        this._setState('FOCUSED');
    };
    TextInput.prototype._onBlurred = function () {
        this._setState('DEFAULT');
    };
    TextInput.prototype._setState = function (state) {
        this.state = state;
        this._updateSubstitution();
    };
    TextInput.prototype._updateSubstitution = function () {
        if (this.state === 'FOCUSED') {
            this._domVisible = true;
            this._text.visible = false;
        }
        else {
            this._domVisible = false;
            this._text.visible = true;
        }
        this._updateDOMInput();
        this._updatetext();
    };
    // RENDER & UPDATE
    // for VF v5
    TextInput.prototype.render = function (renderer) {
        this._renderInternal(renderer);
    };
    TextInput.prototype._renderInternal = function (renderer) {
        this._resolution = renderer.resolution;
        this._lastRenderer = renderer;
        this._canvasBounds = this._getCanvasBounds();
        if (this._needsUpdate()) {
            this._updateSubstitution();
        }
    };
    TextInput.prototype._updateDOMInput = function () {
        if (!this._canvasBounds)
            return;
        var cb = this._canvasBounds;
        var transform = this._vfMatrixToCSS(this._getDOMRelativeWorldTransform());
        this.htmlInputShared.updatePostion(cb.top, cb.left, transform, this.container.worldAlpha);
        this.htmlInputShared.visible = this.container.worldVisible && this._domVisible;
        this._previous.canvasBounds = this._canvasBounds;
        this._previous.worldTransform = this.container.worldTransform.clone();
        this._previous.worldAlpha = this.container.worldAlpha;
        this._previous.worldVisible = this.container.worldVisible;
    };
    // STATE COMPAIRSON (FOR PERFORMANCE BENEFITS)
    TextInput.prototype._needsUpdate = function () {
        return (!this._comparevfMatrices(this.container.worldTransform, this._previous.worldTransform)
            || !this._compareClientRects(this._canvasBounds, this._previous.canvasBounds)
            || this.container.worldAlpha != this._previous.worldAlpha
            || this.container.worldVisible != this._previous.worldVisible);
    };
    TextInput.prototype._updatetext = function () {
        var padding = this._derivetextPadding();
        var inputBounds = this.htmlInputShared.getDOMInputBounds();
        this._text.style = this._derivetextStyle();
        this._text.style.padding = Math.max.apply(Math, padding);
        this._text.y = this._inputStyle.multiline ? padding[0] : (inputBounds.height - this._text.height) / 2;
        this._text.x = padding[3];
        if (this._inputStyle.multiline) {
            this._text.style.wordWrap = true;
            this._text.style.wordWrapWidth = inputBounds.width;
            this._text.style.breakWords = true;
        }
        this._text.text = this._derivetextText();
        this._textHitbox.clear();
        this._textHitbox.beginFill(0);
        this._textHitbox.drawRect(0, 0, inputBounds.width, inputBounds.height);
        this._textHitbox.endFill();
        this._textHitbox.interactive = this.enabled;
        this._textMask.clear();
        this._textMask.beginFill(0);
        this._textMask.drawRect(padding[3], 0, inputBounds.width - padding[3] - padding[1], inputBounds.height);
        this._textMask.endFill();
        this.img.width = inputBounds.width;
        this.img.height = inputBounds.height;
    };
    TextInput.prototype._ontextFocus = function () {
        this.htmlInputShared.visible = true;
        //sometimes the input is not being focused by the mouseclick
        setTimeout(this._ensureFocus.bind(this), 10);
    };
    TextInput.prototype._ensureFocus = function () {
        if (!this._hasFocus())
            this.focus();
    };
    TextInput.prototype._derivetextStyle = function () {
        var style = new vf.TextStyle();
        for (var key in this._inputStyle) {
            switch (key) {
                case 'color':
                    style.fill = this._inputStyle.color;
                    break;
                case 'fontFamily':
                case 'fontSize':
                case 'fontWeight':
                case 'fontVariant':
                case 'fontStyle':
                    style[key] = this._inputStyle[key];
                    break;
                case 'letterSpacing':
                    style.letterSpacing = parseFloat(this._inputStyle.letterSpacing);
                    break;
            }
        }
        if (this._inputStyle.multiline) {
            style.lineHeight = parseFloat(style.fontSize);
            style.wordWrap = true;
            style.wordWrapWidth = this.htmlInputShared.getDOMInputBounds().width;
        }
        if (this.htmlInputShared.value.length === 0)
            style.fill = this.placeholderColor;
        return style;
    };
    TextInput.prototype._derivetextPadding = function () {
        var indent = this._inputStyle.textIndent ? parseFloat(this._inputStyle.textIndent) : 0;
        if (this._inputStyle.padding && this._inputStyle.padding.length > 0) {
            var components = this._inputStyle.padding.trim().split(' ');
            if (components.length == 1) {
                var padding = parseFloat(components[0]);
                return [padding, padding, padding, padding + indent];
            }
            else if (components.length == 2) {
                var paddingV = parseFloat(components[0]);
                var paddingH = parseFloat(components[1]);
                return [paddingV, paddingH, paddingV, paddingH + indent];
            }
            else if (components.length == 4) {
                var padding = components.map(function (component) {
                    return parseFloat(component);
                });
                padding[3] += indent;
                return padding;
            }
        }
        return [0, 0, 0, indent];
    };
    TextInput.prototype._derivetextText = function () {
        return this.htmlInputShared.value.length === 0 ? this.placeholder : this.htmlInputShared.value;
    };
    // private _updateFontMetrics() {
    //     const style = this._derivetextStyle();
    //     const font = style.toFontString();
    //     this._fontMetrics = vf.TextMetrics.measureFont(font);
    // }
    // HELPER FUNCTIONS
    TextInput.prototype._hasFocus = function () {
        return document.activeElement === this.htmlInputShared.domInput;
    };
    TextInput.prototype._getCanvasBounds = function () {
        if (this._lastRenderer) {
            var rect = this._lastRenderer.view.getBoundingClientRect();
            var bounds = { top: rect.top, left: rect.left, width: rect.width, height: rect.height };
            bounds.left += window.scrollX;
            bounds.top += window.scrollY;
            return bounds;
        }
        return undefined;
    };
    TextInput.prototype._getDOMRelativeWorldTransform = function () {
        if (this._lastRenderer) {
            var canvasBounds = this._lastRenderer.view.getBoundingClientRect();
            var matrix = this.container.worldTransform.clone();
            matrix.scale(this._resolution, this._resolution);
            matrix.scale(canvasBounds.width / this._lastRenderer.width, canvasBounds.height / this._lastRenderer.height);
            return matrix;
        }
    };
    TextInput.prototype._vfMatrixToCSS = function (m) {
        return 'matrix(' + [m.a, m.b, m.c, m.d, m.tx, m.ty].join(',') + ')';
    };
    TextInput.prototype._comparevfMatrices = function (m1, m2) {
        if (!m1 || !m2)
            return false;
        return (m1.a == m2.a
            && m1.b == m2.b
            && m1.c == m2.c
            && m1.d == m2.d
            && m1.tx == m2.tx
            && m1.ty == m2.ty);
    };
    TextInput.prototype._compareClientRects = function (r1, r2) {
        if (!r1 || !r2)
            return false;
        return (r1.left == r2.left
            && r1.top == r2.top
            && r1.width == r2.width
            && r1.height == r2.height);
    };
    TextInput.prototype.release = function () {
        this._text.removeAllListeners();
        this.container.removeChild(this._text);
        this._text.destroy();
        this._text = undefined;
        this._textHitbox.removeAllListeners();
        this.container.removeChild(this._textHitbox);
        this._textHitbox && this._textHitbox.destroy();
        this._textHitbox = undefined;
        this.img && this.img.parent && this.img.parent.removeChild(this.img);
        this.img.release();
        this.img = undefined;
        this._textMask.parent.removeChild(this._textMask);
        this._textMask.destroy();
        this._textMask = undefined;
        this.htmlInputShared.release();
        this.htmlInputShared = undefined;
        this._lastRenderer = undefined;
        this._inputStyle = undefined;
        this._fontMetrics = undefined;
        this.container.off("renderChange", this.updateSystem, this);
        this.offAll(Index_1.ComponentEvent.STATE_CHANGE);
        _super.prototype.release.call(this);
    };
    return TextInput;
}(InputBase_1.InputBase));
exports.TextInput = TextInput;


/***/ }),

/***/ "./src/display/Tracing.ts":
/*!********************************!*\
  !*** ./src/display/Tracing.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tracing = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Utils_2 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Tween_1 = __webpack_require__(/*! ../tween/Tween */ "./src/tween/Tween.ts");
/**
 * 临摹组件
 *
 * @example let Tracing = new vf.gui.Tracing();
 *
 * @namespace vf.gui
 *
 */
var GUIDE_SPRITE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAyCAYAAADImlLUAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAClpJREFUeJzdmQdU1FcWxmWGYUDqUKUFESlDFxAECxiNgg1EjYghUYMaNW7QjRvbYhTLYpSQ2HBtRDREsMW2rEYRD0SjxFiiRowr0hQEpA11xrv3vmEIZWAGs8I5+855B5hh3vu97333vvv+06fP/0NTUVVVNRrk6WjsOdjfyMNrqKHbIJs+KhyV3uaS21S4XBVDV3dnhE028fIutho2QmzpN7ze2Ms7z9jDa5OBq7tJbzN2aASMsE/Mh/hB3IGDcO3WHbhyPRsWfb4eTAb7AC4mA1U3723OloYqcxDqG4I7lZ4B7dvW/Yky8GQ9OzuN3uZlTc9eaIU2ePRR9DqobnjVAZpa4vETYDXcX4Jqx/U2L2t6dg5OaI282D2JUCKSgDzsapEIZv1tBSlepe/s6tu7xCocjnZ/a2dU+vGnsVuhsFoMtU3y1b7zMAdcx00gm2Ry1dXVehNala9vYIkgv4yc+T6DLq2VgFgOt1gigVVx8czfAgfHYb2XChEaA9HI0N1jO8GcybrBwCvrJXLVluBiRkXMIrWzDFxcbVsPpWlmbo25PQzHWYn9c9y9KPpb4OhkTe9rW1kZ42LdBQ5CZ76+vuGfgVbpw+Fooq+DcKKaeaujGfSzGjE0yJMb26mL6UxtBNrKUVPjCeyFNvj7KXqtn/cQsPQbBgP8R4KF71D2N77ehAt4Ru+37rjwm0bug6YauroZdxeag9Aaanp6A/AQuUST3fpPIQOvqJcflA2NTRA4+0OaON/I3SMOgZ64jZsIC/6+BlLOpcGNO3fg1v0HcP32bTh16TIsXhsDtiNHg5mPL3z2RRzEJybB8i+2QOCsD2mBDfj5bDwnJncvnSI4WsQAt9cfQepXxH0Nj19UQxGqXdUg3ybns66C+4RJBC6hn4+e5sv9P2q19Q2wLekwU3fSvAVQ+rKCvV4tqoWjaedh+PRweq8Sy4ct3bIIQutg3WGJyqWQ2kcuZLTYpEkO9yvcgtjdexkIqf5KvpP+2J0mMYyPnMf+P2bHLoyNPz5QUFwCoQsWsff0nVzClAfncNQQ3FjD2MSNvB04ey78XlLFwCl3y2svyl/C6IgP2GT/PJLaNTW2opIX4BM6jVnlMpYIrVtxaRksiF5LY9UYKH0OSAOyL6pthkF10sb/bfGZrGwGTZ1OyvZiklgHjp1gQecVHIoWyVMIfi4jExzHBELQnLlQWSNqM9bDJ0/Zexiglw2cXZQo0Aha6m09nQED38EP3otYtqJF7SLsNY0dPVBTWwfbDh5mWSJgxkycOLdLaAnmzAPHTsLgkFC4cfdeh/f3owiothj9/SlVnkoKztVAtS3Q29tdgsZDyoUrLWoXo00kcrxbhQHlN206swllh0axuEtwUV0dXMUqknzevpVUiliAU0YRCB31lbUJjzIJHu3DsB4ppCCTQVN/LhLLDTraWprMDEvbDbt2dwndvtFwVDrQSUxzfJ/xo6w4W6octFRtTebtQZ7fknrpN++1Aa/o5LS8m/MYPCaGMMXTf7qhFDBlprI6SZvxc8trYdL8haR2jbaVta6y1JRJBHjkTscPlixcu6HNoJS/6+QUVbQDmT//AjM+WQoZ17uGpsOWgvt5jbjN2LK+PfkomHr7Aqo9qztqa/Q1NXPFTHIatwoe5Be3tQlOVt9JNSiWZ/xWjQKabCYPVtav/fYEKKaoPCAY5agxb+O9MAq3upG2e3HMJiiobOwA3thJfSKvUS1TVivpElbW8yrqIXThX1jexl3XUqqi1DS31Me0d91t/ESWnuxGvQOXfv61w+AE3ln9LWuNqHx5nXKwrXvSmX9LT0lHp9GsRlLgDRV9R2e66BZFroyG2L2JLA+v27VH7uAETlve/rinTaDXixVYobP+qKiMVYyYfqP6cLg8RdA8rJWDrEcEiL86nMIOmNFYQ/tNC4PbucWdTkLwlLYou5CyBFv0GrCte0D4e+hrz0Pab1kpOCERWl/oNM1h9BhIPJ3GPnwQt4qOa/r5ZyC628OiltKxfkUgdLJTBM03dHOf6zgmCA796yL7MKlNRRQtJOd5ZY9BL163kaDv6dkLvbv2NWYOzNFhFHz7Tp5tGWDnd8eYtymH9hT08q3xdMj8jke6ryJodYQebz7Erz4mYV/LANmP8sAzeDJWaJE9Br1kYywp/RvyDOkaGj2ta2vnSbXH+1jpyQYoqGqCHajy3FXRPQb93l8/Y57WtbF1VgTNVzcwNKc87Tg2CAqrGnoMsn0fERZOKS8JeSwVKk2VHl42N1Fyb12e9mS/eON28xXM+WPiUQTNweNeS2AvDMYgyJ8fva7HgXPL62ARFmoErWdnH0x32K6PcunVS52no2uN9UcsFUwn0rNwsKYeg05OuwT9hwewbIU2vYO7HqS4/pA9VrCw9KaiZcwHc+B+QWmPAD98XgHBH0lv53NWrGLPSxD8Et7UBYqgZRddU0NXt+U0QPjSZWzANwn8oLAMD7FIVnPE7NwNlaJ6WI8/pTcZ9yldQ0vB1dDb9DzECovxvQjeMBavXzcfF7wR4PsIHBAegcr6wbLYLVBWJWLQu79LhYEBb7/SFzpOpWePCi1C3kZoEzVdPWf01RbM3ZXeIVNg3/HTcOtJ0f8s6BJPpcHYWZHsmUjMjgTIe17KgItKX8IIvOVjQsjFXO2mGFoKzsVONumnqqnpgLXtHPTXI7rADn13Bhw+dwGeloleG/he/gtYtvlLFnT0fc+JH9IZrKyvivuaeRsF24wMhspBS8F5zeAmZBUNI2MftEsCrZ6imy4KK7/cDqczr7NLqTKwP+F1KnpbAivASIDIFash69bdFtji8krYmLCXBSHO9Y2GiYmb4rTXEZwCk9/scQsOj2eDlnHDy8ISvMelUoYhRah8DVnwMaxBoJQfrsDF7Lusn/0xG776NhWiNsSC79R3WSojoHmr10Ba5lWoqKlrAc7JK4SZGPTscbK7RzLNRYJRIac8sAxa2vnNDytJ9be4Ghp2qIKPwEE4GxWJxwVcpgMJ1Wugi6n35Kmse04KAbxUoGdHwTC01TysX5K+PwtPn71oAS6vroUzGZkwIXI+mPsOrUHgo337mQ6hDIZiaSu+cnUOz2E+57DMokW5nC2Ax7MiRVQ1tZy0LCxH6Q60jcBJD6Fa1YMxcGmrj6Nfr93+FXKLiqGilW/JCgRLDyBxpyQYMw/w6F7C09YRNgNr4XxK3siVU5/PHqVxuQI2gaqqGfmeo6ZmT943GuR5kjLC5j372wSYrF/FRazdthOcxo5r/nbA67zOAJsQ/LwtG4vDfPyaCiteAO2AGkuR5HvpDlioGxp5omXSCYiU3Jd6HHYlH4FP1v+DVXDNX2XU4uJS9WztI2ix9JycHjtTDL05YPmL4DP7oFp9Tc38ECpZFqz0VBTz/Uv0fg6msngd6wGBHD6fYK1ooc1ZQsHt+82Dm2OmcdG1GThFYO8wF6u2OQgajEHmS8piLFgzK9DuoNV6Vt3OwbXpaz/mdQzW5hTWnylLr3O5uvRlVe/Dtm5Sv/Obva7LOv0uVbXbvv0vybmCZrgGsxMAAAAASUVORK5CYII=";
var POS_DISTANCE = 7;
/** 优化曲率，小于这个弧度视为直线，把当前点优化掉 */
var MAX_ARC = 0.09; // 5度
/** 点数字转换成字符的数位 */
var DIGIT = 90;
/** 字符列表 ascii */
var NUMBER_TO_STR = "$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}";
/** 压缩比例，有损压缩 */
var COMPRESS_RATE = 2;
/** 最大宽度 */
var MAX_WIDTH = 1500;
/** 为了把点都变成正数所用 */
var POSITIVE = MAX_WIDTH / 2;
/** 将一个x，y坐标转换成3个字符，宽高不能超过MAX_WIDTH */
function getStrFromPos(x, y) {
    x = Math.min(Math.max(0, x), MAX_WIDTH);
    y = Math.min(Math.max(0, y), MAX_WIDTH);
    // 有损压缩
    var compX = Math.floor(x / COMPRESS_RATE);
    var compY = Math.floor(y / COMPRESS_RATE);
    var n1 = compX % DIGIT;
    var n2 = compY % DIGIT;
    var n3 = Math.floor(compX / DIGIT) * 10 + Math.floor(compY / DIGIT);
    return NUMBER_TO_STR[n1] + NUMBER_TO_STR[n2] + NUMBER_TO_STR[n3];
}
/** 将字符串转换成坐标数字列表 */
function getVecListFromStr(str, from, to) {
    var list = [];
    for (var index = from; index < to; index += 3) {
        var n1 = str.charCodeAt(index) - 36;
        var n2 = str.charCodeAt(index + 1) - 36;
        var n3 = str.charCodeAt(index + 2) - 36;
        var n12 = Math.floor(n3 / 10);
        var n22 = n3 % 10;
        var compX = n1 + n12 * DIGIT;
        var compY = n2 + n22 * DIGIT;
        var realX = compX * COMPRESS_RATE;
        var realY = compY * COMPRESS_RATE;
        list.push(realX);
        list.push(realY);
    }
    return list;
}
var Tracing = /** @class */ (function (_super) {
    __extends(Tracing, _super);
    function Tracing() {
        var _this = _super.call(this) || this;
        _this._renderMode = 0; //绘图模式  0-graphics drawLine  1-mask
        _this._realTraceIndexArr = []; //实际临摹轨迹
        _this._tempTraceIndexArr = []; //暂存区
        _this._lineStyle = {}; //线条样式
        _this._posCache = []; //绘图的坐标缓存
        _this._drawing = false; //是否正在画线
        _this._lastLocalPos = new vf.Point(); //上一次的触点
        _this._curLocalPos = new vf.Point(); //当前触点
        _this._autoComplete = false; //自动绘制是否完成
        _this._curIndex = -1; //当前index
        _this._tracePointObjArr = [];
        _this._result = 0 /* Uncomplete */; //临摹结果
        _this._groupStatusArr = []; //每个笔画的状态
        _this._lineId = 0; //绘制笔画id
        _this._newLineFlag = true; //是否是新笔画
        _this._pointId = 0; //绘制的笔画的轨迹点id
        _this._messageCache = []; //需要处理的消息列表
        _this._strictFlag = true; //严格模式是否检测通过
        _this._fillIndex = 0; //填充模式索引
        /**
         * debug
         */
        _this._debug = false;
        /**
         * 模式
         */
        _this._mode = 0 /* Check */;
        /**
         * 轨迹点,二维数组
         */
        _this._tracePoints = [];
        /**
         * 线宽
         */
        _this._lineWidth = 10;
        /**
         * 颜色
         */
        _this._lineColor = 0xff0000;
        /**
         * 检测精度
         */
        _this._precision = 20;
        _this._posLength = 2;
        _this._lines = new Map();
        _this.clickEvent = new Index_1.ClickEvent(_this, true);
        _this.clickEvent.isOpenLocalPoint = true;
        vf.utils.deprecation("1.0.0", "组件已废弃，请使用插件TracingPlug");
        return _this;
    }
    Object.defineProperty(Tracing.prototype, "debug", {
        get: function () {
            return this._debug;
        },
        set: function (value) {
            this._debug = value;
            if (this._tracePointObjArr.length > 0) {
                var graphic_1 = new vf.Graphics();
                this.container.addChild(graphic_1);
                this._tracePointObjArr.forEach(function (item) {
                    graphic_1.beginFill(0x00ff00);
                    graphic_1.drawCircle(item.point.x, item.point.y, 5);
                    graphic_1.endFill();
                });
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tracing.prototype, "mode", {
        get: function () {
            return this._mode;
        },
        set: function (value) {
            if (this._mode !== value) {
                this._mode = value;
                if (value == 3 /* Strict */ || value == 1 /* Teach */) {
                    this._renderMode = 0;
                    this.removeRenderBgSprite();
                }
                this.clear();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tracing.prototype, "traceSprite", {
        get: function () {
            return this._traceSprite;
        },
        set: function (value) {
            this._traceSprite = value;
            this.setTraceSprite();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tracing.prototype, "renderBgSprite", {
        get: function () {
            return this._renderBgSprite;
        },
        set: function (value) {
            this._renderBgSprite = value;
            if (this.mode !== 3 /* Strict */ && this.mode !== 1 /* Teach */) {
                this._renderMode = 1;
                this.setRenderBgSprite();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tracing.prototype, "tracePoints", {
        get: function () {
            return this._tracePoints;
        },
        set: function (value) {
            var _this = this;
            this._tracePoints = value;
            var pointIndex = 0;
            this._groupStatusArr = [];
            this._tracePoints.forEach(function (group, index) {
                var groupStatus = {
                    flag: false,
                    points: [],
                };
                _this._groupStatusArr.push(groupStatus);
                group.forEach(function (point) {
                    groupStatus.points.push(pointIndex++);
                    _this._tracePointObjArr.push({
                        flag: false,
                        point: new vf.Point(point.x, point.y),
                    });
                });
            });
            if (this.debug) {
                var graphic_2 = new vf.Graphics();
                this.container.addChild(graphic_2);
                this._tracePointObjArr.forEach(function (item) {
                    graphic_2.beginFill(0x00ff00);
                    graphic_2.drawCircle(item.point.x, item.point.y, 5);
                    graphic_2.endFill();
                });
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tracing.prototype, "lineWidth", {
        get: function () {
            return this._lineWidth;
        },
        set: function (value) {
            this._lineWidth = value;
            this.setLineStyle();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tracing.prototype, "lineColor", {
        get: function () {
            return this._lineColor;
        },
        set: function (value) {
            this._lineColor = value;
            this.setLineStyle();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tracing.prototype, "precision", {
        get: function () {
            return this._precision;
        },
        set: function (value) {
            this._precision = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tracing.prototype, "lineTexture", {
        get: function () {
            return this._lineTexture;
        },
        set: function (value) {
            this._lineTexture = value;
            this.setLineStyle();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tracing.prototype, "lineOpacity", {
        get: function () {
            return this._lineOpacity;
        },
        set: function (value) {
            this._lineOpacity = value;
            this.setLineStyle();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 画笔样式
     */
    Tracing.prototype.setLineStyle = function () {
        this._lineStyle = {
            width: this.lineWidth,
            color: this.lineColor,
            texture: this.lineTexture,
            alpha: this.lineOpacity
        };
    };
    /**
     * 轨迹图
     */
    Tracing.prototype.setTraceSprite = function () {
        var _a = this, container = _a.container, traceSprite = _a.traceSprite;
        var texture = Utils_2.getTexture(traceSprite);
        var sprite;
        try {
            sprite = new vf.Sprite(texture);
        }
        catch (e) {
            sprite = vf.Sprite.from(texture);
        }
        if (sprite && sprite.parent == undefined) {
            container.addChild(sprite);
        }
    };
    /**
     * mask背景图
     */
    Tracing.prototype.setRenderBgSprite = function () {
        var _a = this, container = _a.container, renderBgSprite = _a.renderBgSprite;
        var texture = Utils_2.getTexture(renderBgSprite);
        var sprite;
        try {
            sprite = new vf.Sprite(texture);
        }
        catch (e) {
            sprite = vf.Sprite.from(texture);
        }
        if (sprite && sprite.parent == undefined) {
            container.addChild(sprite);
            this._bgSprite = sprite;
        }
        var graphic = this.getGraphics("mask", this._lineStyle);
        this._bgSprite.mask = graphic;
    };
    /**
     * 移出mask背景图
     */
    Tracing.prototype.removeRenderBgSprite = function () {
        if (this._bgSprite) {
            this.container.removeChild(this._bgSprite);
        }
    };
    /**
     * 开始，适用于audo和teach模式
     */
    Tracing.prototype.start = function () {
        var _this = this;
        if (this.mode === 2 /* Auto */) {
            setTimeout(function () {
                _this.auto();
            }, 1000); //自动播放，1s后开始
        }
        else if (this.mode === 1 /* Teach */) {
            //教学模式，需要引导手势
            if (!this._guideSprite) {
                this._guideSprite = vf.Sprite.from(GUIDE_SPRITE);
            }
            setTimeout(function () {
                _this.container.removeChild(_this._guideSprite);
                _this.container.addChild(_this._guideSprite);
                _this.guide();
            }, 1000);
        }
    };
    /**
     * 教学引导
     */
    Tracing.prototype.guide = function () {
        var _this = this;
        var guideSprite = this._guideSprite;
        if (this._pointId >= this.tracePoints[this._lineId].length) {
            this._newLineFlag = true;
            guideSprite.visible = false;
            this._pointId = 0;
            clearTimeout(this._guideTime);
            this._guideTime = setTimeout(function () {
                _this.guide();
            }, 3000);
            return;
        }
        var point = this.tracePoints[this._lineId][this._pointId++];
        if (this._newLineFlag) {
            guideSprite.visible = true;
            this._newLineFlag = false;
            this._lastLocalPos.set(point.x, point.y);
            point = this.tracePoints[this._lineId][this._pointId++];
        }
        this._curLocalPos.set(point.x, point.y);
        this.playGuideAnimal();
    };
    Tracing.prototype.playGuideAnimal = function () {
        var _this = this;
        var distance = Utils_1.pointDistance(this._lastLocalPos, this._curLocalPos);
        var startPos = this._lastLocalPos.clone();
        var endPos = this._curLocalPos.clone();
        var curPos = this._curLocalPos.clone();
        this._lastLocalPos.copyFrom(this._curLocalPos);
        var from = { dt: 0 };
        var to = { dt: distance };
        this._tween = new Tween_1.Tween(from)
            .to(to, 500)
            .on(Tween_1.Tween.Event.update, function (obj) {
            var dt = Math.ceil(obj.dt);
            var x = (dt * (endPos.x - startPos.x)) / distance + startPos.x;
            var y = (dt * (endPos.y - startPos.y)) / distance + startPos.y;
            curPos.set(x, y);
            _this._guideSprite.x = x;
            _this._guideSprite.y = y;
        })
            .once(Tween_1.Tween.Event.complete, function (obj) {
            if (_this._tween) {
                _this._tween.removeAllListeners();
                _this._tween.release();
            }
            _this.guide();
        })
            .start();
    };
    /**
     * 清除教学引导
     */
    Tracing.prototype.clearGuide = function () {
        clearTimeout(this._guideTime);
        var guideSprite = this._guideSprite;
        if (guideSprite) {
            guideSprite.visible = false;
        }
        this._newLineFlag = true;
        this._pointId = 0;
        this._tween && this._tween.release();
    };
    /**
     * 自动绘制
     */
    Tracing.prototype.auto = function () {
        var point = this.autoNextPoint();
        if (this._newLineFlag) {
            this._newLineFlag = false;
            this._lastLocalPos.set(point.x, point.y);
            this._posCache = [];
            this._posCache.push(this._lastLocalPos.clone());
            point = this.autoNextPoint();
        }
        this._curLocalPos.set(point.x, point.y);
        if (this._autoComplete) {
            this.emit(Index_1.ComponentEvent.COMPLETE, this, { mode: this.mode, value: 3 /* Complete */ });
            return;
        }
        this.drawWithAnimation();
    };
    Tracing.prototype.drawWithAnimation = function () {
        var _this = this;
        var distance = Utils_1.pointDistance(this._lastLocalPos, this._curLocalPos);
        var startPos = this._lastLocalPos.clone();
        var endPos = this._curLocalPos.clone();
        var curPos = this._curLocalPos.clone();
        this._lastLocalPos.copyFrom(this._curLocalPos);
        var from = { dt: 0 };
        var to = { dt: distance };
        this._tween = new Tween_1.Tween(from)
            .to(to, 500)
            .on(Tween_1.Tween.Event.update, function (obj) {
            var dt = Math.ceil(obj.dt);
            var x = (dt * (endPos.x - startPos.x)) / distance + startPos.x;
            var y = (dt * (endPos.y - startPos.y)) / distance + startPos.y;
            curPos.set(x, y);
            _this._posCache.push(curPos.clone());
            var graphics = _this.getGraphics(_this._lineId.toString(), _this._lineStyle);
            _this.localDraw(graphics);
        })
            .once(Tween_1.Tween.Event.complete, function (obj) {
            _this._tween.removeAllListeners();
            _this._tween.release();
            var length = _this._posCache.length;
            if (length > _this._posLength) {
                _this._posCache = _this._posCache.slice(length - _this._posLength, length - 1); //容错处理   没有全部清掉 因为最后节点可能没有画完
            }
            _this.auto();
        })
            .start();
    };
    Tracing.prototype.autoNextPoint = function () {
        if (this._pointId >= this.tracePoints[this._lineId].length) {
            this._newLineFlag = true;
            this._lineId++;
            this._pointId = 0;
            if (this._lineId >= this.tracePoints.length) {
                //绘制全部完成
                this._autoComplete = true;
                this._pointId = 0;
                this._lineId = 0;
                return { x: 0, y: 0 };
            }
        }
        var point = this.tracePoints[this._lineId][this._pointId];
        this._pointId++;
        return point;
    };
    /**
     * 更新显示列表,子类重写，实现布局
     */
    Tracing.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
        this.container.hitArea = new vf.Rectangle(0, 0, this.width, this.height);
    };
    Tracing.prototype.$onInit = function () {
        //由于绑定的可能非当前显示对象，所以此处不可以使用this.on("xxxx")
        this.clickEvent.getTarget().on(Index_1.TouchMouseEvent.onPress, this.onPress, this);
        this.clickEvent.getTarget().on(Index_1.TouchMouseEvent.onMove, this.onMove, this);
        this.setLineStyle();
    };
    Tracing.prototype.$onRelease = function () {
        this.clickEvent.getTarget().off(Index_1.TouchMouseEvent.onPress, this.onPress, this);
        this.clickEvent.getTarget().off(Index_1.TouchMouseEvent.onMove, this.onMove, this);
        this.clickEvent.remove();
    };
    /**
     * 检测触摸点和轨迹点
     * @param point
     */
    Tracing.prototype.checkTrace = function (point) {
        var _this = this;
        if (this.tracePoints.length == 0) {
            this._result = 1 /* Correct */;
            return;
        }
        this._curIndex = -1;
        for (var i = 0; i < this._tracePointObjArr.length; ++i) {
            if (!this._tracePointObjArr[i].flag &&
                Utils_1.pointDistance(point, this._tracePointObjArr[i].point) < this.precision) {
                this._tracePointObjArr[i].flag = true;
                this._curIndex = i;
                break;
            }
        }
        if (this._curIndex === -1)
            return;
        if (this._realTraceIndexArr.length === 0 && this._curIndex === 0) {
            this._realTraceIndexArr.push(this._curIndex);
            return;
        }
        if (this._curIndex === this._realTraceIndexArr[this._realTraceIndexArr.length - 1] + 1) {
            this._realTraceIndexArr.push(this._curIndex);
            this._tempTraceIndexArr.forEach(function (item) {
                _this._tracePointObjArr[item].flag = false;
            });
            this._tempTraceIndexArr = [];
        }
        else {
            this._tempTraceIndexArr.push(this._curIndex);
            if (this._tempTraceIndexArr.length > 3) {
                //暂存区超过4个，不再容错了
                this._realTraceIndexArr = this._realTraceIndexArr.concat(this._tempTraceIndexArr);
                this._tempTraceIndexArr = [];
            }
            else {
                //
            }
        }
        if (this.debug) {
            console.log("实际轨迹：", this._realTraceIndexArr, "暂存区：", this._tempTraceIndexArr, "result:", this._result);
        }
    };
    /**
     * 检查暂存区,抬起时检测暂存区中的点是否在一个笔画上
     */
    Tracing.prototype.checkTemp = function () {
        var _this = this;
        if (this._tempTraceIndexArr.length < 2)
            return;
        //检查temp中的点是否在一个笔画上,如果是，则认为这是一次有效画线而非误触,否则就算误触,退回到待触发数组
        var groupIndexArr = [];
        this._tempTraceIndexArr.forEach(function (element) {
            _this._groupStatusArr.forEach(function (item, index) {
                if (item.points.indexOf(element) !== -1) {
                    groupIndexArr.push(index);
                }
            });
        });
        if (new Set(groupIndexArr).size === 1) {
            this._realTraceIndexArr = this._realTraceIndexArr.concat(this._tempTraceIndexArr);
            this._tempTraceIndexArr = [];
        }
        else {
            this._tempTraceIndexArr.forEach(function (item) {
                _this._tracePointObjArr[item].flag = false;
            });
            this._tempTraceIndexArr = [];
        }
    };
    /**
     * 检查group
     */
    // private checkGroup() {}
    Tracing.prototype.checkResult = function () {
        var _this = this;
        if (this._realTraceIndexArr.length === 0)
            return;
        if (this._realTraceIndexArr.length + this._tempTraceIndexArr.length == this._tracePointObjArr.length) {
            //结束了
            this._realTraceIndexArr = this._realTraceIndexArr.concat(this._tempTraceIndexArr);
            this._tempTraceIndexArr = [];
            this._result = 1 /* Correct */;
            var preIndex_1 = -1;
            this._realTraceIndexArr.forEach(function (item) {
                if (item > preIndex_1) {
                    preIndex_1 = item;
                }
                else {
                    _this._result = 2 /* Incorrect */;
                }
            });
            this.emit(Index_1.ComponentEvent.COMPLETE, this, { mode: this.mode, value: this._result });
        }
        else {
            this._result = 0 /* Uncomplete */;
            if (this._realTraceIndexArr[0] != 0) {
                this._result = 2 /* Incorrect */;
            }
            else {
                var preIndex_2 = -1;
                this._realTraceIndexArr.forEach(function (item) {
                    if (item < preIndex_2) {
                        _this._result = 2 /* Incorrect */;
                    }
                    else {
                        preIndex_2 = item;
                    }
                });
            }
            if (this._result != 0 /* Uncomplete */) {
                this.emit(Index_1.ComponentEvent.COMPLETE, this, { mode: this.mode, value: this._result });
            }
        }
    };
    Tracing.prototype.checkStrictFirstPoint = function (point) {
        //检测下笔处是否当前笔画的初始点位置
        var index = this._groupStatusArr[this._lineId].points[0];
        if (Utils_1.pointDistance(point, this._tracePointObjArr[index].point) <= this.precision) {
            return true;
        }
        return false;
    };
    Tracing.prototype.checkStrict = function () {
        var _this = this;
        var flag = true;
        if (this._lineId != 1) {
            this._realTraceIndexArr.shift();
        }
        if (this._realTraceIndexArr.length != this._groupStatusArr[this._lineId - 1].points.length) {
            flag = false;
        }
        else {
            for (var i = 0; i < this._groupStatusArr[this._lineId - 1].points.length; ++i) {
                if (this._realTraceIndexArr[i] != this._groupStatusArr[this._lineId - 1].points[i]) {
                    flag = false;
                    break;
                }
            }
        }
        if (!flag) {
            this._lineId--;
            this._realTraceIndexArr.forEach(function (item) {
                _this._tracePointObjArr[item].flag = false;
            });
            //书写失败，清除当前线条
            this.removeLine(this._lineId.toString());
            // setTimeout(() => {
            //     this.emitTracingMsg(
            //         TracingEnum.Operate.Remove,
            //         this._lineId.toString(),
            //         this.getDataStrByPosCache(),
            //         this._lineStyle,
            //         this._realTraceIndexArr,
            //         this._tempTraceIndexArr,
            //         this._result
            //     );
            // }, 300);
        }
        if (this._lineId < this._groupStatusArr.length) {
            this._realTraceIndexArr = [];
            if (this._lineId != 0) {
                var firstIndex = this._groupStatusArr[this._lineId].points[0] - 1;
                this._realTraceIndexArr.push(firstIndex);
            }
        }
        else {
            //书写完成
            this.emit(Index_1.ComponentEvent.COMPLETE, this, { mode: this.mode, value: 3 /* Complete */ });
        }
        return flag;
    };
    Tracing.prototype.checkFill = function (curPoint, signalling) {
        if (signalling === void 0) { signalling = false; }
        if (this._fillIndex >= this._tracePointObjArr.length)
            return;
        var point = this._tracePointObjArr[this._fillIndex].point;
        if (Utils_1.pointDistance(curPoint, point) <= this.precision) {
            if (!signalling) {
                var obj = { mode: this.mode, fillIndex: this._fillIndex, lineIndex: this._lineId, pointIndex: this._pointId, complete: false };
                this.emit(Index_1.ComponentEvent.CHANGE, this, JSON.stringify(obj));
            }
            this._fillIndex++;
            if (this._fillIndex >= this._tracePointObjArr.length) {
                this.emit(Index_1.ComponentEvent.COMPLETE, this, { mode: this.mode, complete: true });
            }
            else {
                this.emit(Index_1.ComponentEvent.COMPLETE, this, { mode: this.mode, complete: false, fillIndex: this._fillIndex - 1, lineIndex: this._lineId, pointIndex: this._pointId });
            }
            //触碰正确
            this._posCache.push(point);
            var graphics = this.getGraphics(this._lineId.toString(), this._lineStyle);
            this.localDraw(graphics);
            if (this._pointId >= this._groupStatusArr[this._lineId].points.length - 1) {
                //画完了一笔
                this._pointId = 0;
                this._lineId++;
                this._posCache = [];
            }
            else {
                this._pointId++;
            }
        }
    };
    /**
     * 教学模式检查
     */
    Tracing.prototype.checkTeach = function () {
        var _this = this;
        var flag = true;
        if (this._lineId != 1) {
            this._realTraceIndexArr.shift();
        }
        if (this._realTraceIndexArr.length != this._groupStatusArr[this._lineId - 1].points.length) {
            flag = false;
        }
        else {
            for (var i = 0; i < this._groupStatusArr[this._lineId - 1].points.length; ++i) {
                if (this._realTraceIndexArr[i] != this._groupStatusArr[this._lineId - 1].points[i]) {
                    flag = false;
                    break;
                }
            }
        }
        if (!flag) {
            this._lineId--;
            this._realTraceIndexArr.forEach(function (item) {
                _this._tracePointObjArr[item].flag = false;
            });
            //书写失败，清除当前线条
            this.removeLine(this._lineId.toString());
            // setTimeout(() => {
            //     this.emitTracingMsg(
            //         TracingEnum.Operate.Remove,
            //         this._lineId.toString(),
            //         this.getDataStrByPosCache(),
            //         this._lineStyle,
            //         this._realTraceIndexArr,
            //         this._tempTraceIndexArr,
            //         this._result
            //     );
            // }, 300);
        }
        if (this._lineId < this._groupStatusArr.length) {
            this._realTraceIndexArr = [];
            if (this._lineId != 0) {
                var firstIndex = this._groupStatusArr[this._lineId].points[0] - 1;
                this._realTraceIndexArr.push(firstIndex);
            }
            this.guide();
        }
        else {
            //教学完成
            this.emit(Index_1.ComponentEvent.COMPLETE, this, { mode: this.mode, value: 3 /* Complete */ });
        }
        return flag;
    };
    /**
     * 画线
     * @param lineId
     * @param data
     * @param from
     * @param to
     * @param lineStyle
     */
    Tracing.prototype.drawLine = function (lineId, data, from, to, lineStyle) {
        console.log("drawLine----", lineId);
        var graphics = this.getGraphics(lineId, lineStyle);
        var posList = getVecListFromStr(data, from, to);
        this.draw(graphics, posList);
    };
    /**
     * 绘图
     * @param graphics
     * @param posList
     */
    Tracing.prototype.draw = function (graphics, posList) {
        var lastX = posList[0] - POSITIVE;
        var lastY = posList[1] - POSITIVE;
        graphics.moveTo(lastX, lastY);
        // 利用贝塞尔将线平滑化
        var realList = [];
        for (var index = 2; index < posList.length; index += 2) {
            var x = posList[index] - POSITIVE;
            var y = posList[index + 1] - POSITIVE;
            var halfX = lastX + (x - lastX) * 0.5;
            var halfY = lastY + (y - lastY) * 0.5;
            realList.push(halfX, halfY, x, y);
            lastX = x;
            lastY = y;
        }
        graphics.lineTo(realList[0], realList[1]);
        for (var index = 2; index < realList.length - 2; index += 4) {
            var cx = realList[index];
            var cy = realList[index + 1];
            var x = realList[index + 2];
            var y = realList[index + 3];
            graphics.quadraticCurveTo(cx, cy, x, y);
        }
        graphics.lineTo(realList[realList.length - 2], realList[realList.length - 1]);
    };
    /**
     * 本地绘制
     * @param graphics
     */
    Tracing.prototype.localDraw = function (graphics) {
        //修改：仅拿最后的3个点绘制
        var posCache = this._posCache;
        var length = posCache.length;
        if (length < 2)
            return;
        graphics.moveTo(posCache[length - 2].x, posCache[length - 2].y);
        graphics.lineTo(posCache[length - 1].x, posCache[length - 1].y);
    };
    Tracing.prototype.onPress = function (e, thisObj, isPress) {
        e.stopPropagation();
        if (this.mode === 2 /* Auto */) {
            //自动播放，不可操作
            return;
        }
        var curLocal = this.container.toLocal(e.local, thisObj.container);
        if (isPress) {
            if (this.mode === 3 /* Strict */) {
                var result = this.checkStrictFirstPoint(curLocal);
                if (!result) {
                    this._strictFlag = false;
                    return;
                }
                this._strictFlag = true;
            }
            else if (this.mode === 1 /* Teach */) {
                this.clearGuide();
            }
            else if (this.mode === 4 /* Fill */) {
                this._drawing = true;
                return;
            }
            this._drawing = true;
            this._lastLocalPos.copyFrom(curLocal);
            this._posCache = [this._lastLocalPos.clone()];
            this.checkTrace(this._lastLocalPos);
        }
        else {
            if (this.mode === 4 /* Fill */) {
                // ++this._lineId;
                // this._posCache = [];
                this._drawing = false;
                return;
            }
            if (this.mode === 3 /* Strict */ && !this._strictFlag) {
                return;
            }
            if (this._posCache.length === 1) {
                //仅有一个点
                var newPoint = this._lastLocalPos.clone(); //在附近新建一个点，保证第一个触点也能画出来
                newPoint.set(newPoint.x, newPoint.y - POS_DISTANCE);
                this._posCache.push(newPoint);
                var graphics = this.getGraphics(this._lineId.toString(), this._lineStyle);
                this.localDraw(graphics);
            }
            this._drawing = false;
            this.checkTemp();
            if (this.mode === 0 /* Check */) {
                this.checkResult();
            }
            this.emitTracingMsg(0 /* Add */, this._lineId.toString(), this.getDataStrByPosCache(), this._lineStyle, this._realTraceIndexArr, this._tempTraceIndexArr, this._result);
            ++this._lineId;
            if (this.mode === 1 /* Teach */) {
                this.checkTeach();
            }
            else if (this.mode === 3 /* Strict */) {
                this.checkStrict();
            }
        }
    };
    Tracing.prototype.onMove = function (e, thisObj) {
        e.stopPropagation();
        if (this.mode === 4 /* Fill */ && this._drawing) {
            var curLocal = this.container.toLocal(e.local, thisObj.container);
            this.checkFill(curLocal);
            return;
        }
        if (this.mode == 2 /* Auto */) {
            //自动播放，不可操作
            return;
        }
        if (this._drawing) {
            var curLocal = this.container.toLocal(e.local, thisObj.container);
            if (Utils_1.pointDistance(curLocal, this._lastLocalPos) >= POS_DISTANCE) {
                this._lastLocalPos.copyFrom(curLocal);
                this._posCache.push(this._lastLocalPos.clone());
                var graphics = this.getGraphics(this._lineId.toString(), this._lineStyle);
                this.localDraw(graphics);
                this.checkTrace(this._lastLocalPos);
            }
        }
    };
    /**
     *
     * @param lineId
     * @param lineStyle
     */
    Tracing.prototype.getGraphics = function (lineId, lineStyle) {
        if (lineStyle === void 0) { lineStyle = {}; }
        if (this._renderMode === 1) {
            lineId = "mask";
        }
        var key = "line_" + lineId;
        if (this._lines.has(key)) {
            return this._lines.get(key);
        }
        var graphics = new vf.Graphics();
        graphics.interactive = false;
        graphics.interactiveChildren = false;
        graphics.name = key;
        this.container.addChild(graphics);
        this._lines.set(key, graphics);
        lineStyle = Utils_1.deepCopy(lineStyle);
        lineStyle.color = lineStyle.texture ? 0xffffff : lineStyle.color;
        lineStyle.texture = lineStyle.texture ? Utils_2.getTexture(this.lineTexture) : vf.Texture.WHITE;
        lineStyle.alpha = lineStyle.alpha ? lineStyle.alpha : 1;
        lineStyle.cap = "round";
        lineStyle.join = "round";
        if (this._renderMode === 0) {
            graphics.lineTextureStyle(lineStyle);
        }
        else {
            graphics.lineTextureStyle({
                width: lineStyle.width,
                color: 0xff0000,
            });
        }
        return graphics;
    };
    Tracing.prototype.getDataStrByPosCache = function () {
        var _posCache = this._posCache;
        if (_posCache.length == 0) {
            return "";
        }
        // 稀疏位置点，通过曲率
        var finalX = [_posCache[0].x];
        var finalY = [_posCache[0].y];
        var lastLastPos = _posCache[0];
        var lastPos = _posCache[1];
        var sumAngle = 0;
        for (var index = 2; index < _posCache.length; index++) {
            var pos = _posCache[index];
            var pos1 = Utils_1.pointSub(lastPos, lastLastPos);
            var pos2 = Utils_1.pointSub(pos, lastPos);
            var angle = Utils_1.pointSignAngle(pos1, pos2);
            if (angle > MAX_ARC || angle < -MAX_ARC || sumAngle > MAX_ARC || sumAngle < -MAX_ARC) {
                finalX.push(lastPos.x);
                finalY.push(lastPos.y);
                sumAngle = 0;
            }
            else {
                sumAngle += angle;
            }
            lastLastPos = lastPos;
            lastPos = pos;
        }
        finalX.push(_posCache[_posCache.length - 1].x);
        finalY.push(_posCache[_posCache.length - 1].y);
        var finalStrList = [];
        for (var index = 0; index < finalX.length; index++) {
            var x = finalX[index] + POSITIVE;
            var y = finalY[index] + POSITIVE;
            var str = getStrFromPos(x, y);
            finalStrList.push(str);
        }
        var finalStr = finalStrList.join("");
        return finalStr;
    };
    /**
     * 发送一个笔画的msg
     * @param lineId
     * @param data
     */
    Tracing.prototype.emitTracingMsg = function (operate, lineId, data, lineStyle, realTraceIndexArr, tempTraceIndexArr, result) {
        if (operate === void 0) { operate = 0 /* Add */; }
        if (lineId === void 0) { lineId = ""; }
        if (data === void 0) { data = ""; }
        if (lineStyle === void 0) { lineStyle = {}; }
        if (realTraceIndexArr === void 0) { realTraceIndexArr = []; }
        if (tempTraceIndexArr === void 0) { tempTraceIndexArr = []; }
        if (result === void 0) { result = 0; }
        var obj = {
            operate: operate,
            lineId: lineId,
            data: data,
            lineStyle: lineStyle,
            realTraceIndexArr: realTraceIndexArr,
            tempTraceIndexArr: tempTraceIndexArr,
            result: result,
        };
        this.emit(Index_1.ComponentEvent.CHANGE, this, JSON.stringify(obj));
    };
    Tracing.prototype.onMessage = function () {
        var _messageCache = this._messageCache;
        if (_messageCache.length > 0) {
            while (_messageCache.length > 0) {
                var message = _messageCache.shift();
                if (this.mode == 4 /* Fill */) {
                    //填充模式特殊处理
                    var fillIndex = JSON.parse(message).fillIndex;
                    if (fillIndex < this._tracePointObjArr.length) {
                        var point = this._tracePointObjArr[fillIndex].point;
                        this.checkFill(point, true);
                    }
                    continue;
                }
                var _a = JSON.parse(message), operate = _a.operate, lineId = _a.lineId, data = _a.data, lineStyle = _a.lineStyle, realTraceIndexArr = _a.realTraceIndexArr, tempTraceIndexArr = _a.tempTraceIndexArr, result = _a.result;
                this._realTraceIndexArr = realTraceIndexArr;
                this._tempTraceIndexArr = tempTraceIndexArr;
                this._lineId = parseInt(lineId);
                this._result = result;
                ++this._lineId;
                if (this.mode == 1 /* Teach */) {
                    this.clearGuide();
                    this.checkTeach();
                }
                else if (this.mode == 3 /* Strict */) {
                    this.checkStrict();
                }
                else if (this._result != 0 /* Uncomplete */) {
                    //临摹完成，返回结果
                    this.emit(Index_1.ComponentEvent.COMPLETE, this, { mode: this.mode, value: this._result });
                }
                switch (operate) {
                    case 0 /* Add */:
                        this.drawLine(lineId, data, 0, data.length, lineStyle);
                        break;
                    case 1 /* Clear */:
                        this.clear();
                        break;
                    case 2 /* Remove */:
                        this.removeLine(lineId);
                        break;
                }
            }
        }
    };
    Tracing.prototype.removeLine = function (lineId) {
        console.log("removeLine----", lineId);
        var graphics = this.getGraphics(lineId);
        if (graphics.parent) {
            graphics.parent.removeChild(graphics);
            graphics.destroy();
            var key = "line_" + lineId;
            this._lines.delete(key);
        }
    };
    /**
     * clear
     */
    Tracing.prototype.clear = function () {
        this._lines.forEach(function (value, key) {
            if (value.parent) {
                value.parent.removeChild(value);
                value.destroy();
            }
        });
        this._lines.clear();
        if (this._renderMode == 1) {
            var graphic = this.getGraphics("mask", this._lineStyle);
            this._bgSprite.mask = graphic;
        }
        this._fillIndex = 0;
        this._lineId = 0;
        this._pointId = 0;
        this._realTraceIndexArr = [];
        this._tempTraceIndexArr = [];
        this._posCache = [];
        this._autoComplete = false;
        this._newLineFlag = true;
        this._result = 0 /* Uncomplete */;
        this._tracePointObjArr.forEach(function (item) {
            item.flag = false;
        });
        if (this._tween) {
            this._tween.release();
        }
        this.clearGuide();
        this.start();
    };
    /**
     * @private
     * 提交属性，子类在调用完invalidateProperties()方法后，应覆盖此方法以应用属性
     */
    Tracing.prototype.commitProperties = function () {
        this.onMessage();
    };
    Tracing.prototype.setData = function (data) {
        if (typeof data === "string") {
            this._messageCache.push(data);
        }
        else {
            this._messageCache = this._messageCache.concat(data);
        }
        this.invalidateProperties();
    };
    Object.defineProperty(Tracing.prototype, "source", {
        set: function (data) {
            this.setData(data);
        },
        enumerable: false,
        configurable: true
    });
    return Tracing;
}(DisplayObject_1.DisplayObject));
exports.Tracing = Tracing;


/***/ }),

/***/ "./src/display/Video.ts":
/*!******************************!*\
  !*** ./src/display/Video.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Video = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var VideoBtn_1 = __webpack_require__(/*! ./VideoBtn */ "./src/display/VideoBtn.ts");
/**
 * 播放器组件
 *
 */
var Video = /** @class */ (function (_super) {
    __extends(Video, _super);
    function Video() {
        var _this = _super.call(this) || this;
        _this._videoHasEvent = false;
        _this._resolution = 1;
        // 内部属性 ~~~~~~~~~~
        _this._autoplay = false;
        _this._canPlayFirst = false; // canplay 事件在某些设备 设置currenttime 等也会触发  所以需要用这个属性过滤事件
        _this._poster = ""; // 海报url
        _this._firstLoad = false; //首次加载
        _this._muted = false;
        _this._loop = false;
        _this._controls = true;
        _this._volume = 1;
        _this._currentTime = 0;
        _this._oldPoster = "";
        _this._oldSrc = "";
        _this._canPlay = false;
        _this._visibleStatus = true; // 视频显示 or 隐藏
        _this._elemDraw = false; //渲染模式 是否标签渲染  默认纹理
        _this._isplaying = false; //当前播放状态  play or pause
        _this.forceElementDraw = false; // 强制标签渲染
        _this._lastPostion = new vf.Rectangle();
        _this._oldX = 0;
        _this._oldY = 0;
        _this._fullStates = "noFull";
        _this._sprite = new vf.Sprite();
        _this.container.addChildAt(_this._sprite, 0); // 这里添加  便于有些需要获取dom渲染位置
        _this.videoGroup = "";
        _this._video = document.createElement('video');
        vf.utils.deprecation("1.0.0", "在互动课件环境，Video组件仅支持最基础的播放、暂停功能。并且需要配置无声视频源：silentSrc以及对应的声音源：soundSrc");
        return _this;
    }
    Video.prototype.createVideoBtn = function () {
        if (!this._videoBtn) {
            this._videoBtn = new VideoBtn_1.VideoBtn();
            this._videoBtn.width = 50;
            this._videoBtn.height = 50;
            this._videoBtn.interactabled = true;
            this._videoBtn.on(vf.gui.Interaction.TouchMouseEvent.onClick, this.clickAudio, this);
            this.addChild(this._videoBtn);
            this._videoBtn.visible = this._controls;
        }
    };
    Video.prototype.clickAudio = function (e, thisObj) {
        if (this._isplaying === true) {
            this.pause();
        }
        else {
            this.play();
        }
    };
    /**
     *  目前 设置src才会添加sprite到舞台
     *  创建sprite需要根据src获取纹理
     */
    Video.prototype.createVideoSource = function () {
        var _a;
        if (this.useNativeAudio()) {
            return;
        }
        if (!this._sprite) {
            this._sprite = new vf.Sprite();
            this.container.addChildAt(this._sprite, 0);
        }
        if (!this._video) {
            this._video = document.createElement('video');
        }
        // 如果是mediaSteam  需要赋值给srcObject
        var video = this._video;
        if (window["MediaStream"] && this._src instanceof MediaStream) {
            video.srcObject = this._src || "";
            this._autoplay = true;
        }
        else {
            video.src = this._src || "";
        }
        video.setAttribute('preload', 'auto'); // 打开的话 标签的海报就不能生效
        video.setAttribute('webkit-playsinline', '');
        video.setAttribute('playsinline', '');
        video.setAttribute('x5-video-player-type', 'h5');
        video.setAttribute('x5-video-player-fullscreen', "true");
        video.setAttribute('playsinline', "true");
        video.crossOrigin = "anonymous";
        this._videoTextrue = vf.Texture.from(video, { resourceOptions: { autoPlay: this._autoplay, autoLoad: true, crossorigin: true } });
        var v = this._videoTextrue;
        this._video.onseeked = function () {
            if (v.baseTexture && v.baseTexture.resource) {
                v.update();
            }
        };
        this._sprite.texture = this._videoTextrue;
        video.muted = this._muted;
        video.loop = this._loop;
        video.currentTime = this._currentTime;
        video.volume = this._volume;
        video.autoplay = this._autoplay;
        video.controls = this._controls;
        var url = this._poster;
        if (this._poster && this._poster !== "") {
            var o = Utils_1.getSource(this._poster);
            if (typeof (o) === "object") {
                if (o.baseTexture && o.baseTexture.resource && o.baseTexture.resource.url) {
                    url = o.baseTexture.resource.url;
                }
            }
        }
        video.poster = url;
        if (this._autoplay && this.useNativeAudio()) {
            if (((_a = this.stage) === null || _a === void 0 ? void 0 : _a.syncManager) && this.stage.syncManager.resumeStatusFlag) {
                return;
            }
            this.nativeEmit(this._audio, 'playAudio');
        }
        /**
        * 需要上报的事件
        */
        this.clearVideoEvent();
        if (!this._videoHasEvent) { //当前没有添加事件监听
            this._videoHasEvent = true;
            this._canplayFun = this.canplayFun.bind(this);
            this._canplaythroughFun = this.canplaythroughFun.bind(this);
            this._completeFun = this.completeFun.bind(this);
            this._endedFun = this.endedFun.bind(this);
            this._loadeddataFun = this.loadeddataFun.bind(this);
            this._durationchangeFun = this.durationchangeFun.bind(this);
            this._pauseFun = this.pauseFun.bind(this);
            this._playFun = this.playFun.bind(this);
            //浏览器可以播放媒体文件了，但估计没有足够的数据来支撑播放到结束，不需要停止缓存更多的内容
            video.addEventListener('canplay', this._canplayFun);
            //浏览器估算可以播放到结束，不需要停止缓存更多的内容。
            video.addEventListener('canplaythrough', this._canplaythroughFun);
            //渲染完成
            video.addEventListener('complete', this._completeFun);
            //播放
            video.addEventListener('play', this._playFun);
            //暂停
            video.addEventListener('pause', this._pauseFun);
            //视频已经到达结束点
            video.addEventListener('ended', this._endedFun);
            //首帧已经加载
            video.addEventListener('loadeddata', this._loadeddataFun);
            //duration 属性的值改变时触发
            video.addEventListener('durationchange', this._durationchangeFun);
        }
    };
    Video.prototype.canplayFun = function (e) {
        if (this._canPlayFirst === false) { // 某些设备 设置currentTime 也会触发canplay 这里统一video只抛出一次  后面看情况优化
            this._canPlayFirst = true;
            this.emit('canplay', e, this);
        }
    };
    Video.prototype.canplaythroughFun = function (e) {
        this.emit('canplaythrough', e, this);
    };
    Video.prototype.completeFun = function (e) {
        this.emit('complete', e, this);
    };
    Video.prototype.pauseFun = function (e) {
        (this._videoBtn && this._videoBtn.setStates("pause"));
        this._isplaying = false;
        this.emit("paused", e, this);
    };
    Video.prototype.playFun = function (e) {
        (this._videoBtn && this._videoBtn.setStates("play"));
        this._isplaying = true;
        Index_1.VideoGroupController.updateVideoGroupStates(this);
        this.emit("play", e, this);
    };
    Video.prototype.endedFun = function (e) {
        this._isplaying = false;
        this.emit('ended', e, this);
    };
    Video.prototype.loadeddataFun = function (e) {
        var video = this._video;
        //这里判断当前版本支持问题
        if (this._canPlay == false && (video.videoWidth <= 0) || this.checkComatibility() === true) {
            this._canPlay = true;
            this._elemDraw = true;
            console.log("视频不支持纹理");
            this.clearSprite();
            if (!video.parentElement && this.stage && this.stage.app) {
                var canvas = this.stage.app.view;
                if (canvas && canvas.parentElement) {
                    canvas.parentElement.appendChild(this._video);
                    //调整标签位置
                    this.setPos();
                    //刷新宽高
                    this.invalidateDisplayList();
                }
            }
        }
        else {
            this._posterImg && (this._posterImg.visible = true);
            this.createVideoBtn();
        }
        this._firstLoad = true;
        if (this._fullStates == "fulling") {
            this.fullScreen();
        }
        this.emit('loadeddata', e, this);
    };
    // 内核版本白名单
    Video.prototype.checkComatibility = function () {
        if (this.forceElementDraw === true) {
            return true;
        }
        var agent = navigator.userAgent;
        if (agent) {
            if (agent.indexOf("HUAWEICMR-W09") > -1) {
                return true;
            }
            var info = vf.utils.getSystemInfo();
            var bowser = info.browser;
            var name_1 = bowser.name;
            var version = bowser.version;
            var type = info.device.type;
            var sing = Number.MAX_VALUE.toString();
            if (name_1.toLocaleLowerCase() === "chrome") {
                sing = version.split(".")[0];
            }
            // alert("bowser :" + version + "000000" + type);
            if (Number(sing) <= 62 && (type === "tablet" || type === "mobile")) {
                //安卓 chrome版本小于62 暂用标签
                return true;
            }
        }
        return false;
    };
    Video.prototype.durationchangeFun = function (e) {
        this.emit('durationchange', e, this);
    };
    Video.prototype.checkVideoPlay = function () {
        var video = this._video;
        this.updateSystem();
        if (this._sprite) {
            if (this._sprite.texture) {
                this._sprite.texture.destroy();
            }
            this._sprite.destroy();
        }
        this._sprite = undefined;
        video.width = this.width;
        video.height = this.height;
        video.style.position = "absolute";
        //对位置
        this.setPos();
    };
    Object.defineProperty(Video.prototype, "x", {
        get: function () {
            return this.container.x;
        },
        set: function (value) {
            this.container.position.x = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "y", {
        get: function () {
            return this.container.y;
        },
        set: function (value) {
            this.container.position.y = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Video.prototype.setPos = function () {
        this._canvasBounds = this._getCanvasBounds();
        var cb = this._canvasBounds;
        this.stage && this.container.updateTransform();
        var m = this.container.worldTransform.clone();
        var transform = 'matrix(' + [m.a, m.b, m.c, m.d, 0, 0].join(',') + ')';
        if (cb) {
            var vleft = cb.left + m.tx + this.width * (m.a - 1) * 0.5;
            var vtop = cb.top + m.ty + this.height * (m.d - 1) * 0.5;
            this.updatePostion(vtop, vleft, transform, this.container.worldAlpha);
        }
    };
    Video.prototype._getCanvasBounds = function () {
        if (this._lastRenderer) {
            var rect = this._lastRenderer.view.getBoundingClientRect();
            var bounds = { top: rect.top, left: rect.left, width: rect.width, height: rect.height };
            bounds.left += window.scrollX;
            bounds.top += window.scrollY;
            return bounds;
        }
        return undefined;
    };
    Video.prototype.updateSystem = function () {
        if (this.stage) {
            var renderer = this.stage.app.renderer;
            this._resolution = renderer.resolution;
            this._lastRenderer = renderer;
        }
    };
    Video.prototype.updatePostion = function (top, left, transform, opacity) {
        this._video.style.top = Number(top) + 'px';
        this._video.style.left = Number(left) + 'px';
        this._video.style.transform = transform;
        if (opacity)
            this._video.style.opacity = opacity.toString();
    };
    Video.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
        var lastPostion = this._lastPostion;
        if (lastPostion.x !== this.x || lastPostion.y !== this.y ||
            lastPostion.width !== this.width || lastPostion.height !== this.height) {
            this._lastPostion.x = this.x;
            this._lastPostion.y = this.y;
            this._lastPostion.width = this.width;
            this._lastPostion.height = this.height;
            this.validateDisplayList();
            // if (this.useNativeAudio()) {
            //   this.nativeEmit(this.src, 'position')
            // }
        }
        if (this.useNativeAudio()) {
            if (this._silent) {
                this._src = this._silent;
            }
            else {
                console.warn('课件环境需要配置silent参数！');
                return;
            }
        }
        if (unscaledWidth === 0 && unscaledHeight === 0) {
            return;
        }
        if (!this._src || this._src === undefined || this._src === "" || this._src != this._oldSrc) {
            this._oldSrc = this._src;
            this.clearSource();
            if (this._src && this._src != "") {
                this.createVideoSource();
            }
        }
        if (this._canPlay) {
            this.checkVideoPlay();
        }
        if (this._sprite && this._fullStates === "noFull") {
            this._sprite.width = unscaledWidth;
            this._sprite.height = unscaledHeight;
        }
        this.updataPoster();
    };
    Video.prototype.updataPoster = function () {
        if (this._poster && this._poster !== this._oldPoster) {
            if (!this._posterImg) {
                this._posterImg = new vf.Sprite();
                var index = this.container.getChildIndex(this._sprite);
                this.container.addChildAt(this._posterImg, index + 1);
            }
            this._posterImg.texture = Utils_1.getTexture(this._poster);
            this._oldPoster = this._poster;
            this._posterImg.width = this.width;
            this._posterImg.height = this.height;
            this._posterImg.visible = false;
        }
    };
    Video.prototype.clearPoster = function () {
        if (this._posterImg) {
            if (this._posterImg.parent) {
                this._posterImg.parent.removeChild(this._posterImg);
            }
            this._posterImg.destroy();
            this._posterImg = undefined;
        }
        this._oldPoster = "";
    };
    Object.defineProperty(Video.prototype, "silent", {
        get: function () {
            return this._silent;
        },
        set: function (value) {
            value = Utils_1.getSource(value);
            this._silent = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "audio", {
        get: function () {
            return this._audio;
        },
        set: function (value) {
            value = Utils_1.getSource(value);
            this._audio = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "src", {
        //设置src
        get: function () {
            return this._src;
        },
        set: function (value) {
            var o = Utils_1.getSource(value);
            var checkUrl = false;
            checkUrl = (typeof value === 'string' && value.indexOf('//') !== -1);
            var v = value;
            if (!o && !checkUrl) { // 没有值 并且不是链接
                this._src = null;
                this._oldSrc = undefined;
                //清除旧视频数据
                this.clearSource();
                this.clearVideoBtn();
                this.clearPoster();
                this.clearSprite();
                this.clearVideo();
                return;
            }
            if (o && typeof (o) === "object" && o.url) {
                v = o.url;
                if (o["audio"]) {
                    this._audio = o["audio"];
                }
                if (o["silent"]) {
                    this._silent = o["silent"];
                }
            }
            if (this._src == v) {
                return;
            }
            if (v instanceof HTMLVideoElement) {
                this._video = v;
                this._src = this._video.src;
            }
            else {
                this._src = v;
            }
            // this.checkSrcLegal();
            //受别的参数影响  下一帧生效
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "srcObject", {
        get: function () {
            if (this._src && window["MediaStream"] && this._src instanceof MediaStream) {
                return this._src;
            }
            if (!window["MediaStream"]) {
                console.log("当前不支持 mediaStream");
            }
            return undefined;
        },
        set: function (value) {
            if (this._src === value) {
                return;
            }
            this._src = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "autoplay", {
        get: function () {
            return this._autoplay;
        },
        set: function (value) {
            this._autoplay = value;
            this._video && (this._video.autoplay = value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "loop", {
        get: function () {
            return this._loop;
        },
        set: function (value) {
            this._loop = value;
            this._video && (this._video.loop = value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "poster", {
        get: function () {
            return this._poster;
        },
        set: function (value) {
            if (this._poster === value) {
                return;
            }
            this._poster = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "muted", {
        //静音
        get: function () {
            return this._muted;
        },
        set: function (boo) {
            this._muted = boo;
            this._video && (this._video.muted = boo);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "controls", {
        get: function () {
            return this._controls;
        },
        set: function (boo) {
            this._controls = boo;
            this._video && (this._video.controls = boo);
            this._videoBtn && (this._videoBtn.visible = (this._controls && !this._elemDraw));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "volume", {
        get: function () {
            return this._volume;
        },
        set: function (value) {
            value = value > 1 ? 1 : value;
            value = value < 0 ? 0 : value;
            this._volume = value;
            this._video && (this._video.volume = value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "visible", {
        get: function () {
            return this._visibleStatus;
        },
        set: function (boo) {
            if (this._visibleStatus === boo) {
                return;
            }
            this._visibleStatus = boo;
            if (boo === true) {
                this.validateNow();
            }
            this.container.visible = boo;
            this._video && (this._video.style.visibility = this.visible ? "visible" : "hidden");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "videoElement", {
        get: function () {
            return this._video;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "currentTime", {
        //播放位置
        get: function () {
            return this._currentTime;
        },
        set: function (value) {
            this._currentTime = value;
            this._video && (this._video.currentTime = this._currentTime);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "videoGroup", {
        /**
         * 设置分组名
         */
        get: function () {
            return this._groupName;
        },
        set: function (value) {
            if (value === undefined) {
                Index_1.VideoGroupController.unRegistrerVideoGroup(this);
            }
            if (this._groupName == value) {
                return;
            }
            this._groupName = value; //需要在registrerCheckGroup之前
            Index_1.VideoGroupController.registrerVideoGroup(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "duration", {
        /**
         * 只读的属性们~~~~~~~~~~~~~~~~
         * */
        get: function () {
            if (this._video) {
                return this._video.duration;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Video.prototype, "isPlaying", {
        get: function () {
            return this._isplaying;
        },
        enumerable: false,
        configurable: true
    });
    /**
    * 支持的方法们~~~··~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    **/
    Video.prototype.play = function () {
        var _a;
        //如果处于恢复状态，不播放声音
        if (((_a = this.stage) === null || _a === void 0 ? void 0 : _a.syncManager) && this.stage.syncManager.resumeStatusFlag) {
            return;
        }
        //在教室环境，使用nativeAudio
        if (this.useNativeAudio()) {
            if (!this._audio) {
                console.warn('课件环境需要配置audio参数！');
            }
            this.nativeEmit(this._audio, 'playAudio');
        }
        if (this._video) {
            this.clearPoster();
            try {
                this._video.play();
            }
            catch (error) {
                console.log(error);
            }
            return;
        }
        else {
            this.autoplay = true; // 正常不走这里
        }
        // throw new Error("Video is undefined!");
    };
    Video.prototype.pause = function () {
        var _a;
        //如果处于恢复状态，不播放声音
        if (((_a = this.stage) === null || _a === void 0 ? void 0 : _a.syncManager) && this.stage.syncManager.resumeStatusFlag) {
            return;
        }
        //在教室环境，使用nativeAudio
        if (this.useNativeAudio()) {
            this.nativeEmit(this._audio, 'pauseAudio');
        }
        this._video && this._video.pause();
    };
    //进入全屏
    Video.prototype.requestFullScreen = function () {
        if (this._elemDraw == true) {
            this.requestFullScreenDom();
            return;
        }
        if (this._fullStates == "full") {
            return;
        }
        //全屏是自己做的 需要记录小屏的数据  需要满足两个需求
        //1 获取的到stage的宽高
        //2.已经加载了第一帧  否则sprite的宽高记录不到
        var stage = this.stage;
        if (!stage || this._firstLoad == false) {
            this._fullStates = "fulling";
            return;
        }
        this.fullScreen();
    };
    Video.prototype.fullScreen = function () {
        var stage = this.stage;
        if (!stage || !this._sprite) {
            return;
        }
        this._fullStates = "full";
        this._oldX = this.x;
        this._oldY = this.y;
        var stageWidth = stage.width;
        var stageHeight = stage.height;
        var scale = Math.min(stageWidth / this.width, stageHeight / this.height);
        var w = this.width * scale;
        var h = this.height * scale;
        this._sprite.width = w;
        this._sprite.height = h;
        if (this._posterImg) {
            this._posterImg.width = w;
            this._posterImg.height = h;
        }
        var disX = 0;
        var disY = 0;
        if (this.container.parent) {
            var pos1 = this.container.parent.toLocal(new vf.Point(0, 0));
            disX = pos1.x;
            disY = pos1.y;
        }
        this.x = (stageWidth - this._sprite.width) * 0.5 + disX;
        this.y = (stageHeight - this._sprite.height) * 0.5 + disY;
    };
    Video.prototype.requestFullScreenDom = function () {
        var de = this._video;
        if (de.requestFullscreen) {
            de.requestFullscreen();
        }
        else if (de.mozRequestFullScreen) {
            de.mozRequestFullScreen();
        }
        else if (de.webkitRequestFullScreen) {
            de.webkitRequestFullScreen();
        }
        else if (de.webkitEnterFullScreen) {
            de.webkitEnterFullScreen();
        }
    };
    //退出全屏
    Video.prototype.exitFullscreen = function () {
        if (this._elemDraw == true) {
            this.exitFullscreenDom();
            return;
        }
        if (this._fullStates == "noFull" || !this._sprite) {
            return;
        }
        this._fullStates = "noFull";
        this._sprite.width = this.width;
        this._sprite.height = this.height;
        if (this._posterImg) {
            this._posterImg.width = this.width;
            this._posterImg.height = this.height;
        }
        this.x = this._oldX;
        this.y = this._oldY;
    };
    Video.prototype.exitFullscreenDom = function () {
        var de = this._video;
        if (de.exitFullscreen) {
            de.exitFullscreen();
        }
        else if (de.mozCancelFullScreen) {
            de.mozCancelFullScreen();
        }
        else if (de.webkitCancelFullScreen) {
            de.webkitCancelFullScreen();
        }
        else if (de.webkitExitFullScreen) {
            de.webkitExitFullScreen();
        }
    };
    Video.prototype.clearSource = function () {
        var v = this._videoTextrue;
        if (v) {
            this.exitFullscreen();
            if (v.baseTexture && v.baseTexture.resource.source) {
                v.baseTexture.resource.source.onseeked = null;
            }
            v.destroy();
        }
    };
    Video.prototype.clearVideoBtn = function () {
        if (this._videoBtn) {
            if (this._videoBtn.parent) {
                this._videoBtn.parent.removeChild(this._videoBtn);
            }
            this._videoBtn.off(vf.gui.Interaction.TouchMouseEvent.onClick, this.clickAudio, this);
            this._videoBtn.release();
            this._videoBtn = undefined;
        }
    };
    Video.prototype.clearVideoEvent = function () {
        if (this._video) {
            var video = this._video;
            video.removeEventListener('canplay', this._canplayFun);
            //浏览器估算可以播放到结束，不需要停止缓存更多的内容。
            video.removeEventListener('canplaythrough', this._canplaythroughFun);
            //渲染完成
            video.removeEventListener('complete', this._completeFun);
            //视频已经到达结束点
            video.removeEventListener('ended', this._endedFun);
            //首帧已经加载
            video.removeEventListener('loadeddata', this._loadeddataFun);
            //duration 属性的值改变时触发
            video.removeEventListener('durationchange', this._durationchangeFun);
            //暂停
            video.removeEventListener('pause', this._pauseFun);
            //播放
            video.removeEventListener('play', this._playFun);
        }
        this._videoHasEvent = false;
    };
    Video.prototype.clearVideo = function () {
        if (this._video) {
            var video = this._video;
            this.clearVideoEvent();
            if (video.parentElement) {
                video.parentElement.removeChild(this._video);
            }
        }
        this._video && (this._video.pause());
        this._video = null;
        this._isplaying = false;
    };
    Video.prototype.clearSprite = function () {
        if (this._sprite) {
            this._sprite.parent && this._sprite.parent.removeChild(this._sprite);
            this._sprite.texture && this._sprite.texture.destroy();
            this._sprite.destroy();
            this._sprite = undefined;
        }
    };
    Video.prototype.useNativeAudio = function () {
        var _a, _b;
        return (_b = (_a = this.stage) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.vfvars.useNativeAudio;
    };
    Video.prototype.nativeEmit = function (url, typeTag) {
        var _a;
        (_a = this.stage) === null || _a === void 0 ? void 0 : _a.getSystemEvent().emit('message', {
            code: 'native',
            type: 'native',
            level: 'command',
            target: this,
            data: {
                type: typeTag,
                src: url,
                mode: 'sound',
                signalling: false,
            }
        });
    };
    Video.prototype.release = function () {
        _super.prototype.release.call(this);
        //在教室环境，使用nativeAudio
        if (this.useNativeAudio()) {
            this.nativeEmit(this._audio, 'pauseAudio');
        }
        this._src = null;
        this._oldSrc = null;
        this._canvasBounds = undefined;
        this._lastRenderer = undefined;
        this._resolution = 1;
        this._poster = this._oldPoster = "";
        Index_1.VideoGroupController.unRegistrerVideoGroup(this);
        this._canplayFun = null;
        this.clearSource();
        this.clearPoster();
        this.clearSprite();
        this.clearVideo();
        this.clearVideoBtn();
        this._canplaythroughFun = null;
        this._completeFun = null;
        this._endedFun = null;
        this._loadeddataFun = null;
        this._durationchangeFun = null;
        this._firstLoad = false;
        this._fullStates = "noFull";
        this._canPlay = false;
        this._elemDraw = false;
        this._canPlayFirst = false;
    };
    return Video;
}(DisplayObject_1.DisplayObject));
exports.Video = Video;


/***/ }),

/***/ "./src/display/VideoBtn.ts":
/*!*********************************!*\
  !*** ./src/display/VideoBtn.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoBtn = void 0;
var Container_1 = __webpack_require__(/*! ./Container */ "./src/display/Container.ts");
var Circle_1 = __webpack_require__(/*! ./Circle */ "./src/display/Circle.ts");
var Star_1 = __webpack_require__(/*! ./Star */ "./src/display/Star.ts");
var Rect_1 = __webpack_require__(/*! ./Rect */ "./src/display/Rect.ts");
var Index_1 = __webpack_require__(/*! ../interaction/Index */ "./src/interaction/Index.ts");
var VideoBtn = /** @class */ (function (_super) {
    __extends(VideoBtn, _super);
    function VideoBtn() {
        var _this = _super.call(this) || this;
        _this._states = "pause";
        _this.updateDisplayList();
        return _this;
    }
    VideoBtn.prototype.setStates = function (states) {
        this._states = states;
        this.updateDisplayList();
    };
    VideoBtn.prototype.updateDisplayList = function () {
        this.initBgCircle();
        this.initTrangle();
        this.initLine();
        switch (this._states) {
            case "play":
                this.refreshPlay();
                break;
            case "pause":
                this.refreshPause();
                break;
        }
    };
    VideoBtn.prototype.refreshPlay = function () {
        this._rect1 && (this._rect1.visible = true);
        this._rect2 && (this._rect2.visible = true);
    };
    VideoBtn.prototype.refreshPause = function () {
        this._thumbTriangle && (this._thumbTriangle.visible = true);
    };
    VideoBtn.prototype.initBgCircle = function () {
        if (!this._bgCircle) {
            this._bgCircle = new Circle_1.Circle();
            this._bgCircle.color = 0xef7f51;
            this.on(Index_1.TouchMouseEvent.onHover, this.onHover, this);
            this.addChild(this._bgCircle);
        }
        this._bgCircle.width = this.width;
        this._bgCircle.height = this.height;
    };
    VideoBtn.prototype.onHover = function (e, thisObj, over) {
        if (over) {
            thisObj.style.cursor = 'pointer';
        }
        else {
            thisObj.style.cursor = '';
        }
    };
    VideoBtn.prototype.initTrangle = function () {
        if (!this._thumbTriangle) {
            this._thumbTriangle = new Star_1.Star();
            this._thumbTriangle.color = 0xffffff;
            this._thumbTriangle.triangleNum = 3;
            this._thumbTriangle.rotation = 90;
            this._thumbTriangle.anchorX = 0.5;
            this._thumbTriangle.anchorY = 0.5;
            this.addChild(this._thumbTriangle);
        }
        this._thumbTriangle.visible = false;
        this._thumbTriangle.x = this.width * 0.87;
        this._thumbTriangle.y = this.width * 0.13;
        this._thumbTriangle.width = this._thumbTriangle.height = this.width * 0.5;
    };
    VideoBtn.prototype.initLine = function () {
        if (!this._rect1) {
            this._rect1 = new Rect_1.Rect();
            this._rect1.color = '0xffffff';
            this.addChild(this._rect1);
        }
        this._rect1.width = this.width * 0.1;
        this._rect1.height = this.width * 0.3;
        this._rect1.x = this.width * 0.35;
        this._rect1.y = this.width * 0.35;
        this._rect1.visible = false;
        if (!this._rect2) {
            this._rect2 = new Rect_1.Rect();
            this._rect2.color = '0xffffff';
            this.addChild(this._rect2);
        }
        this._rect2.width = this.width * 0.1;
        this._rect2.height = this.width * 0.3;
        this._rect2.x = this.width * 0.55;
        this._rect2.y = this.width * 0.35;
        this._rect2.visible = false;
    };
    VideoBtn.prototype.release = function () {
        if (this._bgCircle) {
            this._bgCircle.parent && (this._bgCircle.parent.removeChild(this._bgCircle));
            this._bgCircle.release();
            this._bgCircle = undefined;
        }
        if (this._thumbTriangle) {
            this._thumbTriangle.parent && (this._thumbTriangle.parent.removeChild(this._thumbTriangle));
            this._thumbTriangle.release();
            this._thumbTriangle = undefined;
        }
        if (this._rect1) {
            this._rect1.parent && (this._rect1.parent.removeChild(this._rect1));
            this._rect1.release();
            this._rect1 = undefined;
        }
        if (this._rect2) {
            this._rect2.parent && (this._rect2.parent.removeChild(this._rect2));
            this._rect2.release();
            this._rect2 = undefined;
        }
        this.off(Index_1.TouchMouseEvent.onHover, this.onHover, this);
        _super.prototype.release.call(this);
    };
    return VideoBtn;
}(Container_1.Container));
exports.VideoBtn = VideoBtn;


/***/ }),

/***/ "./src/display/animation/Animation.ts":
/*!********************************************!*\
  !*** ./src/display/animation/Animation.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Animation = void 0;
var AnimationJitter_1 = __webpack_require__(/*! ./AnimationJitter */ "./src/display/animation/AnimationJitter.ts");
var AnimationPath_1 = __webpack_require__(/*! ./AnimationPath */ "./src/display/animation/AnimationPath.ts");
var Animation = /** @class */ (function () {
    function Animation() {
    }
    Animation.play = function (type, sprite, options, durtime, callBack) {
        var cls;
        switch (type) {
            case "jitter":
                cls = AnimationJitter_1.AnimationJitter;
                break;
            case "path":
                cls = AnimationPath_1.AnimationPath;
                break;
        }
        var _ani = new cls(sprite, options, durtime);
        Animation._aniList.push(_ani);
        if (_ani) {
            _ani.on("complete", function () {
                Animation.removeItem(_ani);
                _ani.release();
                callBack && callBack();
            });
            _ani.on('release', function () {
                Animation.removeItem(_ani);
            });
            _ani.play();
        }
        return _ani;
    };
    Animation.removeItem = function (_ani) {
        if (!Animation._aniList) {
            return;
        }
        for (var i = 0; i < Animation._aniList.length; i++) {
            if (Animation._aniList[i] === _ani) {
                Animation._aniList.splice(i, 1);
                return;
            }
        }
    };
    Animation.releaseAll = function () {
        if (Animation._aniList) {
            for (var i = 0; i < Animation._aniList.length; i++) {
                if (Animation._aniList[i]) {
                    Animation._aniList[i].release();
                }
            }
        }
        Animation._aniList = [];
    };
    Animation._aniList = [];
    return Animation;
}());
exports.Animation = Animation;


/***/ }),

/***/ "./src/display/animation/AnimationJitter.ts":
/*!**************************************************!*\
  !*** ./src/display/animation/AnimationJitter.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationJitter = void 0;
var AnimationBase_1 = __webpack_require__(/*! ../private/AnimationBase */ "./src/display/private/AnimationBase.ts");
var TweenEvent_1 = __webpack_require__(/*! ../../event/TweenEvent */ "./src/event/TweenEvent.ts");
var Tween_1 = __webpack_require__(/*! ../../tween/Tween */ "./src/tween/Tween.ts");
var AnimationJitter = /** @class */ (function (_super) {
    __extends(AnimationJitter, _super);
    function AnimationJitter(sp, options, duratime) {
        var _this = _super.call(this, sp, options, duratime) || this;
        _this._revertAni = true;
        return _this;
    }
    AnimationJitter.prototype.play = function (timer) {
        if (timer === void 0) { timer = 0; }
        if (this.playing === true) {
            return;
        }
        _super.prototype.play.call(this, timer);
        var sp = this.sprite; //显示对象
        this.tween && this.clearTween();
        if (!this.tween) {
            this.tween = new Tween_1.Tween(sp)
                .to(this.options, 35)
                .repeat(Infinity)
                .easing(vf.gui.Easing.Linear.None)
                .yoyo(true)
                .delay(10);
            this.tween.on(TweenEvent_1.TweenEvent.complete, this.complete.bind(this));
        }
        this.tween.start();
    };
    AnimationJitter.prototype.gotoAndStop = function (timer) {
        this.tween && this.tween.gotoAndStop(timer);
        _super.prototype.gotoAndStop.call(this, timer);
    };
    // public getTimeData(timer: number) {
    //     const d = new AnimationBaseData();
    //     if (timer <= 2000) {
    //         d.x = 200 + 200 * (timer / 1000);
    //     }
    //     return d;
    // }
    AnimationJitter.prototype.clearTween = function () {
        var sp = this.sprite; //显示对象
        if (this.tween) {
            this.tween.release();
            this.tween = undefined;
        }
    };
    AnimationJitter.prototype.complete = function () {
        this.clearTween();
        _super.prototype.complete.call(this);
    };
    AnimationJitter.prototype.release = function () {
        this.clearTween();
        _super.prototype.release.call(this);
    };
    return AnimationJitter;
}(AnimationBase_1.AnimationBase));
exports.AnimationJitter = AnimationJitter;


/***/ }),

/***/ "./src/display/animation/AnimationPath.ts":
/*!************************************************!*\
  !*** ./src/display/animation/AnimationPath.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationPath = void 0;
var AnimationBase_1 = __webpack_require__(/*! ../private/AnimationBase */ "./src/display/private/AnimationBase.ts");
var PathTimeline_1 = __webpack_require__(/*! ./PathTimeline */ "./src/display/animation/PathTimeline.ts");
var Ticker_1 = __webpack_require__(/*! ../../core/Ticker */ "./src/core/Ticker.ts");
var AnimationPath = /** @class */ (function (_super) {
    __extends(AnimationPath, _super);
    function AnimationPath(sp, options, duratime) {
        var _this = _super.call(this, sp, options, duratime) || this;
        _this.pathTimeline = new PathTimeline_1.PathTimeline(options.path);
        _this.pathTimeline.frames = options.frames;
        if (options.frames && options.frames.length) {
            _this.pathTimeline.totalTime = options.frames[options.frames.length - 1].time;
        }
        _this.pathTimeline.loop = !!options.loop;
        return _this;
    }
    AnimationPath.prototype.play = function (timer) {
        if (timer === void 0) { timer = 0; }
        if (this.playing === true) {
            return;
        }
        _super.prototype.play.call(this, timer);
    };
    AnimationPath.prototype.gotoAndStop = function (timer) {
        _super.prototype.gotoAndStop.call(this, timer);
    };
    AnimationPath.prototype.updata = function (delta) {
        if (this.playing === false) {
            return;
        }
        this._currenTimer += Ticker_1.TickerShared.deltaMS;
        var _a = this, pathTimeline = _a.pathTimeline, sprite = _a.sprite;
        if (pathTimeline) {
            pathTimeline.globalTime = this._currenTimer;
            //因为path.getPointAtLength这个api比较耗性能，导致恢复时长较长，故恢复状态不实时获取坐标  by ziye+
            if (sprite && sprite.stage && !sprite.stage.resumeStatusFlag) {
                var curPos = pathTimeline.curPos;
                sprite.x = curPos[0];
                sprite.y = curPos[1];
            }
            if (!pathTimeline.loop && this._currenTimer >= pathTimeline.totalTime) {
                //校对位置
                var curPos = pathTimeline.curPos;
                sprite.x = curPos[0];
                sprite.y = curPos[1];
                this.complete();
            }
        }
    };
    AnimationPath.prototype.release = function () {
        if (this.pathTimeline) {
            this.pathTimeline.release();
            this.pathTimeline = null;
        }
        _super.prototype.release.call(this);
    };
    return AnimationPath;
}(AnimationBase_1.AnimationBase));
exports.AnimationPath = AnimationPath;


/***/ }),

/***/ "./src/display/animation/PathTimeline.ts":
/*!***********************************************!*\
  !*** ./src/display/animation/PathTimeline.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathTimeline = void 0;
var Timeline_1 = __webpack_require__(/*! ./Timeline */ "./src/display/animation/Timeline.ts");
var PathTimeline = /** @class */ (function (_super) {
    __extends(PathTimeline, _super);
    function PathTimeline(path) {
        var _this = _super.call(this) || this;
        _this.length = 0;
        _this.path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        _this.path.setAttribute("d", path);
        _this.length = _this.path.getTotalLength();
        return _this;
    }
    Object.defineProperty(PathTimeline.prototype, "curPos", {
        get: function () {
            if (this.path) {
                var p = this.path.getPointAtLength(this._curValue * this.length);
                return [p.x, p.y];
            }
            return [0, 0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PathTimeline.prototype, "angle", {
        get: function () {
            var p0 = this.path.getPointAtLength(this._curValue * this.length - 1);
            var p1 = this.path.getPointAtLength(this._curValue * this.length + 1);
            return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
        },
        enumerable: false,
        configurable: true
    });
    PathTimeline.prototype.release = function () {
        if (this.path && this.path.parentElement) {
            this.path.parentElement.removeChild(this.path);
        }
        this.path = null;
        _super.prototype.release.call(this);
    };
    return PathTimeline;
}(Timeline_1.Timeline));
exports.PathTimeline = PathTimeline;


/***/ }),

/***/ "./src/display/animation/Timeline.ts":
/*!*******************************************!*\
  !*** ./src/display/animation/Timeline.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberFrame = exports.Frame = exports.Timeline = void 0;
var Timeline = /** @class */ (function () {
    function Timeline() {
        this.frames = [];
        this.curTime = 0;
        this.lastTime = 0;
        this.loop = false;
        this.totalTime = 0;
        this._defaultValue = null;
        this._globalTime = 0;
        this._lastGlobalTime = 0;
        this._lastFrame = null;
        this._curFrame = null;
        this._nextFrame = null;
        this._times = -1;
        this._curValue = null;
        //
    }
    Object.defineProperty(Timeline.prototype, "defaultValue", {
        set: function (value) {
            this._defaultValue = value;
            this._curValue = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timeline.prototype, "curValue", {
        get: function () {
            return this._curValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Timeline.prototype, "globalTime", {
        set: function (v) {
            this._globalTime = v;
            this.tick();
            this._lastGlobalTime = v;
        },
        enumerable: false,
        configurable: true
    });
    Timeline.prototype.getProgress = function (cur, min, max, ease) {
        var lineProgress = 0;
        var curveProgress = 0;
        if (max === min) {
            lineProgress = 0;
        }
        else {
            lineProgress = (cur - min) / (max - min);
        }
        curveProgress = lineProgress;
        if (ease) {
            curveProgress = ease(lineProgress);
            // todo bezier
        }
        return curveProgress;
    };
    Timeline.prototype.tick = function () {
        this.curTime = this._globalTime;
        if (this.loop) {
            this._times = Math.floor(this.curTime / this.totalTime);
            this.curTime = this.curTime - this.totalTime * this._times;
        }
        this.updateCurFrame();
        this.updateCurValue();
        this.lastTime = this.curTime;
    };
    Timeline.prototype.updateCurFrame = function () {
        if (this.frames.length === 0) {
            return;
        }
        this._lastFrame = this._curFrame;
        var i = 0;
        var len = 0;
        for (i = 0, len = this.frames.length; i < len; i++) {
            if (this.frames[i].time > this.curTime) {
                if (i === 0) {
                    this._curFrame = null;
                    this._nextFrame = this.frames[i];
                }
                else {
                    this._curFrame = this.frames[i - 1];
                    this._nextFrame = this.frames[i];
                }
                return;
            }
        }
        this._curFrame = this.frames[this.frames.length - 1];
        this._nextFrame = this._curFrame;
    };
    Timeline.prototype.updateCurValue = function () {
        if (this._curFrame && this._nextFrame) {
            var p = this.getProgress(this.curTime, this._curFrame.time, this._nextFrame.time, this._curFrame.ease);
            this._curValue = this._curFrame.getValue(p, this._nextFrame.value);
        }
    };
    Timeline.prototype.release = function () {
        this.frames = [];
        this.curTime = 0;
        this.lastTime = 0;
        this.loop = false;
        this.totalTime = 0;
        this._defaultValue = null;
        this._globalTime = 0;
        this._lastGlobalTime = 0;
        this._lastFrame = null;
        this._curFrame = null;
        this._nextFrame = null;
        this._times = -1;
    };
    return Timeline;
}());
exports.Timeline = Timeline;
var Frame = /** @class */ (function () {
    function Frame() {
        this.time = -1;
        this.value = null;
    }
    Frame.prototype.getValue = function (progress, value) {
        return null;
    };
    return Frame;
}());
exports.Frame = Frame;
var NumberFrame = /** @class */ (function (_super) {
    __extends(NumberFrame, _super);
    function NumberFrame() {
        return _super.call(this) || this;
    }
    NumberFrame.prototype.getValue = function (progress, value) {
        return this.value + (value - this.value) * progress;
    };
    return NumberFrame;
}(Frame));
exports.NumberFrame = NumberFrame;


/***/ }),

/***/ "./src/display/private/AnimationBase.ts":
/*!**********************************************!*\
  !*** ./src/display/private/AnimationBase.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationBase = exports.AnimationBaseData = void 0;
var Ticker_1 = __webpack_require__(/*! ../../core/Ticker */ "./src/core/Ticker.ts");
var Utils_1 = __webpack_require__(/*! ../../utils/Utils */ "./src/utils/Utils.ts");
var AnimationBaseData = /** @class */ (function () {
    function AnimationBaseData() {
        this.x = NaN;
        this.y = NaN;
        this.rotation = NaN;
    }
    return AnimationBaseData;
}());
exports.AnimationBaseData = AnimationBaseData;
var AnimationBase = /** @class */ (function (_super) {
    __extends(AnimationBase, _super);
    function AnimationBase(sp, options, duratime) {
        var _this = _super.call(this) || this;
        _this._duratime = NaN; //持续
        _this._currenTimer = NaN; //当前播放时间
        _this._revertAni = false; //动画播放后 sprite是否重置最初状态
        _this._playing = false;
        _this._addTick = false;
        if (sp) {
            _this.sprite = sp;
        }
        if (options) {
            _this._options = options;
        }
        if (duratime) {
            _this._duratime = duratime;
        }
        return _this;
    }
    Object.defineProperty(AnimationBase.prototype, "playing", {
        get: function () {
            return this._playing;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationBase.prototype, "sprite", {
        get: function () {
            return this._sprite;
        },
        set: function (value) {
            this._sprite = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationBase.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (value) {
            this._options = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimationBase.prototype, "revertAni", {
        get: function () {
            return this._revertAni;
        },
        enumerable: false,
        configurable: true
    });
    AnimationBase.prototype.cacheSprite = function () {
        if (this.sprite) {
            var object = this.sprite;
            var opt = this._options;
            this._valuesStart = {};
            for (var property in opt) {
                var start = object && object[property] && Utils_1.deepCopy(object[property]);
                this._valuesStart[property] = start;
            }
        }
    };
    //子类重写
    AnimationBase.prototype.play = function (curTimer) {
        if (curTimer === void 0) { curTimer = NaN; }
        // this.emit("play", this);
        if (this._revertAni === true) {
            this.cacheSprite();
        }
        this._playing = true;
        if (isNaN(curTimer)) {
            isNaN(this._currenTimer) && (this._currenTimer = 0);
        }
        else {
            this._currenTimer = curTimer;
        }
        if (!this._addTick) {
            this._addTick = true;
            Ticker_1.TickerShared.add(this.updata, this);
        }
    };
    AnimationBase.prototype.pause = function () {
        this._playing = false;
        this.gotoAndStop(this._currenTimer);
    };
    /**
     * 播放完成
     */
    AnimationBase.prototype.complete = function () {
        Ticker_1.TickerShared.remove(this.updata, this);
        this._playing = false;
        if (this._revertAni === true) {
            //还原状态
            this.setTimeStates(0);
        }
        this.emit("complete");
    };
    AnimationBase.prototype.gotoAndPlay = function (timer) {
        this.goto(timer);
        this._playing = true;
        this.play(timer);
    };
    AnimationBase.prototype.gotoAndStop = function (timer) {
        this._playing = false;
        this.goto(timer);
    };
    /**
     * 跳转
     */
    AnimationBase.prototype.goto = function (timer) {
        //刷新当前显示对象的状态信息
        this._currenTimer = timer;
        this.setTimeStates(timer);
    };
    /**
     *
     * 设置当前sprite状态
     */
    AnimationBase.prototype.setTimeStates = function (timer) {
        var d = this.getTimeData(timer);
        if (this._sprite && d) {
            !isNaN(d.x) && (this._sprite.x = d.x);
            !isNaN(d.y) && (this._sprite.y = d.y);
            !isNaN(d.rotation) && (this._sprite.rotation = d.rotation);
        }
    };
    /**
     * 获取当前时间的sprite数据
     * 如果重播时重头播放就可以  子类可以不用重写
     *  每个动画计算方式不同 这个方法需要重写
     */
    AnimationBase.prototype.getTimeData = function (timer) {
        return this._spriteData;
    };
    /**
     *
     */
    AnimationBase.prototype.updata = function (delta) {
        if (this._playing === false) {
            return;
        }
        if (this._duratime > 0 && this._currenTimer >= this._duratime) {
            this.complete();
        }
        else {
            this._currenTimer += Ticker_1.TickerShared.deltaMS;
        }
    };
    //子类重写
    AnimationBase.prototype.release = function () {
        this.emit("release");
        this.removeAllListeners();
        Ticker_1.TickerShared.remove(this.updata, this);
        this._addTick = false;
        this._sprite = undefined;
        this._options = undefined;
        this._duratime = NaN;
        this._playing = false;
    };
    return AnimationBase;
}(vf.utils.EventEmitter));
exports.AnimationBase = AnimationBase;


/***/ }),

/***/ "./src/display/private/GifSprite.ts":
/*!******************************************!*\
  !*** ./src/display/private/GifSprite.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GifSprite = void 0;
var Utils_1 = __webpack_require__(/*! ../../utils/Utils */ "./src/utils/Utils.ts");
var GifSequence_1 = __webpack_require__(/*! ../../utils/GifSequence */ "./src/utils/GifSequence.ts");
var GifSprite = /** @class */ (function (_super) {
    __extends(GifSprite, _super);
    function GifSprite(resource) {
        var _this = _super.call(this) || this;
        _this._sequences = {};
        // eslint-disable-next-line no-debugger
        // debugger;
        if (typeof resource === 'string') {
            resource = Utils_1.getSource(resource);
            _this._frames = resource['frames'];
        }
        else if (resource && ("gif" in resource) && "frames" in resource) {
            _this._frames = resource;
        }
        else {
            _this._frames = resource['frames'];
        }
        var allFrames = [];
        for (var i = 0; i < _this._frames.numFrames; ++i) {
            allFrames.push(i);
        }
        _this._currentSequence = _this._addSequence('', _this._frames.frames, _this._frames.gif.loopCount);
        _this.setSequence('', true);
        return _this;
    }
    Object.defineProperty(GifSprite.prototype, "gifFrames", {
        get: function () {
            return this._frames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifSprite.prototype, "totalFrames", {
        get: function () {
            return this._frames.numFrames;
        },
        enumerable: false,
        configurable: true
    });
    GifSprite.prototype.getSequence = function (name) {
        return this._sequences[name] || this._sequences[''];
    };
    GifSprite.prototype.addSequence = function (name, frames, loopCount) {
        var _this = this;
        return this._addSequence(name, frames.map(function (f) { return _this._frames.getFrame(f); }), loopCount);
    };
    GifSprite.prototype._addSequence = function (name, frames, loopCount) {
        var seq = new GifSequence_1.GifSequence(this, name, frames, loopCount);
        this._sequences[name] = seq;
        return seq;
    };
    GifSprite.prototype.setSequence = function (name, play) {
        var wasPlaying = this._currentSequence.playing;
        if (play === undefined) {
            play = wasPlaying;
        }
        this._currentSequence.stop(true);
        this._currentSequence = this.getSequence(name);
        this.setGifFrame(this._currentSequence.frames[0]);
        if (!(play && this._currentSequence.play())) {
            wasPlaying && this.emit(GifSprite.EVENT.STOP, this);
        }
    };
    GifSprite.prototype.destroy = function () {
        this.stop();
        _super.prototype.destroy.call(this);
    };
    GifSprite.prototype.play = function () {
        this._currentSequence.play();
    };
    GifSprite.prototype.stop = function () {
        this._currentSequence.stop();
    };
    GifSprite.prototype.setFrame = function (frame) {
        this.setGifFrame(this._frames.getFrame(frame));
    };
    GifSprite.prototype.setGifFrame = function (frame) {
        if (this._currentFrame != frame) {
            this._currentFrame = frame;
            this.texture = frame ? frame.texture : null;
            this.emit(GifSprite.EVENT.FRAME_CHANGED, this);
        }
    };
    GifSprite.prototype.gotoAndStop = function (frame) {
        this.setSequence('', false);
        this.setFrame(frame);
    };
    GifSprite.prototype.gotoAndPlay = function (frame) {
        this.setSequence('', true);
        this.setFrame(frame);
    };
    Object.defineProperty(GifSprite.prototype, "currentFrame", {
        get: function () {
            return this._currentFrame ? this._currentFrame.index : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifSprite.prototype, "currentGifFrame", {
        get: function () {
            return this._currentFrame;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifSprite.prototype, "currentSequence", {
        get: function () {
            return this._currentSequence;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifSprite.prototype, "playing", {
        get: function () {
            return this._currentSequence.playing;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifSprite.prototype, "speedScale", {
        get: function () {
            return this._currentSequence.speedScale;
        },
        set: function (value) {
            this._currentSequence.speedScale = value;
        },
        enumerable: false,
        configurable: true
    });
    GifSprite.EVENT = {
        FRAME_CHANGED: 'frameChanged',
        PLAY: 'play',
        STOP: 'stop',
        COMPLETE: 'complete',
        END: 'end'
    };
    return GifSprite;
}(vf.Sprite));
exports.GifSprite = GifSprite;


/***/ }),

/***/ "./src/display/private/GraphBase.ts":
/*!******************************************!*\
  !*** ./src/display/private/GraphBase.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphBase = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Utils_1 = __webpack_require__(/*! ../../utils/Utils */ "./src/utils/Utils.ts");
var GraphicsCore_1 = __webpack_require__(/*! ./GraphicsCore */ "./src/display/private/GraphicsCore.ts");
/**
 * 绘制图形基类
 */
var GraphBase = /** @class */ (function (_super) {
    __extends(GraphBase, _super);
    function GraphBase() {
        var _this = _super.call(this) || this;
        /**
         * 半径
         */
        _this._radius = 0;
        /**
         *
         */
        _this._alignment = 0.5;
        /**
         * 线条样式
         */
        _this._lineType = "full";
        /**
         * 线条颜色
         */
        _this._lineColor = 0xffffff;
        /**
         * 线条粗细
         */
        _this._lineWidth = 0;
        /**
         * 线条透明度
         */
        _this._lineAlpha = 1;
        /**
         * 填充透明度
         */
        _this._fillAlpha = 1;
        _this.graphics = new GraphicsCore_1.GraphicsCore();
        _this.container.addChild(_this.graphics);
        return _this;
    }
    /** 可以支持遮罩的组件 */
    GraphBase.prototype.maskSprite = function () {
        return this.graphics;
    };
    Object.defineProperty(GraphBase.prototype, "radius", {
        get: function () {
            return this._radius;
        },
        set: function (value) {
            this._radius = value;
            this.invalidateSize();
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "alignment", {
        get: function () {
            return this._alignment;
        },
        set: function (value) {
            this._alignment = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "lineType", {
        get: function () {
            return this._lineType;
        },
        set: function (value) {
            if (this._lineType === value) {
                return;
            }
            this._lineType = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "lineColor", {
        get: function () {
            return this._lineColor;
        },
        set: function (value) {
            if (this._lineColor === value) {
                return;
            }
            if (Array.isArray(value)) {
                value = Utils_1.rgbToNumber(value[0], value[1], value[2]);
            }
            var color = 0xffffff;
            if (!isNaN(value))
                color = Utils_1.hexToInt(value, color);
            this._lineColor = color;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "lineWidth", {
        get: function () {
            return this._lineWidth;
        },
        set: function (value) {
            this._lineWidth = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "lineAlpha", {
        get: function () {
            return this._lineAlpha;
        },
        set: function (value) {
            this._lineAlpha = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "fillAlpha", {
        get: function () {
            return this._fillAlpha;
        },
        set: function (value) {
            this._fillAlpha = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "fillColor", {
        /**
         * 颜色
         */
        get: function () {
            return this._color || this.style.fillColor;
        },
        set: function (value) {
            if (Array.isArray(value[0])) {
                this._color = undefined;
                if (this.canvas === undefined) {
                    this.canvas = document.createElement("canvas");
                    this.context = this.canvas.getContext("2d");
                    this.texture = vf.Texture.from(this.canvas);
                }
                return; // 多颜色渐变，不走color
            }
            this.color = Utils_1.rgbToNumber(value[0], value[1], value[2]);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            if (this._color === value) {
                return;
            }
            var color = undefined;
            color = Utils_1.hexToInt(value, color);
            this._color = color;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "anchorX", {
        /**
         * 锚点，调整位图的坐标中点 0-1
         */
        get: function () {
            return this._anchorX;
        },
        set: function (value) {
            this._anchorX = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GraphBase.prototype, "anchorY", {
        /**
         * 锚点，调整位图的坐标中点 0-1
         */
        get: function () {
            return this._anchorY;
        },
        set: function (value) {
            this._anchorY = value;
            this.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 子类重写
     */
    GraphBase.prototype.drawGraph = function () {
        //
    };
    GraphBase.prototype.release = function () {
        _super.prototype.release.call(this);
        if (this.graphics.parent) {
            this.graphics.parent.removeChild(this.graphics).destroy();
        }
        if (this.canvas) {
            this.canvas.height = this.canvas.width = 0;
            this.context = undefined;
            this.canvas = undefined;
        }
    };
    GraphBase.prototype.updateDisplayList = function (unscaledWidth, unscaledHeight) {
        this.drawGraph();
        _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
    };
    return GraphBase;
}(DisplayObject_1.DisplayObject));
exports.GraphBase = GraphBase;


/***/ }),

/***/ "./src/display/private/GraphicsCore.ts":
/*!*********************************************!*\
  !*** ./src/display/private/GraphicsCore.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphicsCore = void 0;
/**
 * 图形逻辑基类
 */
var GraphicsCore = /** @class */ (function (_super) {
    __extends(GraphicsCore, _super);
    function GraphicsCore(geometry) {
        var _this = _super.call(this, geometry) || this;
        _this._lineType = "full"; //full 实线   dash 虚线
        _this.RatioLine = 3;
        _this.RatioNone = 2;
        return _this;
    }
    GraphicsCore.prototype.lineStyle = function (width, color, alpha, alignment, native, lineType) {
        if (lineType === void 0) { lineType = "full"; }
        this._lineType = lineType;
        return _super.prototype.lineStyle.call(this, width, color, alpha, alignment, native);
    };
    GraphicsCore.prototype.lineTo = function (x, y) {
        if (this._lineType === "full") {
            return _super.prototype.lineTo.call(this, x, y);
        }
        var lineWidth = this._lineStyle.width;
        if (lineWidth <= 0) {
            return this;
        }
        var pointStartX = this.currentPath ? this.currentPath.points[0] : 0;
        var pointStartY = this.currentPath ? this.currentPath.points[1] : 0;
        var ratioLine = this.RatioLine;
        var ratioNone = this.RatioNone;
        var dis = lineWidth * ratioLine;
        var dashDis = lineWidth * ratioNone;
        var totaDis = Math.sqrt(Math.pow(x - pointStartX, 2) + Math.pow(y - pointStartY, 2));
        var scale = lineWidth / totaDis;
        var dashX = pointStartX;
        var dashY = pointStartY;
        var addX = scale * (x - pointStartX) * ratioLine;
        var addY = scale * (y - pointStartY) * ratioLine;
        var addDashX = scale * (x - pointStartX) * (ratioLine + ratioNone);
        var addDashY = scale * (y - pointStartY) * (ratioLine + ratioNone);
        var maxD = totaDis;
        for (var i = 0; i < maxD; i = i + dis + dashDis) {
            var toX = dashX + addX;
            var toY = dashY + addY;
            dashX = dashX + addDashX;
            dashY = dashY + addDashY;
            if (i + dis + dashDis > maxD) {
                dashX = toX = x;
                dashY = toY = y;
            }
            _super.prototype.lineTo.call(this, toX, toY);
            this.moveTo(dashX, dashY);
        }
        return this;
    };
    GraphicsCore.prototype.arc = function (cx, cy, radius, startAngle, endAngle, anticlockwise) {
        var startAgl = startAngle * Math.PI / 180;
        var endAgl = endAngle * Math.PI / 180;
        if (this._lineType === "full") {
            if ((startAngle === 0 && endAngle === 360) || (startAngle === 360 && endAngle === 0)) {
                return this.drawCircle(cx, cy, radius);
            }
            return _super.prototype.arc.call(this, cx, cy, radius, startAgl, endAgl, anticlockwise);
        }
        var lineWidth = this._lineStyle.width;
        if (lineWidth <= 0) {
            return this;
        }
        var startA = startAgl;
        var totalNum = radius * (Math.abs(endAgl - startAgl) / (Math.PI * 2));
        for (var i = 0; i < totalNum; i++) {
            var endA = (endAgl - startAgl) / (totalNum * 2) + startA;
            _super.prototype.arc.call(this, cx, cy, radius, startA, endA, anticlockwise);
            startA = startA + (endAgl - startAgl) / totalNum;
            var endX = cx + Math.cos(startA) * radius;
            var endY = cy + Math.sin(startA) * radius;
            _super.prototype.moveTo.call(this, endX, endY);
        }
        return this;
    };
    /**
     * 画椭圆
    */
    GraphicsCore.prototype.drawEllipse = function (xx, yy, width, height) {
        if (this._lineType === "full") {
            return _super.prototype.drawEllipse.call(this, xx, yy, width, height);
        }
        var lineWidth = this._lineStyle.width;
        if (lineWidth <= 0) {
            return this;
        }
        var w = width * 2;
        var h = height * 2;
        var x = xx - (w / 2);
        var y = yy - (h / 2);
        var kappa = 0.5522848;
        var ox = (w / 2) * kappa; // control point offset horizontal
        var oy = (h / 2) * kappa; // control point offset vertical
        var xe = x + w; // x-end
        var ye = y + h; // y-end
        var xm = x + (w / 2); // x-middle
        var ym = y + (h / 2); // y-middle
        _super.prototype.moveTo.call(this, x, ym);
        this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
        this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
        this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
        return this;
    };
    /**
     * 圆角矩形
     */
    GraphicsCore.prototype.drawRoundedRect = function (x, y, width, height, radius) {
        if (this._lineType === "full") {
            return _super.prototype.drawRoundedRect.call(this, x, y, width, height, radius);
        }
        var lineWidth = this._lineStyle.width;
        if (lineWidth <= 0) {
            return this;
        }
        var maxRadius = Math.min(width, height) / 2 | 0;
        radius = radius > maxRadius ? maxRadius : radius;
        var w = radius * 2;
        var h = radius * 2;
        var kappa = 0.5522848;
        var xe = x + width; // x-end
        var ye = y + height; // y-end
        var ox = radius * kappa; // control point offset horizontal
        var oy = radius * kappa; // control point offset vertical
        var pI = Math.PI;
        _super.prototype.moveTo.call(this, x + radius, y);
        this.lineTo(x + width - radius, y);
        this.bezierCurveTo(xe - radius + ox, y, xe, y + oy, xe, y + radius);
        this.lineTo(xe, ye - radius);
        this.bezierCurveTo(xe, ye - radius + oy, xe - radius + ox, ye, xe - radius, ye);
        this.lineTo(x + radius, ye);
        this.bezierCurveTo(x + radius - ox, ye, x, ye - radius + oy, x, ye - radius);
        this.lineTo(x, y + radius);
        this.bezierCurveTo(x, y + radius - oy, x + radius - ox, y, x + radius, y);
        return this;
    };
    /**
     * 闭合路线
     */
    GraphicsCore.prototype.drawPolygonOne = function (path, closeStroke) {
        if (closeStroke === void 0) { closeStroke = true; }
        if (this._lineType === "full") {
            var points = [];
            for (var i = 0; i < path.length; i++) {
                points.push(path[i].x, path[i].y);
            }
            var pt = { points: points, closeStroke: closeStroke };
            return _super.prototype.drawPolygon.call(this, pt);
        }
        var lineWidth = this._lineStyle.width;
        if (lineWidth <= 0) {
            return this;
        }
        var startPoint = path[0]; // 闭合回归到第0个点
        this.moveTo(startPoint.x, startPoint.y);
        for (var i = 0; i < path.length; i++) {
            var item = path[i];
            this.lineTo(item.x, item.y);
        }
        if (closeStroke) {
            this.lineTo(startPoint.x, startPoint.y);
        }
        return this;
    };
    /**
     * 判断一个点是否在贝塞尔曲线上
     * B_{3}(t) = (1 - t)^3P_0 + 3t(1 - t)^2P_1 + 3t^2(1 - t)P_2 + t^3P_3 , t  in[0, 1]
     *
     * (x3-3*x2+3*x1-x0)t^3 + (3*x2-6*x1+3*x0)t^2 + (3*x1-3*x0)t + x0
     *
     * cpX cpY 控制点一
     * cpX2 cpY2 控制点二
     * toX toY 曲线目标点
     * fromX fromY 曲线起始点
     * x y 当前点
     */
    GraphicsCore.prototype.checOnkBezier = function (cpX, cpY, cpX2, cpY2, toX, toY, fromX, fromY, x, y) {
        var start = 0.0;
        var end = 1.0;
        var half = 0.5;
        var A = toX - 3 * cpX2 + 3 * cpX - fromX;
        var B = 3 * cpX2 - 6 * cpX + 3 * fromX;
        var C = 3 * cpX - 3 * fromX;
        var D = fromX;
        var fStart;
        var fHalf;
        var yEnd = 0;
        var index = 0;
        while (Math.abs(A * Math.pow(half, 3) + B * half * half + C * half + D - x) > 1) {
            fStart = A * Math.pow(start, 3) + B * start * start + C * start + D - x;
            fHalf = A * Math.pow(half, 3) + B * half * half + C * half + D - x;
            index++;
            if (fStart * fHalf < 0) {
                end = half;
                half = (start + half) * 0.5;
            }
            else {
                start = half;
                half = (half + end) * 0.5;
            }
            if (index >= 10) { //错误点
                break;
            }
        }
        var nt = 1 - half;
        yEnd = Math.round(fromY * Math.pow(nt, 3) + 3 * Math.pow(nt, 2) * half * cpY + 3 * half * half * nt * cpY2 + toY * Math.pow(nt, 3));
        if (Math.abs(yEnd - y) <= Math.ceil(this._lineStyle.width * 0.5)) { //灵敏度  目前按照线条宽度
            return nt;
        }
        return -1;
    };
    /**
     *
     */
    GraphicsCore.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY) {
        if (this._lineType === "full") {
            return _super.prototype.quadraticCurveTo.call(this, cpX, cpY, toX, toY);
        }
        var lineWidth = this._lineStyle.width;
        if (lineWidth <= 0) {
            return this;
        }
        var p = this.currentPath.points;
        //取得曲线上点的数组
        var bPoints = this.quadPointLength(p[p.length - 2], p[p.length - 1], cpX, cpY, toX, toY);
        //取得区间近似长度
        var totalLength = this.bezierLength(bPoints);
        //获取虚线曲线数据
        var dashPointList = this.bezierToLineData(bPoints, totalLength);
        //画虚线
        _super.prototype.moveTo.call(this, p[p.length - 2], p[p.length - 1]);
        this.drawBezierDash(dashPointList);
        _super.prototype.moveTo.call(this, toX, toY);
        return this;
    };
    /**
     * 贝塞尔曲线
     */
    GraphicsCore.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY) {
        if (this._lineType === "full") {
            return _super.prototype.bezierCurveTo.call(this, cpX, cpY, cpX2, cpY2, toX, toY);
        }
        var lineWidth = this._lineStyle.width;
        if (lineWidth <= 0) {
            return this;
        }
        var p = this.currentPath.points;
        //取得曲线上点的数组
        var bPoints = this.bezierPointLength(p[p.length - 2], p[p.length - 1], cpX, cpY, cpX2, cpY2, toX, toY);
        //取得区间近似长度
        var totalLength = this.bezierLength(bPoints);
        //获取虚线曲线数据
        var dashPointList = this.bezierToLineData(bPoints, totalLength);
        //画虚线
        this.moveTo(p[p.length - 2], p[p.length - 1]);
        this.drawBezierDash(dashPointList);
        this.moveTo(toX, toY);
        return this;
    };
    GraphicsCore.prototype.drawBezierDash = function (dashPointList) {
        //画虚线
        for (var i = 0; i < dashPointList.length; i++) {
            var item = dashPointList[i];
            var point = item.point;
            if (item.type === false) {
                _super.prototype.moveTo.call(this, point.x, point.y);
            }
            else {
                _super.prototype.lineTo.call(this, point.x, point.y);
            }
        }
    };
    /**
    * 获取二阶贝塞尔曲线点信息(近似值 ， n越大值越准确)
    */
    GraphicsCore.prototype.quadPointLength = function (fromX, fromY, cpX, cpY, toX, toY, n) {
        if (n === void 0) { n = 30; }
        var t = 0.0;
        var xa = 0;
        var ya = 0;
        var x = 0.0;
        var y = 0.0;
        var points = [new vf.Point(fromX, fromY)];
        for (var i = 1; i <= n; ++i) {
            t = i / n;
            xa = fromX + ((cpX - fromX) * t);
            ya = fromY + ((cpY - fromY) * t);
            x = xa + (((cpX + ((toX - cpX) * t)) - xa) * t);
            y = ya + (((cpY + ((toY - cpY) * t)) - ya) * t);
            points.push(new vf.Point(x, y));
        }
        return points;
    };
    /**
     * 获取三阶贝塞尔曲线点信息(近似值 ， n越大值越准确)
     */
    GraphicsCore.prototype.bezierPointLength = function (fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n) {
        if (n === void 0) { n = 30; }
        var t = 0.0;
        var t2 = 0.0;
        var t3 = 0.0;
        var nt = 0.0;
        var nt2 = 0.0;
        var nt3 = 0.0;
        var x = 0.0;
        var y = 0.0;
        var points = [new vf.Point(fromX, fromY)];
        for (var i = 1; i <= n; ++i) {
            t = i / n;
            t2 = t * t;
            t3 = t2 * t;
            nt = (1.0 - t);
            nt2 = nt * nt;
            nt3 = nt2 * nt;
            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);
            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);
            points.push(new vf.Point(x, y));
        }
        return points;
    };
    /**
     * 根据点取长度
     */
    GraphicsCore.prototype.bezierLength = function (points) {
        if (!points || points.length <= 0) {
            return 0;
        }
        var result = 0.0;
        var x = 0.0;
        var y = 0.0;
        var dx = 0.0;
        var dy = 0.0;
        var prevX = points[0].x;
        var prevY = points[0].y;
        for (var i = 0; i < points.length; i++) {
            x = points[i].x;
            y = points[i].y;
            dx = prevX - x;
            dy = prevY - y;
            prevX = x;
            prevY = y;
            result += Math.sqrt((dx * dx) + (dy * dy));
        }
        return result;
    };
    GraphicsCore.prototype.bezierToLineData = function (points, length, oldLength, oldlineS) {
        if (oldLength === void 0) { oldLength = 0; }
        if (oldlineS === void 0) { oldlineS = true; }
        var lineWidth = this._lineStyle.width;
        var ratioLine = this.RatioLine;
        var ratioNone = this.RatioNone;
        var dis = lineWidth * ratioLine;
        var dashDis = lineWidth * ratioNone;
        var pointOld = points[0];
        var index = 1;
        var result = [];
        var oldX = oldLength; //当前状态剩余长度 //oldLength 外部传入用于以后两条线衔接处计算
        var lineS = oldlineS;
        while (index < points.length) { //转折处算两条线
            var nextPoint = points[index];
            var distanse = this.pointDistance(nextPoint, pointOld);
            var curL = (oldX > 0 ? oldX : (lineS ? dis : dashDis));
            var l = distanse - (curL);
            if (l >= 0) {
                // 当前线段够长了
                var b = pointOld;
                var end = points[index];
                var scale = (curL) / distanse;
                var x = b.x + (end.x - b.x) * scale;
                var y = b.y + (end.y - b.y) * scale;
                var p = new vf.Point(x, y);
                result.push({ type: lineS, point: p });
                oldX = 0;
                pointOld = p;
                lineS = !lineS;
            }
            else {
                pointOld = points[index];
                index++;
                oldX = Math.abs(l);
                if (index >= points.length) {
                    result.push({ type: lineS, point: pointOld });
                    break;
                }
            }
        }
        return result;
    };
    GraphicsCore.prototype.pointDistance = function (pointA, pointB) {
        var dx = pointB.x - pointA.x;
        var dy = pointB.y - pointA.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    /**
     * 获取线段起始位置或者终止位置角度
     */
    GraphicsCore.prototype.getLineRotation = function (lineTyle, isBeignPoint, fromX, fromY, toX, toY, cpX, cpY, cpX2, cpY2) {
        if (cpX === void 0) { cpX = 0; }
        if (cpY === void 0) { cpY = 0; }
        if (cpX2 === void 0) { cpX2 = 0; }
        if (cpY2 === void 0) { cpY2 = 0; }
        if (lineTyle === "M") {
            return 0;
        }
        var beginPoint;
        var endPoint;
        var bPoints = [];
        switch (lineTyle) {
            case "L":
                if (isBeignPoint) {
                    beginPoint = new vf.Point(toX, toY);
                    endPoint = new vf.Point(fromX, fromY);
                }
                else {
                    beginPoint = new vf.Point(fromX, fromY);
                    endPoint = new vf.Point(toX, toY);
                }
                break;
            case "Q":
            case "C":
                //取得曲线上点的数组
                if (lineTyle === "Q") {
                    bPoints = this.quadPointLength(fromX, fromY, cpX, cpY, toX, toY);
                }
                else {
                    bPoints = this.bezierPointLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY);
                }
                if (isBeignPoint) {
                    beginPoint = new vf.Point(bPoints[1].x, bPoints[1].y);
                    endPoint = new vf.Point(fromX, fromY);
                }
                else {
                    beginPoint = new vf.Point(bPoints[bPoints.length - 2].x, bPoints[bPoints.length - 2].y);
                    endPoint = new vf.Point(toX, toY);
                }
                break;
        }
        var x = endPoint.x - beginPoint.x;
        var y = endPoint.y - beginPoint.y;
        if (y > 0) {
            return -(Math.atan(x / y));
        }
        else if (y === 0) {
            return (Math.PI + Math.atan(x / y));
        }
        else if (y < 0) {
            return Math.PI - Math.atan(x / y);
        }
        return 0;
    };
    return GraphicsCore;
}(vf.Graphics));
exports.GraphicsCore = GraphicsCore;


/***/ }),

/***/ "./src/display/private/HtmlInput.ts":
/*!******************************************!*\
  !*** ./src/display/private/HtmlInput.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 私有的，由于VFJS不支持文本输入，这里以HTML方式实现
 */
var HtmlInput = /** @class */ (function (_super) {
    __extends(HtmlInput, _super);
    function HtmlInput(multiline) {
        var _this = _super.call(this) || this;
        _this._selection = [0, 0];
        _this._restrictValue = '';
        console.log("创建HtmlInput");
        _this._domInput = _this.addDom(multiline);
        _this.visible = false;
        document.body.appendChild(_this._domInput);
        return _this;
    }
    Object.defineProperty(HtmlInput.prototype, "domInput", {
        get: function () {
            return this._domInput;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HtmlInput.prototype, "visible", {
        get: function () {
            if (this._domInput.style.display === 'block')
                return true;
            return false;
        },
        set: function (value) {
            this._domInput.style.display = value ? 'block' : 'none';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HtmlInput.prototype, "value", {
        get: function () {
            return this._domInput.value;
        },
        set: function (value) {
            this._domInput.value = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HtmlInput.prototype, "placeholder", {
        set: function (value) {
            this._domInput.placeholder = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HtmlInput.prototype, "disabled", {
        set: function (value) {
            this._domInput.disabled = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HtmlInput.prototype, "maxlength", {
        get: function () {
            return this._domInput.maxLength;
        },
        set: function (value) {
            this._domInput.maxLength = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HtmlInput.prototype, "restrict", {
        /* 输入郑泽斌表达式 */
        get: function () {
            return this._restrictRegex;
        },
        set: function (regex) {
            if (regex === undefined) {
                return;
            }
            if (regex instanceof RegExp) {
                var str = regex.toString().slice(1, -1);
                if (str.charAt(0) !== '^')
                    str = '^' + str;
                if (str.charAt(str.length - 1) !== '$')
                    str = str + '$';
                regex = new RegExp(str);
            }
            else {
                regex = new RegExp('^[' + regex + ']*$');
            }
            this._restrictRegex = regex;
        },
        enumerable: false,
        configurable: true
    });
    HtmlInput.prototype.setStyle = function (style) {
        for (var key in style) {
            this._domInput.style[key] = style[key];
        }
        //this._domInput.setAttribute("style", stylestr);
    };
    HtmlInput.prototype.setStyleValue = function (key, value) {
        this._domInput.style[key] = value;
    };
    HtmlInput.prototype.select = function () {
        this._domInput.select();
    };
    /** 测量，需要对象添加到body中 */
    HtmlInput.prototype.getDOMInputBounds = function () {
        var orgTransform = this._domInput.style.transform;
        var orgDisplay = this._domInput.style.display;
        this._domInput.style.transform = '';
        this._domInput.style.display = 'block';
        var bounds = this._domInput.getBoundingClientRect();
        this._domInput.style.transform = orgTransform;
        this._domInput.style.display = orgDisplay;
        return bounds;
    };
    HtmlInput.prototype.updatePostion = function (top, left, transform, opacity) {
        this._domInput.style.top = top + 'px';
        this._domInput.style.left = left + 'px';
        this._domInput.style.transform = transform;
        if (opacity)
            this._domInput.style.opacity = opacity.toString();
    };
    HtmlInput.prototype.addDom = function (multiline) {
        if (multiline) {
            this._domInput = document.createElement('textarea');
            this._domInput.style.resize = 'none';
        }
        else {
            this._domInput = document.createElement('input');
            this._domInput.type = 'text';
        }
        this.addEvent();
        document.body.appendChild(this._domInput);
        return this._domInput;
    };
    HtmlInput.prototype.removeDom = function () {
        if (this._domInput) {
            document.body.removeChild(this._domInput);
        }
    };
    HtmlInput.prototype.release = function () {
        this.removeDom();
        this.removeEvent();
        this.removeAllListeners();
        this._domInput = undefined;
        this._restrictRegex = undefined;
    };
    HtmlInput.prototype.addEvent = function () {
        if (this._onInputKeyDownBind) {
            return;
        }
        this._onInputKeyDownBind = this._onInputKeyDown.bind(this);
        this._onInputInputBind = this._onInputInput.bind(this);
        this._onInputKeyUpBind = this._onInputKeyUp.bind(this);
        this._onFocusedBind = this._onFocused.bind(this);
        this._onBlurredBind = this._onBlurred.bind(this);
        this._domInput.addEventListener('keydown', this._onInputKeyDownBind, { passive: false });
        this._domInput.addEventListener('input', this._onInputInputBind, { passive: false });
        this._domInput.addEventListener('keyup', this._onInputKeyUpBind, { passive: false });
        this._domInput.addEventListener('focus', this._onFocusedBind, { passive: false });
        this._domInput.addEventListener('blur', this._onBlurredBind, { passive: false });
    };
    HtmlInput.prototype.removeEvent = function () {
        if (this._onInputKeyDownBind) {
            this._domInput.removeEventListener('keydown', this._onInputKeyDownBind);
            this._domInput.removeEventListener('input', this._onInputInputBind);
            this._domInput.removeEventListener('keyup', this._onInputKeyUpBind);
            this._domInput.removeEventListener('focus', this._onFocusedBind);
            this._domInput.removeEventListener('blur', this._onBlurredBind);
            this._onInputKeyDownBind = undefined;
            this._onInputInputBind = undefined;
            this._onInputKeyUpBind = undefined;
            this._onFocusedBind = undefined;
            this._onBlurredBind = undefined;
        }
    };
    HtmlInput.prototype._applyRestriction = function () {
        if (this._restrictRegex) {
            if (this._restrictRegex.test(this.value)) {
                this._restrictValue = this.value;
            }
            else {
                this.value = this._restrictValue;
                this._domInput.setSelectionRange(this._selection[0], this._selection[1]);
            }
        }
    };
    HtmlInput.prototype._onInputKeyDown = function (e) {
        this._selection = [
            this._domInput.selectionStart || 0,
            this._domInput.selectionEnd || 0
        ];
        this.emit("keydown" /* keydown */, this, e.keyCode);
        //e.preventDefault();
    };
    HtmlInput.prototype._onInputInput = function (e) {
        if (e.data != null) {
            if (this._restrictRegex)
                this._applyRestriction();
        }
        this.emit("input" /* input */, this.value);
        e.preventDefault();
    };
    HtmlInput.prototype._onInputKeyUp = function (e) {
        this.emit("keyup" /* keyup */, this.value);
        e.preventDefault();
    };
    HtmlInput.prototype._onFocused = function (e) {
        this.emit('focus');
        e.preventDefault();
    };
    HtmlInput.prototype._onBlurred = function (e) {
        this.emit('blur');
        e.preventDefault();
    };
    HtmlInput.prototype.focus = function () {
        document.body.removeChild(this._domInput);
        document.body.appendChild(this._domInput);
        this._domInput.focus();
    };
    HtmlInput.prototype.blur = function () {
        this._domInput.blur();
    };
    return HtmlInput;
}(vf.utils.EventEmitter));
exports.default = HtmlInput;


/***/ }),

/***/ "./src/display/private/InputBase.ts":
/*!******************************************!*\
  !*** ./src/display/private/InputBase.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputBase = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Index_1 = __webpack_require__(/*! ../../interaction/Index */ "./src/interaction/Index.ts");
/**
 * 输入对象的基础类
 */
var InputBase = /** @class */ (function (_super) {
    __extends(InputBase, _super);
    function InputBase() {
        var _this = _super.call(this) || this;
        _this.clickEvent = new Index_1.ClickEvent(_this, true);
        _this._currentState = "up";
        _this._focused = false;
        _this._useTab = true;
        _this._usePrev = true;
        _this._useNext = true;
        _this._down = false;
        _this._useMoveEvent = false;
        //this.container.interactive = true;
        _this.container.interactiveChildren = false;
        // this.on(TouchMouseEvent.onMove,this.onMove,this);   默认不监听move，可使用 moveEvent = true开启
        _this.on(Index_1.TouchMouseEvent.onHover, _this.onHover, _this);
        _this.on(Index_1.TouchMouseEvent.onPress, _this.onPress, _this);
        _this.on(Index_1.TouchMouseEvent.onClick, _this.onClick, _this);
        return _this;
    }
    Object.defineProperty(InputBase.prototype, "interactabled", {
        /** 是否开启鼠标或触摸点击，开启后，接收TouchMouseEvent */
        get: function () {
            return true;
        },
        set: function (value) {
            console.warn('Button cannot be set "interactabled" property');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InputBase.prototype, "currentState", {
        get: function () {
            return this._currentState;
        },
        set: function (value) {
            if (this._currentState == value) {
                return;
            }
            this._currentState = value;
            this.emit(Index_1.ComponentEvent.STATE_CHANGE, this, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InputBase.prototype, "clickSound", {
        get: function () {
            return this._clickSound;
        },
        set: function (value) {
            if (this._clickSound === value) {
                return;
            }
            this._clickSound = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InputBase.prototype, "double", {
        get: function () {
            return this.clickEvent.double;
        },
        set: function (value) {
            this.clickEvent.double = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InputBase.prototype, "useMoveEvent", {
        get: function () {
            return this._useMoveEvent;
        },
        set: function (value) {
            if (this._useMoveEvent !== value) {
                this._useMoveEvent = value;
                if (value) {
                    this.on(Index_1.TouchMouseEvent.onMove, this.onMove, this);
                }
                else {
                    this.off(Index_1.TouchMouseEvent.onMove, this.onMove, this);
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    InputBase.prototype.onMove = function () {
        if (this._down) {
            return;
        }
        this.currentState = "move";
    };
    //e: InteractionEvent,thisObj: DisplayObject,over: boolean
    InputBase.prototype.onHover = function () {
        if (this._down) {
            return;
        }
        this.currentState = "up";
    };
    InputBase.prototype.onPress = function (e, thisObj, isPress) {
        this._down = isPress;
        if (isPress) {
            this.focus();
            this.currentState = "down";
        }
        else {
            this.currentState = "up";
        }
    };
    InputBase.prototype.onClick = function (e) {
        if (this._clickSound) {
            this.emit(Index_1.ComponentEvent.PLAY_AUDIO, { name: this._clickSound, mode: 'effect' });
        }
    };
    InputBase.prototype.keyDownEvent = function (event) {
        var e = event;
        if (e.which === 9) {
            if (this._useTab) {
                Index_1.InputController.fireTab();
                e.preventDefault();
            }
        }
        else if (e.which === 38) {
            if (this._usePrev) {
                Index_1.InputController.firePrev();
                e.preventDefault();
            }
        }
        else if (e.which === 40) {
            if (this._useNext) {
                Index_1.InputController.fireNext();
                e.preventDefault();
            }
        }
    };
    InputBase.prototype.documentMouseDown = function () {
        if (this.currentState !== "down") {
            this.blur();
        }
    };
    InputBase.prototype._bindEvents = function () {
        if (this.stage) {
            this.stage.on("pointerdown", this.documentMouseDown, this);
            this.keyDownEventBind = this.keyDownEvent.bind(this);
            document.addEventListener("keydown", this.keyDownEventBind);
        }
    };
    InputBase.prototype._clearEvents = function () {
        if (this.stage) {
            this.stage.off("pointerdown", this.documentMouseDown, this);
            document.removeEventListener("keydown", this.keyDownEventBind);
        }
    };
    InputBase.prototype.focus = function () {
        if (!this._focused) {
            this._focused = true;
            this._bindEvents();
            Index_1.InputController.set(this);
            this.emit("focusChanged", true);
            this.emit("focus");
        }
    };
    InputBase.prototype.blur = function () {
        if (this._focused) {
            Index_1.InputController.clear();
            this._focused = false;
            this._clearEvents();
            this.emit("focusChanged", false);
            this.emit("blur");
        }
    };
    InputBase.prototype.release = function () {
        this.clickEvent && this.clickEvent.remove();
        this.clickEvent = undefined;
        this.off(Index_1.TouchMouseEvent.onMove, this.onMove, this);
        this.off(Index_1.TouchMouseEvent.onHover, this.onHover, this);
        this.off(Index_1.TouchMouseEvent.onPress, this.onPress, this);
        this.off(Index_1.TouchMouseEvent.onClick, this.onClick, this);
        if (this.keyDownEventBind)
            document.removeEventListener("keydown", this.keyDownEventBind);
        if (this.documentMouseDown && this.stage)
            this.stage.off("pointerdown", this.documentMouseDown, this);
        _super.prototype.release.call(this);
    };
    InputBase.prototype.setTabIndex = function (index, group) {
        this._tabIndex = index;
        this._tabGroup = group;
        if (index !== undefined && group !== undefined) {
            Index_1.InputController.registrer(this, index, group);
        }
    };
    return InputBase;
}(DisplayObject_1.DisplayObject));
exports.InputBase = InputBase;


/***/ }),

/***/ "./src/display/private/selectedBounds.ts":
/*!***********************************************!*\
  !*** ./src/display/private/selectedBounds.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectedBounds = exports.BoundsEventType = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../../core/DisplayObject */ "./src/core/DisplayObject.ts");
var UI_1 = __webpack_require__(/*! ../../UI */ "./src/UI.ts");
var Container_1 = __webpack_require__(/*! ../Container */ "./src/display/Container.ts");
var Graphics_1 = __webpack_require__(/*! ../Graphics */ "./src/display/Graphics.ts");
var Rect_1 = __webpack_require__(/*! ../Rect */ "./src/display/Rect.ts");
var BoundsEventType;
(function (BoundsEventType) {
    BoundsEventType["boundsScale"] = "boundsScale";
    BoundsEventType["boundsAngle"] = "boundsAngle";
    BoundsEventType["selectedBoundsClicked"] = "selectedBoundsClicked";
})(BoundsEventType = exports.BoundsEventType || (exports.BoundsEventType = {}));
var SelectedBounds = /** @class */ (function (_super) {
    __extends(SelectedBounds, _super);
    function SelectedBounds() {
        var _this = _super.call(this) || this;
        _this._bounds = new vf.Rectangle();
        _this.addSelectedShapeRect();
        _this.interactabled = true;
        _this.container.hitArea = new vf.Rectangle(0, 0, 2000, 2000);
        _this.on('move', _this.onMove);
        _this._lastPos = new vf.Point();
        return _this;
    }
    SelectedBounds.prototype.onMove = function (e) {
        var _a, _b;
        if (this._selectedRect && this._boundsRect) {
            var pos = this.container.toLocal(e.data.global);
            var len = UI_1.Utils.pointDistance(this._lastPos, pos);
            if (len < 10)
                return;
            var offx = this._lastPos.x - pos.x;
            var offy = this._lastPos.y - pos.y;
            switch (parseInt(this._selectedRect.id)) {
                case 0:
                    {
                        //缩放
                        var scaleX = (this._bounds.width + offx) / this._bounds.width;
                        var scaleY = (this._bounds.height + offy) / this._bounds.height;
                        this.emit(BoundsEventType.boundsScale, scaleX, scaleY);
                    }
                    break;
                case 1:
                    {
                        var scaleY = (this._bounds.height + offy) / this._bounds.height;
                        this.emit(BoundsEventType.boundsScale, 1, scaleY);
                    }
                    break;
                case 2:
                    {
                        var scaleX = (this._bounds.width - offx) / this._bounds.width;
                        var scaleY = (this._bounds.height + offy) / this._bounds.height;
                        this.emit(BoundsEventType.boundsScale, scaleX, scaleY);
                    }
                    break;
                case 3:
                    {
                        var scaleX = (this._bounds.width - offx) / this._bounds.width;
                        this.emit(BoundsEventType.boundsScale, scaleX, 1);
                    }
                    break;
                case 4:
                    {
                        var scaleX = (this._bounds.width - offx) / this._bounds.width;
                        var scaleY = (this._bounds.height - offy) / this._bounds.height;
                        this.emit(BoundsEventType.boundsScale, scaleX, scaleY);
                    }
                    break;
                case 5:
                    {
                        var scaleY = (this._bounds.height - offy) / this._bounds.height;
                        this.emit(BoundsEventType.boundsScale, 1, scaleY);
                    }
                    break;
                case 6:
                    {
                        var scaleX = (this._bounds.width + offx) / this._bounds.width;
                        var scaleY = (this._bounds.height - offy) / this._bounds.height;
                        this.emit(BoundsEventType.boundsScale, scaleX, scaleY);
                    }
                    break;
                case 7:
                    {
                        var scaleX = (this._bounds.width + offx) / this._bounds.width;
                        this.emit(BoundsEventType.boundsScale, scaleX, 1);
                    }
                    break;
                case 8:
                    {
                        // let offy = pos.y - (this._uiContainer as any).y;
                        // let offx = pos.x - (this._uiContainer as any).x;
                        // let angle = Math.tan(offy / offx) * 180 / Math.PI;
                        // console.log(angle);
                        // this.emit('boundsAngle', angle);
                        var origin_1 = new vf.Point((_a = this._uiContainer) === null || _a === void 0 ? void 0 : _a.x, (_b = this._uiContainer) === null || _b === void 0 ? void 0 : _b.y);
                        var angle = this.measureAngle(origin_1, this._lastPos, pos);
                        this.emit(BoundsEventType.boundsAngle, angle);
                    }
                    break;
                default:
                    break;
            }
            this._lastPos = pos;
        }
    };
    /**
     * 向量的夹角
     */
    SelectedBounds.prototype.measureAngle = function (origin, point1, point2) {
        var vector1x = origin.x - point1.x;
        var vector1y = origin.y - point1.y;
        var vector2x = origin.x - point2.x;
        var vector2y = origin.y - point2.y;
        var t = ((vector1x) * (vector2x) + (vector1y) * (vector2y)) / (Math.sqrt(Math.pow(vector1x, 2) + Math.pow(vector1y, 2)) * Math.sqrt(Math.pow(vector2x, 2) + Math.pow(vector2y, 2)));
        var angle = Math.acos(t) * 180 / Math.PI;
        if (point2.y > origin.y) {
            if (point2.x > point1.x) {
                angle = 0 - angle;
            }
        }
        else {
            if (point2.x < point1.x) {
                angle = 0 - angle;
            }
        }
        return angle;
    };
    /**
     * 添加选中时的8个小方块
     */
    SelectedBounds.prototype.addSelectedShapeRect = function () {
        var _this = this;
        var container = new Container_1.Container();
        this._uiContainer = container;
        this.addChild(container);
        var boundsRect = new Graphics_1.Graphics();
        this._boundsRect = boundsRect;
        container.addChild(boundsRect);
        var cornerContainer = new Container_1.Container();
        container.addChild(cornerContainer);
        this._cornerContainer = cornerContainer;
        var _loop_1 = function (i) {
            var rect = new Rect_1.Rect();
            rect.width = rect.height = 10;
            rect.anchorX = rect.anchorY = 0.5;
            rect.id = i.toString();
            rect.lineWidth = 1;
            rect.lineColor = 0x000088;
            rect.color = 0xffffff;
            cornerContainer.addChild(rect);
            rect.interactabled = true;
            rect.syncabled = false;
            rect.on('down', function (e) {
                _this._selectedRect = rect;
                _this._lastPos = _this.container.toLocal(e.data.global);
                _this.emit(BoundsEventType.selectedBoundsClicked, true);
            });
            rect.on('up', function () {
                _this._selectedRect = undefined;
                _this.emit(BoundsEventType.selectedBoundsClicked, false);
            });
        };
        for (var i = 0; i < 9; ++i) {
            _loop_1(i);
        }
    };
    SelectedBounds.prototype.getBoundsPosList = function (bounds) {
        var posList = [];
        posList.push(bounds.x);
        posList.push(bounds.y);
        posList.push(bounds.x + bounds.width * 0.5);
        posList.push(bounds.y);
        posList.push(bounds.x + bounds.width);
        posList.push(bounds.y);
        posList.push(bounds.x + bounds.width);
        posList.push(bounds.y + bounds.height * 0.5);
        posList.push(bounds.x + bounds.width);
        posList.push(bounds.y + bounds.height);
        posList.push(bounds.x + bounds.width * 0.5);
        posList.push(bounds.y + bounds.height);
        posList.push(bounds.x);
        posList.push(bounds.y + bounds.height);
        posList.push(bounds.x);
        posList.push(bounds.y + bounds.height * 0.5);
        posList.push(bounds.x + bounds.width * 0.5);
        posList.push(bounds.y - 30);
        return posList;
    };
    /**
     * 显示
     */
    SelectedBounds.prototype.show = function (parent, bounds, scaleX, scaleY, angle, showCorner) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (angle === void 0) { angle = 0; }
        if (showCorner === void 0) { showCorner = true; }
        parent.addChild(this);
        this.update(parent, bounds, scaleX, scaleY, angle, showCorner);
    };
    /**
     * 更新
     */
    SelectedBounds.prototype.update = function (parent, bounds, scaleX, scaleY, angle, showCorner) {
        var _a;
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (angle === void 0) { angle = 0; }
        if (showCorner === void 0) { showCorner = true; }
        if (this.parent !== parent) {
            this.parent && this.parent.removeChild(this);
            parent.addChild(this);
        }
        bounds.x -= bounds.width * (scaleX - 1) * 0.5;
        bounds.y -= bounds.height * (scaleY - 1) * 0.5;
        bounds.width *= scaleX;
        bounds.height *= scaleY;
        if (this._uiContainer) {
            this._uiContainer.x = bounds.x + bounds.width * 0.5;
            this._uiContainer.y = bounds.y + bounds.height * 0.5;
        }
        bounds.x = -bounds.width * 0.5;
        bounds.y = -bounds.height * 0.5;
        this._bounds = bounds;
        //边框
        if (this._boundsRect) {
            var graphic = this._boundsRect.graphics;
            graphic.clear();
            graphic.lineStyle(1, 0x000088, 1, undefined, undefined, 'dash');
            graphic.moveTo(bounds.x, bounds.y);
            graphic.lineTo(bounds.x + bounds.width, bounds.y);
            graphic.lineTo(bounds.x + bounds.width, bounds.y + bounds.height);
            graphic.lineTo(bounds.x, bounds.y + bounds.height);
            graphic.lineTo(bounds.x, bounds.y);
        }
        if (showCorner) {
            this._cornerContainer && (this._cornerContainer.visible = true);
            //角框
            var posList = this.getBoundsPosList(bounds);
            for (var i = 0; i < posList.length; i += 2) {
                var rect = (_a = this._cornerContainer) === null || _a === void 0 ? void 0 : _a._getChildById(i * 0.5 + '');
                rect.x = posList[i];
                rect.y = posList[i + 1];
            }
        }
        else {
            this._cornerContainer && (this._cornerContainer.visible = false);
        }
        this._uiContainer && (this._uiContainer.rotation = angle);
    };
    /**
     * 隐藏
     */
    SelectedBounds.prototype.hide = function () {
        this.parent && this.parent.removeChild(this);
    };
    return SelectedBounds;
}(DisplayObject_1.DisplayObject));
exports.SelectedBounds = SelectedBounds;


/***/ }),

/***/ "./src/enum/FollowLineEnum.ts":
/*!************************************!*\
  !*** ./src/enum/FollowLineEnum.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
;
;


/***/ }),

/***/ "./src/enum/Index.ts":
/*!***************************!*\
  !*** ./src/enum/Index.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TracingEnum = exports.FollowLineEnum = void 0;
var FollowLineEnum = __webpack_require__(/*! ./FollowLineEnum */ "./src/enum/FollowLineEnum.ts");
exports.FollowLineEnum = FollowLineEnum;
var TracingEnum = __webpack_require__(/*! ./TracingEnum */ "./src/enum/TracingEnum.ts");
exports.TracingEnum = TracingEnum;


/***/ }),

/***/ "./src/enum/TracingEnum.ts":
/*!*********************************!*\
  !*** ./src/enum/TracingEnum.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./src/event/ComponentEvent.ts":
/*!*************************************!*\
  !*** ./src/event/ComponentEvent.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WIDTH_CHANGE = exports.PLAY_AUDIO = exports.DROP_TARGET = exports.DRAG_TARGET = exports.DRAG_TARGET_BEFORE = exports.DRAG_MOVE = exports.DRAG_END = exports.DRAG_END_BEFORE = exports.DRAG_START = exports.DRAG_START_BEFORE = exports.DRAG_MOUSELEAVE = exports.DRAG_MOUSEENTER = exports.DRAG_HOVER = exports.DRAG_UP = exports.DRAG_DOWN = exports.CREATION_COMPLETE = exports.MOVE = exports.RESIZE = exports.REMOVEED = exports.ADDED = exports.ADD = exports.LOOP = exports.STATE_CHANGE = exports.COMPLETE = exports.CHANGEING = exports.CHANGE = void 0;
/**
 * 特定属性改变时,通常为了去系统事件区分，UI组件的事件名为大写
 * 1. CheckBox 的 checked 改变时
 * 2. Label 的 text 改变时
 * 3. SpriteAnimated 的 animationName 改变时
 * 4. Button 文字改变
 * 5. ScrollingContainer 拖动改变时
 * 6. Slider 滑动改变后
 * 7. SpriteAnimated 动画改变后
 * 8. ConnectLine 连线完成时
 */
exports.CHANGE = "CHANGE";
/**
 * 状态改变中
 *
 * slider 滑动时
 */
exports.CHANGEING = "CHANGEING";
/**
 * 状态切换完成时
 *
 * 1. SpriteAnimated 每次播放完时，触发(loop = false时)
 * 2. Image 图片加载完成时
 * 3. Slider 滑动完成
 * 4. Timeline  每次播放完时，触发(loop = false时)
 * 5. FollowLine 完成一次划线
 */
exports.COMPLETE = "COMPLETE";
/**
 * 状态发生改变时
 */
exports.STATE_CHANGE = "STATE_CHANGE";
/**
 * 状态切换完成时
 *
 * SpriteAnimated 每次播放完时，，触发(loop = true时)
 */
exports.LOOP = "LOOP";
/**
 * 组件被添加前
 */
exports.ADD = "add";
/**
 * 组件被添加时
 */
exports.ADDED = "added";
/**
 * 组件被移除时
 */
exports.REMOVEED = "removed";
/**
 * 组件大小改变后
 */
exports.RESIZE = "RESIZE";
/**
 * 组件位置移动
 */
exports.MOVE = "MOVE";
/**
 * 组件创建完成后
 */
exports.CREATION_COMPLETE = "CREATION_COMPLETE";
/**
 * 拖拽组件按下
 */
exports.DRAG_DOWN = "DRAG_DOWN";
/**
 * 拖拽组件按下
 */
exports.DRAG_UP = "DRAG_UP";
/**
 * 拖拽组件hover
 */
exports.DRAG_HOVER = "DRAG_HOVER";
/**
 * 拖拽组件mouseover
 */
exports.DRAG_MOUSEENTER = "DRAG_MOUSEENTER";
/**
 * 拖拽组件mouseleave
 */
exports.DRAG_MOUSELEAVE = "DRAG_MOUSELEAVE";
/**
 * 组件拖动开始之前
 */
exports.DRAG_START_BEFORE = "DRAG_START_BEFORE";
/**
 * 组件拖动开始时
 */
exports.DRAG_START = "DRAG_START";
/**
 * 组件拖动结束之前
 */
exports.DRAG_END_BEFORE = "DRAG_END_BEFORE";
/**
 * 组件拖动结束时 （如果绑定接收容器并拖动到接收容器中，不会触发此事件）
 */
exports.DRAG_END = "DRAG_END";
/**
 * 组件拖动中
 */
exports.DRAG_MOVE = "DRAG_MOVE";
/**
 * 组件拖动到接收目标中之前
 */
exports.DRAG_TARGET_BEFORE = "DRAG_TARGET_BEFORE";
/**
 * 组件拖动到接收目标中
 */
exports.DRAG_TARGET = "DRAG_TARGET";
/**
 * 有拖拽物掉落到此容器时触发
 */
exports.DROP_TARGET = "DROP_TARGET";
/**
 * 播放音效 {name,mode}
 */
exports.PLAY_AUDIO = "PLAY_AUDIO";
/**
 * 组件宽度发生变化(目前文本换行需要用到)
 */
exports.WIDTH_CHANGE = "WIDTH_CHANGE";


/***/ }),

/***/ "./src/event/Index.ts":
/*!****************************!*\
  !*** ./src/event/Index.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenEvent = exports.TouchMouseEvent = exports.InteractionEvent = exports.ComponentEvent = void 0;
var ComponentEvent = __webpack_require__(/*! ./ComponentEvent */ "./src/event/ComponentEvent.ts");
exports.ComponentEvent = ComponentEvent;
var InteractionEvent_1 = __webpack_require__(/*! ./InteractionEvent */ "./src/event/InteractionEvent.ts");
Object.defineProperty(exports, "InteractionEvent", { enumerable: true, get: function () { return InteractionEvent_1.InteractionEvent; } });
//import {KeyEvent} from "./KeyEvent";
var TouchMouseEvent_1 = __webpack_require__(/*! ./TouchMouseEvent */ "./src/event/TouchMouseEvent.ts");
Object.defineProperty(exports, "TouchMouseEvent", { enumerable: true, get: function () { return TouchMouseEvent_1.TouchMouseEvent; } });
var TweenEvent_1 = __webpack_require__(/*! ./TweenEvent */ "./src/event/TweenEvent.ts");
Object.defineProperty(exports, "TweenEvent", { enumerable: true, get: function () { return TweenEvent_1.TweenEvent; } });


/***/ }),

/***/ "./src/event/InteractionEvent.ts":
/*!***************************************!*\
  !*** ./src/event/InteractionEvent.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionEvent = void 0;
var tempLocal = new vf.Point(0, 0);
/**
 * 事件的基础类
 *
 * 触摸或鼠标操作事件 可查看 -> TouchEventEnum.TouchEnum
 *
 * import InteractionEvent from "../interaction/InteractionEvent",
 */
var InteractionEvent = /** @class */ (function (_super) {
    __extends(InteractionEvent, _super);
    function InteractionEvent() {
        var _this = _super.call(this) || this;
        _this.signalling = false;
        _this.local = tempLocal;
        return _this;
    }
    return InteractionEvent;
}(vf.InteractionEvent));
exports.InteractionEvent = InteractionEvent;


/***/ }),

/***/ "./src/event/TouchMouseEvent.ts":
/*!**************************************!*\
  !*** ./src/event/TouchMouseEvent.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TouchMouseEvent = void 0;
/**
 * 对外，封装的点击触摸事件
 *
 * import InteractionEvent,{Mouse} from "../interaction/InteractionEvent",
 */
exports.TouchMouseEvent = {
    /**
     * 移出
     *
     * (e: InteractionEvent,thisObj:DisplayObject,over: boolean)=>{}
     */
    onHover: "hover",
    /**
     * 按下
     *
     * (e: InteractionEvent,thisObj:DisplayObject, isPressed: boolean)=>void
     */
    onPress: "press",
    /**
     * 按下
     */
    onDown: "down",
    /**
     * 弹起
     */
    onUp: "up",
    /**
     * 点击
     *
     * (e: InteractionEvent,thisObj:DisplayObject)=>void
     */
    onClick: "click",
    /**
     * PC 特有，右键点击
     *
     * (e: InteractionEvent,thisObj:DisplayObject)=>void
     */
    onRightDown: "rigthdown",
    /**
     * 移动
     *
     * (e: InteractionEvent,thisObj:DisplayObject)=>void
     */
    onMove: "move",
    /**
     * 鼠标移入
     *
     * (e: InteractionEvent,thisObj:DisplayObject)=>void
     */
    onMouseEnter: "mouseenter",
    /**
     * 鼠标移出
     *
     * (e: InteractionEvent,thisObj:DisplayObject)=>void
     */
    onMouseLeave: "mouseleave"
};


/***/ }),

/***/ "./src/event/TweenEvent.ts":
/*!*********************************!*\
  !*** ./src/event/TweenEvent.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenEvent = void 0;
/**
 * 缓动事件
 */
exports.TweenEvent = {
    /**
     *
     */
    Callback: 'Callback',
    /**
     * 每次改变
     */
    update: 'update',
    /**
     * 完成
     */
    complete: 'complete',
    /**
     * 开始时
     */
    start: 'start',
    /**
     * 每次重复时
     */
    repeat: 'repeat',
    /**
     * 反向时
     */
    reverse: 'reverse',
    /**
     * 暂停时
     */
    pause: 'pause',
    /**
     * 播放时
     */
    play: 'play',
    /**
     * 重新开始时
     */
    restart: 'restart',
    /**
     * 停止时
     */
    stop: 'stop'
};


/***/ }),

/***/ "./src/interaction/AudioGroupController.ts":
/*!*************************************************!*\
  !*** ./src/interaction/AudioGroupController.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.updateAudioGroupStates = exports.unRegistrerAudioGroup = exports.registrerAudioGroup = exports._audioGroupObject = void 0;
var Audio_1 = __webpack_require__(/*! ../display/Audio */ "./src/display/Audio.ts");
exports._audioGroupObject = {
    groups: {},
    values: {}
};
/* 注册分组，用于video组件的分组操作
*
* checkGroups = [key]:{["value"]:cb}
*/
function registrerAudioGroup(cb) {
    var name = cb.audioGroup;
    if (name || name === "") {
        var group = exports._audioGroupObject.groups[name];
        if (!group)
            group = exports._audioGroupObject.groups[name] = {};
        group[cb.uuid.toString()] = cb;
        // if (cb.checked)
        exports._audioGroupObject.values[name] = cb.uuid.toString();
    }
}
exports.registrerAudioGroup = registrerAudioGroup;
/**
 * 注销指定分组或指定分组的子项
 * @param cb video
 */
function unRegistrerAudioGroup(cb) {
    if ((cb.audioGroup || cb.audioGroup === "") && exports._audioGroupObject.groups[cb.audioGroup]) {
        delete exports._audioGroupObject.groups[cb.audioGroup][cb.uuid.toString()];
        var isKey = false;
        for (var key in exports._audioGroupObject.groups[cb.audioGroup]) {
            if (key)
                isKey = true;
            break;
        }
        if (!isKey) {
            delete exports._audioGroupObject.groups[cb.audioGroup];
        }
        // if (cb.checked)
        exports._audioGroupObject.values[cb.audioGroup] = undefined;
    }
}
exports.unRegistrerAudioGroup = unRegistrerAudioGroup;
/** 更新分组中选中的checkbox组件  */
function updateAudioGroupStates(cb) {
    if (cb.audioGroup || cb.audioGroup === "") {
        var group = exports._audioGroupObject.groups[cb.audioGroup];
        for (var val in group) {
            var b = group[val];
            if (b !== cb && b.groupName === cb.groupName) {
                // 不是自己 暂停
                if (b) {
                    if (b.playerStates === Audio_1.PlayerStates.play) {
                        b.stop();
                    }
                    // if (b.playerStates === PlayerStates.end) {
                    //     console.error(" end other ");
                    //     b.stop();
                    // } else {
                    //     console.error(" pausee other ");
                    //     b.pause();
                    // }
                }
            }
        }
        exports._audioGroupObject.values[cb.audioGroup] = cb.uuid.toString();
    }
}
exports.updateAudioGroupStates = updateAudioGroupStates;


/***/ }),

/***/ "./src/interaction/ClickEvent.ts":
/*!***************************************!*\
  !*** ./src/interaction/ClickEvent.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ClickEvent = void 0;
var TouchMouseEvent_1 = __webpack_require__(/*! ../event/TouchMouseEvent */ "./src/event/TouchMouseEvent.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var SyncManager_1 = __webpack_require__(/*! ./SyncManager */ "./src/interaction/SyncManager.ts");
/**
 * 点击触摸相关的事件处理订阅类,UI组件内部可以创建此类实现点击相关操作
 *
 *  可侦听事件:
 * ```
 *  {InteractionEvent}.TouchEvent.onHover
 *  {InteractionEvent}.TouchEvent.onPress
 *  {InteractionEvent}.TouchEvent.onClick
 *  {InteractionEvent}.TouchEvent.onMove
 * ```
 *
 * @example 可查看 `TestSliceSprite` 示例
 *
 * @since 1.0.0
 */
var ClickEvent = /** @class */ (function () {
    /**
     * ClickEvent 构造函数
     * @param obj 调用的显示对象
     * @param includeHover 是否监听鼠标移上与移出，默认true
     * @param rightMouseButton 是否开启鼠标右键点击，默认false
     * @param doubleClick 是否开启鼠标双击,默认false
     */
    function ClickEvent(obj, includeHover, rightMouseButton, doubleClick) {
        this.id = 0;
        /** 是否开启本地坐标转换，开启后，事件InteractionEvent中的localX localY为本地坐标，false情况下为0 */
        this.isOpenLocalPoint = false;
        this.localOffset = new vf.Point();
        this.offset = new vf.Point();
        this.movementX = 0;
        this.movementY = 0;
        this.ishover = false;
        this.mouse = new vf.Point();
        this.bound = false;
        this.right = false;
        this.hover = true;
        this.double = false;
        this.time = 0;
        this.isStop = true;
        this.deviceType = vf.utils.getSystemInfo().device.type;
        this._tempMovePoint = new vf.Point();
        this.obj = obj;
        if (includeHover !== undefined) {
            this.hover = includeHover;
        }
        if (rightMouseButton !== undefined) {
            this.right = rightMouseButton;
            var type = vf.utils.getSystemInfo().device.type;
            if (type === 'tablet' || type === 'mobile') {
                this.right = false;
            }
        }
        if (doubleClick !== undefined) {
            this.double = doubleClick;
        }
        obj.interactive = true;
        this.startEvent();
    }
    ClickEvent.prototype.getTarget = function () {
        return this.obj;
    };
    ClickEvent.prototype.startEvent = function () {
        if (this.isStop) {
            var container = this.obj.container;
            container.on("mousedown" /* mousedown */, this._onMouseDown, this);
            if (this.right) {
                container.on("rightdown" /* mouseRightDown */, this._onMouseRight, this);
            }
            else {
                container.on("touchstart" /* touchstart */, this._onMouseDown, this);
                if (this.hover) {
                    // 信令恢复时需要用到，一端时PC，一端是移动时，所以需要都监听
                    container.on("mouseover" /* mouseover */, this._onMouseOver, this);
                    container.on("mouseout" /* mouseout */, this._onMouseOut, this);
                    if (this.deviceType !== 'pc') {
                        container.on("touchstart" /* touchstart */, this._onMouseOver, this);
                        container.on("touchend" /* touchend */, this._onMouseOut, this);
                        container.on("touchendoutside" /* touchendoutside */, this._onMouseOut, this);
                    }
                }
            }
            this.isStop = false;
        }
    };
    ClickEvent.prototype._onStageTouchOutside = function (e) {
        var _a;
        (_a = this.obj.stage) === null || _a === void 0 ? void 0 : _a.container.off("touchendoutside" /* touchendoutside */, this._onStageTouchOutside, this);
        this._onMouseUpOutside(e);
    };
    ClickEvent.prototype._onMouseRight = function (e) {
        if (this.obj.stage && this.obj.stage.syncInteractiveFlag &&
            (this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onRightDown) > 0)) {
            SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj);
        }
        switch (e.type) {
            case "rightdown" /* mouseRightDown */:
                this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onRightDown, e, true);
                break;
            // case TouchMouseEventEnum.mouseRightup:
            //     break;
            // case TouchMouseEventEnum.mouseRightupoutside:
            //     break;
        }
        if (this.obj.stage && this.obj.stage.originalEventPreventDefault && e.data.originalEvent) {
            e.data.originalEvent.preventDefault();
            e.data.originalEvent.stopImmediatePropagation(); // 移动设备
        }
    };
    /** 清除拖动 */
    ClickEvent.prototype.stopEvent = function () {
        var container = this.obj.container;
        if (this.bound) {
            container.off("mouseup" /* mouseup */, this._onMouseUp, this);
            container.off("mouseupoutside" /* mouseupoutside */, this._onMouseUpOutside, this);
            if (!this.right) {
                container.off("touchend" /* touchend */, this._onMouseUp, this);
                container.off("touchendoutside" /* touchendoutside */, this._onMouseUpOutside, this);
                container.off("touchcancel" /* touchcancel */, this._onMouseUpOutside, this);
            }
            this.bound = false;
        }
        container.off("mousedown" /* mousedown */, this._onMouseDown, this);
        if (this.right) {
            container.off("rightdown" /* mouseRightDown */, this._onMouseRight, this);
        }
        else {
            container.off("touchstart" /* touchstart */, this._onMouseDown, this);
        }
        if (this.hover) {
            container.off("mouseover" /* mouseover */, this._onMouseOver, this);
            container.off("mouseout" /* mouseout */, this._onMouseOut, this);
            container.off("mousemove" /* mousemove */, this._onMouseMove, this);
            container.off("touchmove" /* touchmove */, this._onMouseMove, this);
            container.off("touchstart" /* touchstart */, this._onMouseOver, this);
            container.off("touchend" /* touchend */, this._onMouseOut, this);
            container.off("touchendoutside" /* touchendoutside */, this._onMouseOut, this);
        }
        this.isStop = true;
    };
    ClickEvent.prototype._onMouseDown = function (e) {
        ClickEvent.downObjects.set(this.obj.uuid.toString(), this);
        if (this.obj.stage && this.obj.stage.syncInteractiveFlag &&
            (this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onPress) > 0 ||
                this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onDown) > 0 ||
                this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onClick) > 0)) {
            SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj);
        }
        this.setLocalPoint(e);
        this.mouse.copyFrom(e.data.global);
        this.id = e.data.identifier;
        this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onPress, e, true);
        if (this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onDown) > 0) {
            this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onDown, e, true);
        }
        var container = this.obj.container;
        if (!this.bound) {
            container.on("mouseup" /* mouseup */, this._onMouseUp, this);
            container.on("mouseupoutside" /* mouseupoutside */, this._onMouseUpOutside, this);
            container.on("touchend" /* touchend */, this._onMouseUp, this);
            container.on("touchendoutside" /* touchendoutside */, this._onMouseUpOutside, this);
            container.on("touchcancel" /* touchcancel */, this._onMouseUpOutside, this);
            this.bound = true;
        }
        if (this.double) {
            var now = performance.now();
            if (now - this.time < 210) {
                this.emitTouchEvent('double', e);
            }
            else {
                this.time = now;
            }
        }
        if (this.obj.stage && this.obj.stage.originalEventPreventDefault && e.data.originalEvent) {
            e.data.originalEvent.preventDefault();
            e.data.originalEvent.stopImmediatePropagation(); // 移动设备
        }
    };
    ClickEvent.prototype.emitTouchEvent = function (event, e, args) {
        if (this.obj.listenerCount(event) <= 0) {
            return;
        }
        if (Utils_1.debug) {
            var stage = this.obj.stage;
            if (stage && event !== TouchMouseEvent_1.TouchMouseEvent.onMove) {
                stage.sendToPlayer({
                    code: event,
                    level: "info",
                    target: this.obj,
                    data: [args],
                    action: e.type,
                });
            }
        }
        e.type = event.toString();
        this.obj.emit(e.type, e, this.obj, args);
    };
    ClickEvent.prototype._mouseUpAll = function (e) {
        if (e.data.identifier !== this.id)
            return;
        this.offset.set(e.data.global.x - this.mouse.x, e.data.global.y - this.mouse.y);
        if (this.bound) {
            this.obj.container.off("mouseup" /* mouseup */, this._onMouseUp, this);
            this.obj.container.off("mouseupoutside" /* mouseupoutside */, this._onMouseUpOutside, this);
            this.obj.container.off("touchend" /* touchend */, this._onMouseUp, this);
            this.obj.container.off("touchendoutside" /* touchendoutside */, this._onMouseUpOutside, this);
            this.obj.container.off("touchcancel" /* touchcancel */, this._onMouseUpOutside, this);
            this.bound = false;
        }
        this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onUp, e, false);
        this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onPress, e, false);
    };
    ClickEvent.prototype._onMouseUp = function (e) {
        if (e.data.identifier !== this.id)
            return;
        if (this.obj.stage && this.obj.stage.syncInteractiveFlag &&
            (this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onUp) > 0 ||
                this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onPress) > 0 ||
                this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onClick) > 0)) {
            SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj);
        }
        this._mouseUpAll(e);
        //prevent clicks with scrolling/dragging objects
        if (this.obj.dragThreshold) {
            this.movementX = Math.abs(this.offset.x);
            this.movementY = Math.abs(this.offset.y);
            if (Math.max(this.movementX, this.movementY) > this.obj.dragThreshold)
                return;
        }
        if (!this.double) {
            this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onClick, e, false);
        }
    };
    ClickEvent.prototype._onMouseUpOutside = function (e) {
        if (e.data.identifier !== this.id)
            return;
        if (this.obj.stage && this.obj.stage.syncInteractiveFlag &&
            (this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onUp) > 0 ||
                this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onPress) > 0)) {
            SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj);
        }
        this._mouseUpAll(e);
        if (this.deviceType !== 'pc') { // fix 移动设备按下后，移出组件，无法触发画线
            this.removeAllMove();
        }
    };
    ClickEvent.prototype._onMouseOver = function (e) {
        if (!this.ishover) {
            if (this.obj.stage && this.obj.stage.syncInteractiveFlag && (this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onHover) > 0 || this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onMouseEnter) > 0)) {
                SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj);
            }
            this.ishover = true;
            if (this.obj.container.listeners("mousemove" /* mousemove */).length <= 0) {
                this.obj.container.on("mousemove" /* mousemove */, this._onMouseMove, this);
            }
            if (this.obj.container.listeners("touchmove" /* touchmove */).length <= 0) {
                this.obj.container.on("touchmove" /* touchmove */, this._onMouseMove, this);
            }
            this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onHover, e, true);
            this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onMouseEnter, e);
        }
    };
    ClickEvent.prototype._onMouseOut = function (e) {
        if (this.ishover) {
            if (this.obj.stage && this.obj.stage.syncInteractiveFlag && (this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onHover) > 0 || this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onMouseLeave) > 0)) {
                SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj);
            }
            this.ishover = false;
            if (this.deviceType !== 'pc') { // fix 移动设备按下后，移出组件，无法触发画线
                this.removeAllMove();
            }
            this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onHover, e, false);
            this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onMouseLeave, e);
        }
    };
    ClickEvent.prototype._onMouseMove = function (e) {
        if (this.obj.stage && this.obj.stage.syncInteractiveFlag && (this.obj.listenerCount(TouchMouseEvent_1.TouchMouseEvent.onMove) > 0)) {
            SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj);
        }
        var container = this.obj.container;
        container.toLocal(e.data.global, undefined, this._tempMovePoint);
        if (container.hitArea && container.hitArea.contains(this._tempMovePoint.x, this._tempMovePoint.y)) {
            this.setLocalPoint(e);
            this.emitTouchEvent(TouchMouseEvent_1.TouchMouseEvent.onMove, e);
        }
        if (this.obj.stage && this.obj.stage.originalEventPreventDefault && e.data.originalEvent) {
            e.data.originalEvent.preventDefault();
            e.data.originalEvent.stopImmediatePropagation(); // 移动设备
        }
    };
    ClickEvent.prototype.setLocalPoint = function (e) {
        if (this.isOpenLocalPoint) {
            this.obj.container.toLocal(e.data.global, undefined, this.localOffset);
            e.local = this.localOffset;
        }
    };
    ClickEvent.prototype.removeAllMove = function () {
        ClickEvent.downObjects.forEach(function (value) {
            var obj = value.obj;
            obj.container.off("mousemove" /* mousemove */, value._onMouseMove, value);
            obj.container.off("touchmove" /* touchmove */, value._onMouseMove, value);
        });
        ClickEvent.downObjects.clear();
    };
    ClickEvent.prototype.remove = function () {
        this.stopEvent();
        this.obj.container.interactive = false;
    };
    /** 当前按下状态的所有对象，为了弹起统一做处理 */
    ClickEvent.downObjects = new Map();
    return ClickEvent;
}());
exports.ClickEvent = ClickEvent;


/***/ }),

/***/ "./src/interaction/DragDropController.ts":
/*!***********************************************!*\
  !*** ./src/interaction/DragDropController.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getEventItem = exports.getItem = exports.removeDropTarget = exports.getDropTargets = exports.addDropTarget = exports.remove = exports.add = exports._dropTargets = exports._items = void 0;
/**
 * 记录当前正在拖动的UI组件列表
 * @private
 */
exports._items = [];
exports._dropTargets = []; //拖拽掉落容器列表
/**
 * 添加拖动组件到控制器
 * @param item 要添加的UI组件
 * @param e 传送的事件
 * @returns true|false
 * @since 1.0.0
 */
function add(item, e) {
    item.attach.dragDropEventId = e.data.identifier;
    if (exports._items.indexOf(item) === -1) {
        exports._items.push(item);
        return true;
    }
    return false;
}
exports.add = add;
function remove(item) {
    var index = exports._items.indexOf(item);
    if (index > -1) {
        exports._items.splice(index, 1);
        return true;
    }
    return false;
}
exports.remove = remove;
/**
 * 添加掉落容器
 * @param group
 * @param target
 */
function addDropTarget(group, target) {
    var obj = {
        group: group,
        target: target
    };
    exports._dropTargets.push(obj);
}
exports.addDropTarget = addDropTarget;
/**
 * 获取对应的掉落容器
 * @param group
 */
function getDropTargets(group) {
    var list = [];
    exports._dropTargets.forEach(function (item) {
        if (item.group === group) {
            list.push(item.target);
        }
    });
    return list;
}
exports.getDropTargets = getDropTargets;
function removeDropTarget(target) {
    var index;
    for (var i = 0; i < exports._dropTargets.length; ++i) {
        if (exports._dropTargets[i].target === target) {
            index = i;
            break;
        }
    }
    if (index !== undefined) {
        exports._dropTargets.splice(index, 1);
    }
}
exports.removeDropTarget = removeDropTarget;
/**
 * 获取正在拖动组件
 * @param item 要获取的UI组件
 * @returns flase | item
 */
function getItem(item) {
    var index;
    for (var i = 0; i < exports._items.length; i++) {
        if (exports._items[i] === item) {
            index = i;
            break;
        }
    }
    if (index !== undefined) {
        exports._items.splice(index, 1);
        return item;
    }
    else {
        return false;
    }
}
exports.getItem = getItem;
/**
 * 根据事件对象与分组名获取拖动项
 * @param e 事件对象
 * @param group 分组名
 */
function getEventItem(e, group) {
    var item = null, index;
    var id = e.data.identifier;
    for (var i = 0; i < exports._items.length; i++) {
        if (exports._items[i].attach.dragDropEventId === id) {
            if (group !== exports._items[i].attach.dragGroup && exports._items[i].attach.dragGroup !== "") {
                return false;
            }
            item = exports._items[i];
            index = i;
            break;
        }
    }
    if (index !== undefined) {
        exports._items.splice(index, 1);
        return item;
    }
    else {
        return false;
    }
}
exports.getEventItem = getEventItem;


/***/ }),

/***/ "./src/interaction/DragEvent.ts":
/*!**************************************!*\
  !*** ./src/interaction/DragEvent.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DragEvent = void 0;
var Index_1 = __webpack_require__(/*! ./Index */ "./src/interaction/Index.ts");
var SyncManager_1 = __webpack_require__(/*! ./SyncManager */ "./src/interaction/SyncManager.ts");
/**
 * 多拽相关的事件处理类
 *
 *  可侦听事件:
 * ```
 *  {InteractionEvent}.DraggableEvent.onDragPress
 *  {InteractionEvent}.DraggableEvent.onDragStart
 *  {InteractionEvent}.DraggableEvent.onDragMove
 *  {InteractionEvent}.DraggableEvent.onDragEnd
 * ```
 *  可赋值方法:
 * ```
 * onPress: ((e: InteractionEvent, isPressed: boolean,dragObj?: DragEvent) => void) | undefined;
 * onDragEnd: ((e: InteractionEvent,dragObj?: DragEvent) => void) | undefined
 * onDragMove: ((e: InteractionEvent, offset: vf.Point,dragObj?: DragEvent) => void) | undefined
 * onDragStart: ((e: InteractionEvent,dragObj?: DragEvent) => void) | undefined
 * ```
 *
 * @example 可查看 `Slider` 源码
 *
 * @since 1.0.0
 */
var DragEvent = /** @class */ (function () {
    function DragEvent(obj) {
        this.id = 0;
        this.offset = new vf.Point();
        this.movementX = 0;
        this.movementY = 0;
        this.bound = false;
        this.start = new vf.Point();
        this.mouse = new vf.Point();
        this.cancel = false;
        this.dragging = false;
        this.isStop = true;
        this.ishover = false;
        this.obj = obj;
        obj.interactive = true;
        this.startEvent();
    }
    DragEvent.prototype.startEvent = function () {
        if (this.isStop) {
            this.obj.container.on("mousedown" /* mousedown */, this._onDragStart, this);
            this.obj.container.on("touchstart" /* touchstart */, this._onDragStart, this);
            this.obj.container.on("mouseover" /* mouseover */, this._onDragOver, this);
            this.obj.container.on("mouseout" /* mouseout */, this._onMouseOut, this);
            this.isStop = false;
        }
    };
    DragEvent.prototype.executeAction = function (e) {
        switch (e.type) {
            case Index_1.ComponentEvent.DRAG_START:
                this._onDragStart(e);
                break;
            case Index_1.ComponentEvent.DRAG_MOVE:
                this._onDragMove(e);
                break;
            case Index_1.ComponentEvent.DRAG_END:
                this._onDragEnd(e);
                break;
        }
    };
    DragEvent.prototype._onDragOver = function (e) {
        if (!this.ishover) {
            this.ishover = true;
            this.onDragHover && this.onDragHover.call(this.obj, e, true, this);
        }
    };
    DragEvent.prototype._onMouseOut = function (e) {
        if (this.ishover) {
            this.ishover = false;
            this.onDragHover && this.onDragHover.call(this.obj, e, false, this);
        }
    };
    DragEvent.prototype._onDragStart = function (e) {
        if (this.obj.stage && this.obj.stage.syncInteractiveFlag && (e.type == "mousedown" /* mousedown */ || e.type == "touchstart" /* touchstart */)) {
            SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj);
        }
        if (this.obj.dragStopPropagation && e.data.originalEvent && e.data.originalEvent.stopPropagation) {
            e.data.originalEvent.stopPropagation();
        }
        this.id = e.data.identifier;
        if (e.type == "mousedown" /* mousedown */ || e.type == "touchstart" /* touchstart */) {
            this.onDragPress && this.onDragPress.call(this.obj, e, true, this);
        }
        if (!this.bound && this.obj.parent && this.obj.stage) {
            var stage = this.obj.stage.container;
            this.start.copyFrom(e.data.global);
            stage.off("mousemove" /* mousemove */, this._onDragMove, this);
            stage.off("touchmove" /* touchmove */, this._onDragMove, this);
            stage.on("mousemove" /* mousemove */, this._onDragMove, this);
            stage.on("touchmove" /* touchmove */, this._onDragMove, this);
            stage.on("mouseup" /* mouseup */, this._onDragEnd, this);
            stage.on("mouseupoutside" /* mouseupoutside */, this._onDragEnd, this);
            stage.on("touchend" /* touchend */, this._onDragEnd, this);
            stage.on("touchendoutside" /* touchendoutside */, this._onDragEnd, this);
            stage.on("touchcancel" /* touchcancel */, this._onDragEnd, this);
            //显示对象自身的抬起事件,为了解决显示对象既绑定拖拽事件，又绑定点击事件，且在点击事件有跳转场景操作时，信令恢复会丢失一个up事件  ziye+
            this.obj.container.on("mouseup" /* mouseup */, this._onDragEnd, this);
            this.obj.container.on("touchend" /* touchend */, this._onDragEnd, this);
            this.bound = true;
        }
        if (this.obj.stage &&
            this.obj.stage.originalEventPreventDefault &&
            e.data.originalEvent &&
            e.data.originalEvent.preventDefault) {
            e.data.originalEvent.preventDefault();
        }
    };
    DragEvent.prototype._onDragMove = function (e) {
        if (this.obj.dragStopPropagation && e.data.originalEvent && e.data.originalEvent.stopPropagation) {
            e.data.originalEvent.stopPropagation();
        }
        if (e.data.identifier !== this.id)
            return;
        if (this.obj.stage && this.obj.stage.syncInteractiveFlag && (e.type == "mousemove" /* mousemove */ || e.type == "touchmove" /* touchmove */)) {
            SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj.stage);
        }
        this.mouse.copyFrom(e.data.global);
        this.offset.set(this.mouse.x - this.start.x, this.mouse.y - this.start.y);
        if (!this.dragging) {
            this.movementX = Math.abs(this.offset.x);
            this.movementY = Math.abs(this.offset.y);
            if ((this.movementX === 0 && this.movementY === 0) ||
                Math.max(this.movementX, this.movementY) < this.obj.dragThreshold)
                return; //thresshold
            if (this.dragRestrictAxis !== undefined) {
                this.cancel = false;
                if (this.dragRestrictAxis == "x" && this.movementY > this.movementX)
                    this.cancel = true;
                else if (this.dragRestrictAxis == "y" && this.movementY <= this.movementX)
                    this.cancel = true;
                if (this.cancel) {
                    this._onDragEnd(e);
                    return;
                }
            }
            this.onDragStart && this.onDragStart.call(this.obj, e, this);
            this.dragging = true;
        }
        this.onDragMove && this.onDragMove.call(this.obj, e, this.offset, this);
    };
    DragEvent.prototype._onDragEnd = function (e) {
        if (this.obj.dragStopPropagation && e.stopPropagation)
            e.stopPropagation();
        if (e.data.identifier !== this.id)
            return;
        if (this.obj.stage && this.obj.stage.syncInteractiveFlag &&
            (e.type == "mouseup" /* mouseup */ ||
                e.type == "mouseupoutside" /* mouseupoutside */ ||
                e.type == "touchend" /* touchend */ ||
                e.type == "touchendoutside" /* touchendoutside */ ||
                e.type == "touchcancel" /* touchcancel */)) {
            SyncManager_1.SyncManager.getInstance(this.obj.stage).collectEvent(e, this.obj.stage);
        }
        if (this.bound && this.obj.stage) {
            var stage = this.obj.stage.container;
            stage.off("mousemove" /* mousemove */, this._onDragMove, this);
            stage.off("touchmove" /* touchmove */, this._onDragMove, this);
            stage.off("mouseup" /* mouseup */, this._onDragEnd, this);
            stage.off("mouseupoutside" /* mouseupoutside */, this._onDragEnd, this);
            stage.off("touchend" /* touchend */, this._onDragEnd, this);
            stage.off("touchendoutside" /* touchendoutside */, this._onDragEnd, this);
            stage.off("touchcancel" /* touchcancel */, this._onDragEnd, this);
            this.obj.container.off("mouseup" /* mouseup */, this._onDragEnd, this);
            this.obj.container.off("touchend" /* touchend */, this._onDragEnd, this);
            this.dragging = false;
            this.bound = false;
            this.onDragEnd && this.onDragEnd.call(this.obj, e, this);
            this.onDragPress && this.onDragPress.call(this.obj, e, false, this);
        }
    };
    /** 清除拖动 */
    DragEvent.prototype.stopEvent = function () {
        if (this.bound && this.obj.stage) {
            var stage = this.obj.stage.container;
            stage.off("mousemove" /* mousemove */, this._onDragMove, this);
            stage.off("touchmove" /* touchmove */, this._onDragMove, this);
            stage.off("mouseup" /* mouseup */, this._onDragEnd, this);
            stage.off("mouseupoutside" /* mouseupoutside */, this._onDragEnd, this);
            stage.off("touchend" /* touchend */, this._onDragEnd, this);
            stage.off("touchendoutside" /* touchendoutside */, this._onDragEnd, this);
            this.bound = false;
        }
        this.obj.container.off("mousedown" /* mousedown */, this._onDragStart, this);
        this.obj.container.off("touchstart" /* touchstart */, this._onDragStart, this);
        this.obj.container.off("mouseover" /* mouseover */, this._onDragOver, this);
        this.obj.container.off("mouseout" /* mouseout */, this._onMouseOut, this);
        this.obj.container.off("mouseup" /* mouseup */, this._onDragEnd, this);
        this.obj.container.off("touchend" /* touchend */, this._onDragEnd, this);
        this.isStop = true;
    };
    DragEvent.prototype.remove = function () {
        this.stopEvent();
        this.onDragPress = undefined;
        this.onDragEnd = undefined;
        this.onDragMove = undefined;
        this.onDragStart = undefined;
        this.obj.interactive = false;
    };
    return DragEvent;
}());
exports.DragEvent = DragEvent;


/***/ }),

/***/ "./src/interaction/GroupController.ts":
/*!********************************************!*\
  !*** ./src/interaction/GroupController.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.getGroup = exports.unRegistrerGroup = exports.registrerGroup = exports.unRegistrerID = exports.registrerID = exports.getObjectById = exports._idObject = exports._GroupObject = void 0;
/**
 *
 * @private
 */
exports._GroupObject = new Map();
/**
 * 具有ID属性的组件都会添加到本组
 * @private
 */
exports._idObject = new Map();
function getObjectById(id) {
    return exports._idObject.get(id);
}
exports.getObjectById = getObjectById;
function registrerID(ui) {
    if (ui.id) {
        if (!exports._idObject.has(ui.id)) {
            exports._idObject.set(ui.id, ui);
            return true;
        }
    }
    return false;
}
exports.registrerID = registrerID;
function unRegistrerID(ui) {
    if (ui.id) {
        if (exports._idObject.has(ui.id)) {
            exports._idObject.delete(ui.id);
        }
    }
}
exports.unRegistrerID = unRegistrerID;
/**
 * 注册分组，
 */
function registrerGroup(ui) {
    if (ui.groupName) {
        var group = exports._GroupObject.get(ui.groupName);
        if (!group) {
            group = {};
            exports._GroupObject.set(ui.groupName, group);
        }
        group[ui.uuid] = ui;
    }
}
exports.registrerGroup = registrerGroup;
/**
 * 注销指定分组或指定分组的子项
 */
function unRegistrerGroup(ui) {
    if (ui.groupName) {
        var group = exports._GroupObject.get(ui.groupName);
        if (group) {
            delete group[ui.uuid];
        }
        var isKey = false;
        for (var key in group) {
            isKey = true;
            break;
        }
        if (isKey) {
            exports._GroupObject.delete(ui.groupName);
        }
    }
}
exports.unRegistrerGroup = unRegistrerGroup;
/** 设置选中 */
function getGroup(name) {
    if (name == undefined) {
        return undefined;
    }
    return exports._GroupObject.get(name);
}
exports.getGroup = getGroup;


/***/ }),

/***/ "./src/interaction/Index.ts":
/*!**********************************!*\
  !*** ./src/interaction/Index.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoGroupController = exports.GroupController = exports.ComponentEvent = exports.TouchMouseEvent = exports.InteractionEvent = exports.MouseScrollEvent = exports.InputController = exports.DragEvent = exports.DragDropController = exports.ClickEvent = void 0;
var ClickEvent_1 = __webpack_require__(/*! ./ClickEvent */ "./src/interaction/ClickEvent.ts");
Object.defineProperty(exports, "ClickEvent", { enumerable: true, get: function () { return ClickEvent_1.ClickEvent; } });
var DragDropController = __webpack_require__(/*! ./DragDropController */ "./src/interaction/DragDropController.ts");
exports.DragDropController = DragDropController;
var DragEvent_1 = __webpack_require__(/*! ./DragEvent */ "./src/interaction/DragEvent.ts");
Object.defineProperty(exports, "DragEvent", { enumerable: true, get: function () { return DragEvent_1.DragEvent; } });
var InputController = __webpack_require__(/*! ./InputController */ "./src/interaction/InputController.ts");
exports.InputController = InputController;
var VideoGroupController = __webpack_require__(/*! ./VideoGroupController */ "./src/interaction/VideoGroupController.ts");
exports.VideoGroupController = VideoGroupController;
var MouseScrollEvent_1 = __webpack_require__(/*! ./MouseScrollEvent */ "./src/interaction/MouseScrollEvent.ts");
Object.defineProperty(exports, "MouseScrollEvent", { enumerable: true, get: function () { return MouseScrollEvent_1.MouseScrollEvent; } });
var InteractionEvent_1 = __webpack_require__(/*! ../event/InteractionEvent */ "./src/event/InteractionEvent.ts");
Object.defineProperty(exports, "InteractionEvent", { enumerable: true, get: function () { return InteractionEvent_1.InteractionEvent; } });
var TouchMouseEvent_1 = __webpack_require__(/*! ../event/TouchMouseEvent */ "./src/event/TouchMouseEvent.ts");
Object.defineProperty(exports, "TouchMouseEvent", { enumerable: true, get: function () { return TouchMouseEvent_1.TouchMouseEvent; } });
var ComponentEvent = __webpack_require__(/*! ../event/ComponentEvent */ "./src/event/ComponentEvent.ts");
exports.ComponentEvent = ComponentEvent;
var GroupController = __webpack_require__(/*! ./GroupController */ "./src/interaction/GroupController.ts");
exports.GroupController = GroupController;


/***/ }),

/***/ "./src/interaction/InputController.ts":
/*!********************************************!*\
  !*** ./src/interaction/InputController.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.setCheckGroupSelectedValue = exports.getCheckGroupSelectedValue = exports.updateCheckGroupSelected = exports.unRegistrerCheckGroup = exports.registrerCheckGroup = exports.firePrev = exports.fireNext = exports.fireTab = exports.clear = exports.set = exports.blur = exports.registrer = exports._checkGroupObject = exports.tabGroups = void 0;
/**
 * 记录当前正在拖动的UI组件列表
 * @private
 */
var _currentItem;
/**
 *
 * @private
 */
exports.tabGroups = {};
/**
 *
 * @private
 */
exports._checkGroupObject = {
    groups: {},
    values: {}
};
/**
 * 注册组件
 * @param item
 * @param tabIndex 切换位置
 * @param tabGroup 分组名
 * @returns 依据tabIndex返回是否需要排序 0，-1，1
 */
function registrer(item, tabIndex, tabGroup) {
    var groupName = tabGroup || "default";
    var items = exports.tabGroups[groupName];
    if (!items)
        items = exports.tabGroups[groupName] = [];
    var i = items.indexOf(item);
    if (i === -1) {
        item.attach._tabIndex = tabIndex !== undefined ? tabIndex : -1;
        item.attach._tabGroup = items;
        items.push(item);
        items.sort(function (a, b) {
            if (a.attach._tabIndex < b.attach._tabIndex)
                return -1;
            if (a.attach._tabIndex > b.attach._tabIndex)
                return 1;
            return 0;
        });
    }
}
exports.registrer = registrer;
/** 失去焦点时 */
function blur() {
    var obj = _currentItem;
    if (obj) {
        if (obj.blur && typeof obj.blur == "function") {
            obj.blur();
        }
    }
}
exports.blur = blur;
/** 设置当前输入组件 */
function set(item) {
    blur();
    _currentItem = item;
}
exports.set = set;
/** 清楚当前设置的组件 */
function clear() {
    _currentItem = undefined;
}
exports.clear = clear;
/** 一般再按下键盘tab健执行 焦点获取与设置 */
function fireTab() {
    if (_currentItem) {
        var _tabGroup = _currentItem.attach._tabGroup;
        var i = _tabGroup.indexOf(_currentItem) + 1;
        if (i >= _tabGroup.length)
            i = 0;
        var obj = _tabGroup[i];
        if (obj.focus)
            obj.focus();
    }
}
exports.fireTab = fireTab;
/** 一般再按下键盘向下箭头执行 焦点获取与设置 */
function fireNext() {
    if (_currentItem) {
        var _tabGroup = _currentItem.attach._tabGroup;
        var i = _tabGroup.indexOf(_currentItem) + 1;
        if (i >= _tabGroup.length)
            i = _tabGroup.length - 1;
        var obj = _tabGroup[i];
        if (obj.focus)
            obj.focus();
    }
}
exports.fireNext = fireNext;
/** 一般再按下键盘向上箭头执行 焦点获取与设置 */
function firePrev() {
    if (_currentItem) {
        var _tabGroup = _currentItem.attach._tabGroup;
        var i = _tabGroup.indexOf(_currentItem) - 1;
        if (i < 0)
            i = 0;
        var obj = _tabGroup[i];
        if (obj.focus)
            obj.focus();
    }
}
exports.firePrev = firePrev;
/**
 * 注册分组，一般用于checkBox组件的分组操作
 *
 *  ==== 目前没有实现卸载，如果无限制创建checkbox并设置分组可能引发泄露 ====
 *
 * checkGroups = [key]:{["value"]:cb}
 */
function registrerCheckGroup(cb) {
    var name = cb.checkGroup;
    if (name) {
        var group = exports._checkGroupObject.groups[name];
        if (!group)
            group = exports._checkGroupObject.groups[name] = {};
        group[cb.uuid.toString()] = cb;
        if (cb.checked)
            exports._checkGroupObject.values[name] = cb.uuid.toString();
    }
}
exports.registrerCheckGroup = registrerCheckGroup;
/**
 * 注销指定分组或指定分组的子项
 * @param cb CheckBox
 */
function unRegistrerCheckGroup(cb) {
    if (cb.checkGroup && exports._checkGroupObject.groups[cb.checkGroup]) {
        delete exports._checkGroupObject.groups[cb.checkGroup][cb.uuid.toString()];
        var isKey = false;
        for (var key in exports._checkGroupObject.groups[cb.checkGroup]) {
            if (key)
                isKey = true;
            break;
        }
        if (!isKey) {
            delete exports._checkGroupObject.groups[name];
        }
        if (cb.checked)
            exports._checkGroupObject.values[name] = undefined;
    }
}
exports.unRegistrerCheckGroup = unRegistrerCheckGroup;
/** 更新分组中选中的checkbox组件  */
function updateCheckGroupSelected(cb) {
    if (cb.checkGroup) {
        var group = exports._checkGroupObject.groups[cb.checkGroup];
        for (var val in group) {
            var b = group[val];
            if (b !== cb)
                b.checked = false;
        }
        exports._checkGroupObject.values[cb.checkGroup] = cb.uuid.toString();
    }
}
exports.updateCheckGroupSelected = updateCheckGroupSelected;
/** 获取分组中选中的checkbox值 */
function getCheckGroupSelectedValue(name) {
    var uuid = exports._checkGroupObject.values[name];
    if (uuid) {
        var cb = exports._checkGroupObject.groups[name][uuid.toString()];
        return cb.value;
    }
    return undefined;
}
exports.getCheckGroupSelectedValue = getCheckGroupSelectedValue;
/** 设置选中 */
function setCheckGroupSelectedValue(name, uuid) {
    var group = exports._checkGroupObject.groups[name];
    if (group) {
        var cb = group[uuid];
        if (cb) {
            cb.checked = true;
        }
    }
}
exports.setCheckGroupSelectedValue = setCheckGroupSelectedValue;


/***/ }),

/***/ "./src/interaction/MouseScrollEvent.ts":
/*!*********************************************!*\
  !*** ./src/interaction/MouseScrollEvent.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MouseScrollEvent = void 0;
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
/**
 * 鼠标滑轮事件
 *
 *  可侦听事件(未实现):
 * ```
 *  {InteractionEvent}.MouseScroll.xxxxxx.
 * ```
 *  可赋值方法:
 * ```
 * oonMouseScroll: ((e: WheelEvent,delta: vf.Point) => void) | undefined
 * ```
 *
 * @example 可查看 `Slider` 源码
 *
 * @since 1.0.0
 */
var MouseScrollEvent = /** @class */ (function () {
    /**
     *
     * @param obj 需要绑定的对象
     * @param preventDefault 是否组织系统默认的事件触发
     */
    function MouseScrollEvent(obj, preventDefault) {
        this.id = 0;
        this.delta = new vf.Point();
        this.isStop = true;
        this.obj = obj;
        this.preventDefault = preventDefault;
        obj.container.interactive = true;
        this.startEvent();
    }
    MouseScrollEvent.prototype.startEvent = function () {
        if (this.isStop) {
            this.obj.container.on("mouseover" /* mouseover */, this._onHover, this);
            this.obj.container.on("mouseout" /* mouseout */, this._onMouseOut, this);
            this.isStop = false;
        }
    };
    MouseScrollEvent.prototype._onMouseScroll = function (_e) {
        _e;
        var e = _e;
        if (this.preventDefault)
            e.preventDefault();
        if (typeof e.deltaX !== "undefined")
            this.delta.set(e.deltaX, e.deltaY);
        else //Firefox{}
            this.delta.set(e.axis == 1 ? e.detail * 60 : 0, e.axis == 2 ? e.detail * 60 : 0);
        this.onMouseScroll && this.onMouseScroll.call(this.obj, e, this.delta);
    };
    //e?: interaction.InteractionEvent
    MouseScrollEvent.prototype._onHover = function () {
        if (this.mouseScrllBind === undefined) {
            this.id = Utils_1.uid();
            this.mouseScrllBind = this._onMouseScroll.bind(this);
            document.addEventListener("mousewheel", this.mouseScrllBind, { passive: false });
            document.addEventListener("DOMMouseScroll", this.mouseScrllBind, { passive: false });
        }
    };
    //e?: interaction.InteractionEvent
    MouseScrollEvent.prototype._onMouseOut = function () {
        if (this.mouseScrllBind) {
            document.removeEventListener("mousewheel", this.mouseScrllBind);
            document.removeEventListener("DOMMouseScroll", this.mouseScrllBind);
            this.mouseScrllBind = undefined;
        }
    };
    MouseScrollEvent.prototype.stopEvent = function () {
        if (this.mouseScrllBind) {
            document.removeEventListener("mousewheel", this.mouseScrllBind);
            document.removeEventListener("DOMMouseScroll", this.mouseScrllBind);
            this.mouseScrllBind = undefined;
        }
        this.obj.container.removeListener('mouseover', this._onHover, this);
        this.obj.container.removeListener('mouseout', this._onMouseOut, this);
        this.isStop = true;
    };
    MouseScrollEvent.prototype.remove = function () {
        this.stopEvent();
    };
    return MouseScrollEvent;
}());
exports.MouseScrollEvent = MouseScrollEvent;


/***/ }),

/***/ "./src/interaction/SyncManager.ts":
/*!****************************************!*\
  !*** ./src/interaction/SyncManager.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * 用于同步输入事件
 * by ziye
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncManager = void 0;
var InteractionEvent_1 = __webpack_require__(/*! ../event/InteractionEvent */ "./src/event/InteractionEvent.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Ticker_1 = __webpack_require__(/*! ../core/Ticker */ "./src/core/Ticker.ts");
var SyncManager = /** @class */ (function (_super) {
    __extends(SyncManager, _super);
    function SyncManager(stage) {
        var _this = _super.call(this) || this;
        _this._role = "T" /* teacher */; //角色
        _this.mode = 1; //模式  1-预览  2-直播   3-回放
        _this.resumeStatusFlag = false; //是否正在恢复状态
        _this.resumeImmediately = false; //是否为立即恢复状态
        _this.offsetTime = 0; //本地Date.now()与中心服务器的差值
        _this._initTime = 0; //初始化成功时的时间
        _this._lostMoveEvent = []; //move节流中的event
        _this._throttleMoveFlag = false; //move节流状态
        _this._throttleMoveTimer = null; //move节流时间函数
        _this._evtDataList = []; //历史信令整理后的数组
        _this._readystate = 1;
        _this._sendId = 0; //发送的eventId
        _this._lastSId = 0; //上一个学生的eventId
        _this._lastTId = 0; //上一个老师的eventId
        _this._lastSEventData = undefined; //上一个收到的学生的eventData
        _this._lastTEventData = undefined; //上一个收到的老师的eventData
        _this._swaitingEventList = []; //暂时寄存起来的学生的event
        _this._twaitingEventList = []; //暂时寄存起来的老师的event
        _this._waitTimer = 0;
        _this._resumeTimer = 0;
        _this._heartTimer = undefined;
        _this._autoHeartTimer = undefined;
        _this.autoHeartFlag = true; //是否自动心跳
        _this._initDataTimer = 0;
        _this.initDataFlag = false; //初始化数据状态
        _this._resumeStoreList = []; //恢复状态受到实时信令的暂存取
        _this._startFlag = false;
        _this._lostEvent = []; //节流的event
        _this._throttleEventTimer = null; //节流的timer
        _this._interactionEvent = new InteractionEvent_1.InteractionEvent();
        if (!_this._interactionEvent.data) {
            _this._interactionEvent.data = new vf.InteractionData();
        }
        _this._stage = stage;
        return _this;
    }
    /**
     * 对应一个stage有一个syncManager的实例
     */
    SyncManager.getInstance = function (stage) {
        if (stage === void 0) { stage = undefined; }
        return SyncManager.instance;
    };
    SyncManager.getIns = function () {
        return SyncManager.instance;
    };
    /**
     * log
     */
    SyncManager.prototype.log = function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        if (window.syncManagerLog) {
            console.log.apply(console, data);
        }
    };
    /**
     * 清理syncManager
     */
    SyncManager.prototype.stop = function () {
        this.reset();
        this._readystate = 0;
        this._startFlag = false;
    };
    /**
     * 开始同步
     */
    SyncManager.prototype.start = function () {
        this.reset();
        var stage = this._stage;
        var systemEvent = stage.getSystemEvent();
        if (systemEvent) {
            systemEvent.on("sendCustomEvent", this.sendCustomEvent, this);
            systemEvent.on("sendHeartEvent", this.sendHeartEvent, this);
        }
        this._startFlag = true;
    };
    /**
     * 重置syncManager
     */
    SyncManager.prototype.reset = function () {
        //重置前把遗留的信令都发出去
        this.dealLostEvent();
        //重置变量
        if (this._initDataTimer) {
            clearTimeout(this._initDataTimer);
        }
        if (this._throttleMoveTimer) {
            clearTimeout(this._throttleMoveTimer);
        }
        if (this._waitTimer) {
            clearTimeout(this._waitTimer);
        }
        if (this._resumeTimer) {
            clearTimeout(this._resumeTimer);
        }
        if (this._heartTimer) {
            clearInterval(this._heartTimer);
            this._heartTimer = undefined;
        }
        if (this._autoHeartTimer) {
            clearInterval(this._autoHeartTimer);
            this._autoHeartTimer = undefined;
        }
        this.resumeStatusFlag = false; //是否正在恢复状态
        this.resumeImmediately = false; //是否为立即恢复状态
        this.offsetTime = 0; //本地Date.now()与中心服务器的差值
        this._initTime = Ticker_1.TickerShared.currentTickerTime;
        this._lostMoveEvent = []; //节流中的event
        this._throttleMoveFlag = false; //节流状态
        this._throttleMoveTimer = null; //节流时间函数
        this._readystate = 1;
        this._sendId = 0; //发送的eventId
        this._lastSId = 0; //上一个学生的eventId
        this._lastTId = 0; //上一个老师的eventId
        this._lastSEventData = undefined;
        this._lastTEventData = undefined;
        this._swaitingEventList = []; //暂时寄存起来的学生的event
        this._twaitingEventList = []; //暂时寄存起来的老师的event
        this._waitTimer = 0;
        this._resumeTimer = 0;
        this._heartTimer = undefined;
        this._autoHeartTimer = undefined;
        this.autoHeartFlag = true; //是否自动心跳
        this._initDataTimer = 0;
        this.initDataFlag = false; //初始化数据状态
        this._resumeStoreList = []; //恢复状态受到实时信令的暂存取
        this._lastEventData = undefined;
        this._lostEvent = [];
        this._throttleEventTimer && clearTimeout(this._throttleEventTimer);
        var stage = this._stage;
        var systemEvent = stage.getSystemEvent();
        if (systemEvent) {
            systemEvent.off("sendCustomEvent", this.sendCustomEvent, this);
            systemEvent.off("sendHeartEvent", this.sendHeartEvent, this);
        }
    };
    Object.defineProperty(SyncManager.prototype, "role", {
        get: function () {
            return this._role;
        },
        /**
         * 角色
         */
        set: function (value) {
            this._role = value;
            this.initDataFlag = true;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 自动心跳，自动心跳基于每次输入操作之后，心跳10次，间隔0.5
     * @param duration
     * @param role
     */
    SyncManager.prototype.autoHeartEvent = function () {
        var _this = this;
        if (!this.autoHeartFlag)
            return;
        if (this._autoHeartTimer) {
            clearInterval(this._autoHeartTimer);
        }
        var times = 0;
        this._autoHeartTimer = setInterval(function () {
            _this.sendHeartEvent();
            times++;
            if (times >= 5) {
                if (_this._autoHeartTimer) {
                    clearInterval(_this._autoHeartTimer);
                }
            }
        }, 1000);
    };
    /**
     * 同步心跳
     * @duration 心跳间隔
     * @role 1-老师  2-学生   12-老师学生均发心跳
     */
    SyncManager.prototype.syncHeartEvent = function (duration, role) {
        var _this = this;
        if (role === void 0) { role = 12; }
        if (role == 1 && this.role == "S" /* student */)
            return;
        if (role == 2 && this.role == "T" /* teacher */)
            return;
        if (duration < 2000) {
            duration = 2000;
        }
        if (this._heartTimer) {
            clearInterval(this._heartTimer);
        }
        //心跳js原生时间函数发送
        this._heartTimer = setInterval(function () {
            _this.sendHeartEvent();
        }, duration);
    };
    /**
     * 发送心跳
     */
    SyncManager.prototype.sendHeartEvent = function () {
        var eventData = {};
        var time = this.currentTime();
        eventData.code = "syncHeartEvent";
        eventData.time = time;
        this.sendEvent(eventData);
    };
    /**
     * 收集交互事件
     */
    SyncManager.prototype.collectEvent = function (e, obj) {
        if (!this._startFlag)
            return;
        if (e.signalling)
            return; //不需要同步，或者已经是信令同步过来的，不再做处理
        if (!obj.syncabled)
            return; //组件交互不需要同步
        var eventData = this.createEventData(e, obj);
        if (!eventData)
            return;
        if (this._autoHeartTimer) {
            clearInterval(this._autoHeartTimer);
        }
        if (e.type === "mousemove" /* mousemove */ || e.type === "touchmove" /* touchmove */) {
            this.throttle(eventData);
        }
        else {
            //首先把之前未发送的move补发出去
            if (this._lostMoveEvent.length > 0) {
                clearTimeout(this._throttleMoveTimer);
                this.sendEvent(this._lostMoveEvent[0]);
                this._lostMoveEvent = [];
                this._throttleMoveFlag = false;
            }
            this.sendEvent(eventData);
            //启动自动心跳
            if (e.type == "mousedown" /* mousedown */ ||
                e.type == "mouseup" /* mouseup */ ||
                e.type == "touchstart" /* touchstart */ ||
                e.type == "touchend" /* touchend */) {
                this.autoHeartEvent();
            }
        }
    };
    /**
     * 发送自定义事件
     * customData 自定义数据
     */
    SyncManager.prototype.sendCustomEvent = function (customData) {
        if (!this._startFlag)
            return;
        var eventData = {};
        var time = this.currentTime();
        eventData.code = "syncCustomEvent_" + vf.utils.uid() + time;
        eventData.time = time;
        eventData.data = JSON.stringify(customData);
        this.sendEvent(eventData);
    };
    /**
     * 发送当前时间
     */
    SyncManager.prototype.sendSyncTimeEvent = function () {
        var eventData = {};
        eventData.code = "syncTimeEvent";
        eventData.time = this.currentTime();
        this.sendEvent(eventData);
    };
    /**
     * 接收操作
     * @signalType 信令类型  live-实时信令   history-历史信令
     */
    SyncManager.prototype.receiveEvent = function (eventData, signalType) {
        if (signalType === void 0) { signalType = "live"; }
        if (!this._startFlag)
            return;
        if (signalType == "history") {
            this.log("syncManager----receive history Event：", eventData);
            this.dealHistoryEvent(eventData);
        }
        else {
            this.log("syncManager----receive live Event：", eventData.id, eventData.time, eventData.code, eventData);
            this.dealLiveEvent(eventData);
        }
    };
    SyncManager.prototype.dealLiveEvent = function (eventData) {
        var _this = this;
        //如果是数组，先展开
        if (eventData.code.indexOf('syncListEvent_') == 0) {
            eventData.data.forEach(function (element) {
                _this.dealLiveEvent(element);
            });
            return;
        }
        if (eventData.role !== 'T' && eventData.role !== 'S')
            return;
        if (eventData.code === "syncTimeEvent") {
            //同步时间，恢复状态不做处理
            if (!this.resumeStatusFlag) {
                if (this.currentTime() > eventData.time + 300) {
                    //当前端时间靠后，通知另一端向未来穿越
                    this.sendSyncTimeEvent();
                }
                else {
                    //穿越到未来
                    var duration = eventData.time - this.currentTime();
                    this.timeTravel(duration);
                }
            }
            return;
        }
        if (eventData.code === "syncHeartEvent") {
            return;
        }
        if (eventData.code.indexOf("syncInteraction_") != 0 && eventData.code.indexOf("syncCustomEvent_") != 0) {
            return;
        }
        if (this.resumeStatusFlag) {
            this._resumeStoreList.push(eventData);
            return;
        }
        //如果是回放模式，并且有历史信令未处理，则暂存实时信令
        if (this.mode == 3 && this._evtDataList.length > 0) {
            this._resumeStoreList.push(eventData);
            return;
        }
        if (this.checkEventId(eventData)) {
            this.parseEventData(eventData);
            this.checkWaitingEvent();
        }
        else {
            if (this._swaitingEventList.length > 0 || this._twaitingEventList.length) {
                //启动一个定时器，等待0.5s，0.5s后如果还没有到等到正确的id，则执行wait中的event
                clearTimeout(this._waitTimer);
                this._waitTimer = setTimeout(function () {
                    _this.checkWaitingEvent(true);
                }, 500);
            }
        }
    };
    /**
     * 检查eventId是否正确
     */
    SyncManager.prototype.checkEventId = function (eventData) {
        if (eventData.role == "T" /* teacher */) {
            if (this._lastTId != 0 && this._lastTId != eventData.id - 1) {
                //如果id小于已经执行的id，说明是过去的信令，直接放弃
                if (eventData.id <= this._lastTId) {
                    console.log('syncManager----Tid小于等于已执行eventId，直接放弃', this._lastTId, eventData.id);
                    return false;
                }
                //不相等，暂时寄存起来
                console.log('syncManager----Tid异常，暂存', this._lastTId, eventData.id);
                this._twaitingEventList.push(eventData);
                return false;
            }
            this._lastTId = eventData.id;
            this._lastTEventData = eventData;
        }
        else {
            if (this._lastSId != 0 && this._lastSId != eventData.id - 1) {
                //如果id小于已经执行的id，说明是过去的信令，直接放弃
                if (eventData.id <= this._lastSId) {
                    console.log('syncManager----Sid小于等于已执行eventId，直接放弃', this._lastSId, eventData.id);
                    return false;
                }
                //不相等，暂时寄存起来
                console.log('syncManager----Sid异常，暂存', this._lastSId, eventData.id);
                this._swaitingEventList.push(eventData);
                return false;
            }
            this._lastSId = eventData.id;
            this._lastSEventData = eventData;
        }
        return true;
    };
    /**
     * 检查是否有暂存的event需要执行
     * forceFlag: 是否强制执行
     */
    SyncManager.prototype.checkWaitingEvent = function (forceFlag) {
        var _this = this;
        if (forceFlag === void 0) { forceFlag = false; }
        clearTimeout(this._waitTimer);
        if (this._twaitingEventList.length > 0) {
            this._twaitingEventList.sort(function (a, b) {
                return a.id - b.id;
            });
            if (forceFlag) {
                this._lastTId = this._twaitingEventList[0].id - 1;
            }
            for (var i = 0; i < this._twaitingEventList.length; ++i) {
                //执行操作
                var eventData = this._twaitingEventList[i];
                console.log('syncManager----deal 异常Tid', this._lastTId, eventData.id);
                if (eventData.id == this._lastTId + 1) {
                    this.parseEventData(eventData);
                    this._lastTId = eventData.id;
                    this._lastTEventData = eventData;
                    this._twaitingEventList.splice(i, 1);
                    --i;
                }
            }
        }
        if (this._swaitingEventList.length > 0) {
            this._swaitingEventList.sort(function (a, b) {
                return a.id - b.id;
            });
            if (forceFlag) {
                this._lastSId = this._swaitingEventList[0].id - 1;
            }
            for (var i = 0; i < this._swaitingEventList.length; ++i) {
                //执行操作
                var eventData = this._swaitingEventList[i];
                console.log('syncManager----deal 异常Sid', this._lastSId, eventData.id);
                if (eventData.id == this._lastSId + 1) {
                    this.parseEventData(eventData);
                    this._lastSId = eventData.id;
                    this._lastSEventData = eventData;
                    this._swaitingEventList.splice(i, 1);
                    --i;
                }
            }
        }
        //如果还没有执行完，则起一个定时器，0.5s后继续执行
        if (this._swaitingEventList.length > 0 || this._twaitingEventList.length > 0) {
            this._waitTimer = setTimeout(function () {
                _this.checkWaitingEvent(true);
            }, 500);
        }
    };
    /**
     * 获取当前时间
     */
    SyncManager.prototype.currentTime = function () {
        var time = Ticker_1.TickerShared.currentTickerTime - this._initTime;
        return Math.floor(time);
    };
    /**
     * 构造一个新的e，用于同步，数据要尽量精简
     */
    SyncManager.prototype.createEventData = function (e, obj) {
        var event = {};
        event.type = e.type; //事件类型  mousedown、mouseup、mousemove....
        event.path = Utils_1.getDisplayPathById(obj); //显示对象的唯一标识
        var data = {};
        event.data = data;
        data.identifier = e.data.identifier;
        data.global = { x: Math.floor(e.data.global.x), y: Math.floor(e.data.global.y) };
        //!!!important: e.data.originalEvent  不支持事件继续传递
        var time = this.currentTime();
        var eventData = {
            code: "syncInteraction_" + vf.utils.uid() + time,
            time: time,
            data: event,
        };
        if (this._lastEventData) {
            if (e.type !== 'mousemove' && e.type !== 'touchmove' && this._lastEventData.type == e.type && this._lastEventData.obj == obj && this._lastEventData.time == time) {
                // this.log('syncManager----抛弃相同的事件！', this._lastEventData.time, time)
                return undefined;
            }
        }
        this._lastEventData = {
            type: e.type,
            obj: obj,
            time: time
        };
        return eventData;
    };
    /**
     * 发送操作(稀疏前的每一次单条发送)
     */
    SyncManager.prototype.sendEvent = function (eventData) {
        if (this.role !== 'T' && this.role !== 'S')
            return; //只有老师和学生才能发信令，其他角色不能发
        if (this.mode == 3)
            return; //回放不发送信令
        //添加eventId
        eventData.role = this.role;
        //只有点击事件或自定义信令，才需要id连续
        if (eventData.code.indexOf("syncInteraction") == 0 || eventData.code.indexOf("syncCustomEvent") == 0) {
            eventData.id = ++this._sendId;
        }
        else {
            eventData.id = 0;
        }
        this.checkEventData(eventData);
    };
    /**
     * 智能检测，如果是end，把所有暂存的一起立即发送
     * 如果是start的，暂存起来，启动300ms的定时
     * 如果是其他的，已经有暂存，则将继续暂存，否则立即发送
     * @param eventData
     */
    SyncManager.prototype.checkEventData = function (eventData) {
        var _this = this;
        if (eventData.code.indexOf("syncInteraction") == 0) {
            //如果是操作事件，做智能判断
            if (eventData.data.type == "mouseup" /* mouseup */ || eventData.data.type == "touchend" /* touchend */) {
                eventData.data = JSON.stringify(eventData.data);
                this._lostEvent.push(eventData);
                this._throttleEventTimer && clearTimeout(this._throttleEventTimer);
                this.dealLostEvent();
            }
            else if (eventData.data.type == "mousedown" /* mousedown */ || eventData.data.type == "touchstart" /* touchstart */) {
                eventData.data = JSON.stringify(eventData.data);
                this._lostEvent.push(eventData);
                if (this._lostEvent.length == 1) {
                    //启动定时器
                    this._throttleEventTimer && clearTimeout(this._throttleEventTimer);
                    this._throttleEventTimer = setTimeout(function () {
                        _this.dealLostEvent();
                    }, 300);
                }
            }
            else {
                eventData.data = JSON.stringify(eventData.data);
                this._lostEvent.push(eventData);
                if (this._lostEvent.length == 1) {
                    this.dealLostEvent();
                }
            }
        }
        else {
            this._lostEvent.push(eventData);
            this._throttleEventTimer && clearTimeout(this._throttleEventTimer);
            this.dealLostEvent();
        }
    };
    SyncManager.prototype.dealLostEvent = function () {
        if (this._lostEvent.length == 0)
            return;
        if (this._lostEvent.length == 1) {
            this.realSendEvent(this._lostEvent[0]);
        }
        else {
            var event_1 = {
                code: "syncListEvent_" + vf.utils.uid() + this.currentTime(),
                time: this.currentTime(),
                data: this._lostEvent,
            };
            this.realSendEvent(event_1);
        }
        this._lostEvent = [];
    };
    /**
     * 真实发送(稀疏后的真实发送，可能是单条，可能是数组)
     */
    SyncManager.prototype.realSendEvent = function (eventData) {
        var stage = this._stage;
        //派发至uistage
        stage.emit("sendSyncEvent", eventData);
        //派发至player
        var msg = {
            level: "command",
            code: "syncEvent",
            data: eventData,
        };
        stage.sendToPlayer(msg);
        this.log("syncManager----sendSyncEvent：", eventData.id, eventData.time, eventData.code, eventData);
    };
    /**
     * 更新节流状态
     */
    SyncManager.prototype.throttleUpdate = function () {
        this._throttleMoveFlag = false;
        if (this._lostMoveEvent.length > 0) {
            this.throttle(this._lostMoveEvent[0]);
            this._lostMoveEvent = [];
        }
    };
    /**
     * 节流，每100ms发送一次
     * @param eventData
     */
    SyncManager.prototype.throttle = function (eventData) {
        var _this = this;
        if (!this._throttleMoveFlag) {
            this._throttleMoveFlag = true;
            this.sendEvent(eventData);
            this._throttleMoveTimer = setTimeout(function () {
                _this.throttleUpdate();
            }, 200);
        }
        else {
            this._lostMoveEvent = [];
            this._lostMoveEvent.push(eventData);
        }
    };
    SyncManager.prototype.resetStage = function () {
        var stage = this._stage;
        if (stage.reset) {
            stage.reset(false); //只重置场景，不派发事件  by ziye+
        }
        else {
            console.error("当前stage没有reset方法，使用输入同步需要自定义reset方法用于场景重置!!!");
        }
        if (this._autoHeartTimer) {
            clearInterval(this._autoHeartTimer);
        }
    };
    /**
     * 解析收到的event
     */
    SyncManager.prototype.parseEventData = function (eventData) {
        var stage = this._stage;
        var time = eventData.time;
        //判断信令时间，是否需要向后穿越
        var currentTime = this.currentTime();
        if (currentTime < time) {
            var druation = time - currentTime;
            this.timeTravel(druation);
        }
        if (eventData.code.indexOf("syncInteraction_") == 0) {
            var event_2 = JSON.parse(eventData.data);
            this._interactionEvent.signalling = true;
            this._interactionEvent.type = event_2.type;
            var data = event_2.data;
            this._interactionEvent.data.identifier = data.identifier;
            this._interactionEvent.data.global.set(data.global.x, data.global.y);
            var obj = stage.getChildByPath(event_2.path);
            if (obj) {
                if (this.resumeStatusFlag && !obj.resumeabled)
                    return;
                obj.container.emit(this._interactionEvent.type, this._interactionEvent);
                this.log('syncManager----syncInteraction_success:', eventData);
            }
            else {
                console.error('当前页面没有找到对应path的组件！', event_2.path);
            }
        }
        else if (eventData.code.indexOf("syncCustomEvent_") == 0) {
            //自定义事件
            var data = JSON.parse(eventData.data);
            var systemEvent = stage.getSystemEvent();
            if (systemEvent) {
                systemEvent.emit("receiveCustomEvent", {
                    code: 'receiveCustomEvent',
                    level: 'command',
                    data: data
                });
            }
            stage.emit("receiveCustomEvent", data);
            this.emit("receiveCustomEvent", data);
            this.log('syncManager----syncCustomEvent_success:', eventData);
        }
    };
    /**
     * 时间未到，需要穿越到未来
     */
    SyncManager.prototype.timeTravel = function (druation) {
        if (druation <= 0)
            return; //只能向后穿越，不能向前穿
        var resetRenderFlag = false;
        if (this._stage.renderable) {
            this._stage.renderable = false;
            resetRenderFlag = true;
        }
        Ticker_1.TickerShared.timeTravel(druation);
        if (resetRenderFlag) {
            this._stage.renderable = true;
        }
    };
    /**
     * 模板初始化
     * @param history
     */
    SyncManager.prototype.initData = function (history) {
        var initData = {
            level: 'command',
            code: 'VFInitData',
            data: {
                history: history
            }
        };
        //派发初始化状态
        this._initDataTimer && clearTimeout(this._initDataTimer);
        // this._initDataTimer = setTimeout(() => {
        var stage = this._stage;
        var systemEvent = stage.getSystemEvent();
        if (systemEvent) {
            systemEvent.emit("VFInitData", initData);
        }
        stage.emit("VFInitData", initData);
        // }, 120);
        this.emit('VFInitData', { history: history });
    };
    /**
     * 处理历史信令，将历史输入事件按时间顺序放置到一个数组
     * @param eventData
     */
    SyncManager.prototype.dealHistoryEvent = function (eventData) {
        for (var key in eventData) {
            if (key.indexOf("syncListEvent_") == 0) {
                var event_3 = eventData[key];
                event_3.data.forEach(function (element) {
                    eventData[element.code] = element;
                });
                delete eventData[key];
            }
        }
        this._initTime = Ticker_1.TickerShared.currentTickerTime;
        this._evtDataList = [];
        if (!eventData) {
            this.sendSyncTimeEvent();
            this.autoHeartEvent();
            this.initData(false);
            return;
        }
        var hasCustomEvent = false;
        for (var key in eventData) {
            if (key.indexOf("syncInteraction_") == 0 ||
                key.indexOf("syncCustomEvent_") == 0 ||
                key.indexOf("syncHeartEvent") == 0) {
                this._evtDataList.push(eventData[key]);
            }
            if (key.indexOf("syncCustomEvent_") == 0) {
                hasCustomEvent = true;
            }
        }
        if (this._evtDataList.length == 0) {
            this.sendSyncTimeEvent();
            this.autoHeartEvent();
            this.initData(false);
            return;
        }
        this.initData(hasCustomEvent);
        //立即恢复表示不需要关心stage的状态，直接执行历史信令
        if (this.resumeImmediately) {
            this.resumeStatusImmediately();
        }
        else {
            this.resumeStatus();
        }
    };
    SyncManager.prototype.resumeStatusImmediately = function () {
        var _this = this;
        if (this._readystate === 0)
            return;
        //恢复过程只需要计算状态，不需要渲染
        this.resumeStatusFlag = this._stage.resumeStatusFlag = true;
        this._initTime = Ticker_1.TickerShared.currentTickerTime;
        this._stage.renderable = false;
        this._evtDataList.sort(function (a, b) {
            if (a.time !== b.time) {
                return a.time - b.time;
            }
            else {
                return a.id - b.id;
            }
        });
        for (var i = 0; i < this._evtDataList.length; ++i) {
            //执行操作
            var eventData = this._evtDataList[i];
            this.parseEventData(eventData);
            if (eventData.code.indexOf("syncInteraction") == 0 || eventData.code.indexOf("syncCustomEvent") == 0) {
                if (eventData.role == 'T') {
                    this._lastTId = eventData.id;
                    this._lastTEventData = eventData;
                    if (this.role == 'T') {
                        this._sendId = eventData.id;
                    }
                }
                else {
                    this._lastSId = eventData.id;
                    this._lastSEventData = eventData;
                    if (this.role == 'S') {
                        this._sendId = eventData.id;
                    }
                }
            }
        }
        this._evtDataList = [];
        //执行恢复状态的暂存信令
        this._resumeStoreList.forEach(function (item) {
            _this.receiveEvent(item, 'live');
        });
        this._resumeStoreList = [];
        this._stage.renderable = true;
        this.resumeStatusFlag = this._stage.resumeStatusFlag = false;
        //恢复完历史后，发一条同步指令，对齐时间
        this.sendSyncTimeEvent();
        this.autoHeartEvent();
    };
    /**
     * 恢复状态
     */
    SyncManager.prototype.resumeStatus = function () {
        //恢复过程只需要计算状态，不需要渲染
        //如果是回放模式，每次seek都是发送一次历史信令，需要resetStage
        if (this.mode == 3) {
            var systemEvent = this._stage.getSystemEvent();
            if (systemEvent) {
                systemEvent.on("status", this.resetCallback, this);
            }
            this.resetStage();
        }
        else {
            this.resumeStatusImmediately();
        }
    };
    SyncManager.prototype.resetCallback = function (event) {
        if (event.code == 'ScenComplete') {
            var systemEvent = this._stage.getSystemEvent();
            if (systemEvent) {
                systemEvent.off("status", this.resetCallback, this);
            }
            this.resumeStatusImmediately();
        }
    };
    return SyncManager;
}(vf.utils.EventEmitter));
exports.SyncManager = SyncManager;


/***/ }),

/***/ "./src/interaction/VideoGroupController.ts":
/*!*************************************************!*\
  !*** ./src/interaction/VideoGroupController.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.updateVideoGroupStates = exports.unRegistrerVideoGroup = exports.registrerVideoGroup = exports._videoGroupObject = void 0;
exports._videoGroupObject = {
    groups: {},
    values: {}
};
/* 注册分组，用于video组件的分组操作
*
* checkGroups = [key]:{["value"]:cb}
*/
function registrerVideoGroup(cb) {
    var name = cb.videoGroup;
    if (name || name === "") {
        var group = exports._videoGroupObject.groups[name];
        if (!group)
            group = exports._videoGroupObject.groups[name] = {};
        group[cb.uuid.toString()] = cb;
        // if (cb.checked)
        exports._videoGroupObject.values[name] = cb.uuid.toString();
    }
}
exports.registrerVideoGroup = registrerVideoGroup;
/**
 * 注销指定分组或指定分组的子项
 * @param cb video
 */
function unRegistrerVideoGroup(cb) {
    if ((cb.videoGroup || cb.videoGroup === "") && exports._videoGroupObject.groups[cb.videoGroup]) {
        delete exports._videoGroupObject.groups[cb.videoGroup][cb.uuid.toString()];
        var isKey = false;
        for (var key in exports._videoGroupObject.groups[cb.videoGroup]) {
            if (key)
                isKey = true;
            break;
        }
        if (!isKey) {
            delete exports._videoGroupObject.groups[cb.videoGroup];
        }
        // if (cb.checked)
        exports._videoGroupObject.values[cb.videoGroup] = undefined;
    }
}
exports.unRegistrerVideoGroup = unRegistrerVideoGroup;
/** 更新分组中选中的checkbox组件  */
function updateVideoGroupStates(cb) {
    if (cb.videoGroup || cb.videoGroup === "") {
        var group = exports._videoGroupObject.groups[cb.videoGroup];
        for (var val in group) {
            var b = group[val];
            if (b !== cb) {
                if (b.isPlaying) {
                    b.pause();
                }
            }
            else {
                if (!b.isPlaying) {
                    b.play();
                }
            }
        }
        exports._videoGroupObject.values[cb.videoGroup] = cb.uuid.toString();
    }
}
exports.updateVideoGroupStates = updateVideoGroupStates;


/***/ }),

/***/ "./src/layout/CSSBasicLayout.ts":
/*!**************************************!*\
  !*** ./src/layout/CSSBasicLayout.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.updateBasicDisplayList = exports.formatRelative = exports.$tempRectangle = void 0;
var UIKeys = __webpack_require__(/*! ../core/DisplayLayoutKeys */ "./src/core/DisplayLayoutKeys.ts");
exports.$tempRectangle = new vf.Rectangle();
/**
 * 布局尺寸>外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸
 */
function formatRelative(value, total) {
    if (value == undefined) {
        return NaN;
    }
    if (typeof value === "number") {
        return value;
    }
    var str = value;
    var index = str.indexOf("%");
    if (index == -1) {
        return +str;
    }
    var percent = +str.substring(0, index);
    return percent * 0.01 * total;
}
exports.formatRelative = formatRelative;
/**
 * @private
 * 一个工具方法，使用BasicLayout规则布局目标对象。
 */
function updateBasicDisplayList(target, unscaledWidth, unscaledHeight) {
    if (!target)
        return;
    //console.log(target.container.name);
    var values = target.$values;
    var parent = target.parent;
    var parentWidth = 1;
    var parentHeight = 1;
    if (parent) {
        parentWidth = parent.width || 1;
        parentHeight = parent.height || 1;
    }
    var hCenter = formatRelative(values[UIKeys.horizontalCenter], parentWidth * 0.5);
    var vCenter = formatRelative(values[UIKeys.verticalCenter], parentHeight * 0.5);
    var left = formatRelative(values[UIKeys.left], parentWidth || 1);
    var right = formatRelative(values[UIKeys.right], parentWidth);
    var top = formatRelative(values[UIKeys.top], parentHeight || 1);
    var bottom = formatRelative(values[UIKeys.bottom], parentHeight);
    var childWidth = unscaledWidth;
    var childHeight = unscaledHeight;
    if (!isNaN(left) && !isNaN(right)) {
        childWidth = parentWidth - right - left;
    }
    if (!isNaN(top) && !isNaN(bottom)) {
        childHeight = parentHeight - bottom - top;
    }
    target.setMeasuredSize(childWidth, childHeight);
    target.setActualSize(childWidth, childHeight);
    var childX = NaN;
    var childY = NaN;
    if (!isNaN(hCenter))
        childX = Math.round((parentWidth - childWidth) / 2 + hCenter);
    else if (!isNaN(left))
        childX = left;
    else if (!isNaN(right))
        childX = parentWidth - childWidth - right;
    else
        childX = target.x;
    if (!isNaN(vCenter))
        childY = Math.round((parentHeight - childHeight) / 2 + vCenter);
    else if (!isNaN(top))
        childY = top;
    else if (!isNaN(bottom))
        childY = parentHeight - childHeight - bottom;
    else
        childY = target.y;
    target.setPosition(childX, childY);
}
exports.updateBasicDisplayList = updateBasicDisplayList;


/***/ }),

/***/ "./src/layout/CSSGridLayout.ts":
/*!*************************************!*\
  !*** ./src/layout/CSSGridLayout.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.updateGridLayout = void 0;
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var CSSBasicLayout_1 = __webpack_require__(/*! ./CSSBasicLayout */ "./src/layout/CSSBasicLayout.ts");
function getColumnRowValue(gridTemplate, parentValue) {
    var list = [];
    var isInfinity = false;
    if (gridTemplate) {
        if (gridTemplate[0] === "repeat") {
            if (gridTemplate[1] === Infinity) {
                isInfinity = true;
                list.push(Utils_1.formatRelative(0, parentValue));
            }
            else {
                for (var i = 0; i < gridTemplate[1]; i++) {
                    list.push(Utils_1.formatRelative(gridTemplate[2], parentValue));
                }
            }
        }
        else {
            for (var i = 0; i < gridTemplate.length; i++) {
                list.push(Utils_1.formatRelative(gridTemplate[i], parentValue));
            }
        }
    }
    return { list: list, isInfinity: isInfinity };
}
/**
 *  更新网格布局
 *
 * 单位目前只支持数值或百分比：100 ，”100%“
 *
 *  网格布局中，子容器的位置与宽高可能失效
 *
 * 关于grid布局的词汇表
 *
 * 格网 https://developer.mozilla.org/zh-CN/docs/Glossary/Grid
 *
 * 网格行 gridTemplateRows https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-columns
 *
 * 网格列 gridTemplateColumns https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-rows
 *
 * 网格行间距 gridRowGap   https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-row-gap
 *
 * 网格列间距 gridColumnGap  https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-column-gap
 *
 * 网格轴 （未实现） 支持居中方式为：justifyContent，alignContent
 *
 * 网格线（未实现） https://developer.mozilla.org/en-US/docs/Glossary/Grid_Lines
 *
 * 网格面积（未实现）https://developer.mozilla.org/zh-CN/docs/Glossary/Grid_Areas
 */
function updateGridLayout(target) {
    if (target.parent == undefined) {
        return CSSBasicLayout_1.$tempRectangle;
    }
    if (target.style == undefined) {
        return CSSBasicLayout_1.$tempRectangle;
    }
    var rowHeightTotal = 0;
    var columnWidthTotal = 0;
    var style = target.style;
    var gridColumnGap = style.gridColumnGap || 0;
    var gridRowGap = style.gridRowGap || 0;
    var column = getColumnRowValue(style.gridTemplateColumns, target.parent.width);
    var row = getColumnRowValue(style.gridTemplateRows, target.parent.height);
    var child;
    var cloumnIndex = 0;
    var rowIndex = 0;
    var cloumnWidth = 0;
    var rowHeight = 0;
    var widthTotal = 0;
    for (var i = 0; i < target.uiChildren.length; i++) {
        child = target.uiChildren[i];
        if (child.style.justifyContent || child.style.alignContent) {
            continue;
        }
        if (column.isInfinity) {
            cloumnWidth = column.list[0] || 0;
        }
        else {
            cloumnWidth = column.list[cloumnIndex] || 0;
        }
        if (row.isInfinity) {
            rowHeight = row.list[0] || 0;
        }
        else {
            rowHeight = row.list[rowIndex] || 0;
        }
        child.width = child.explicitWidth || cloumnWidth;
        child.height = child.explicitHeight || rowHeight;
        child.x = widthTotal;
        child.y = rowHeightTotal;
        widthTotal += cloumnWidth + gridColumnGap;
        cloumnIndex++;
        if (widthTotal > columnWidthTotal) {
            columnWidthTotal = widthTotal;
        }
        if (cloumnIndex >= column.list.length) {
            cloumnIndex = 0;
            widthTotal = 0;
            if (rowHeight !== 0) {
                rowHeightTotal += (rowHeight + gridRowGap);
            }
            else {
                rowHeightTotal += (child.height + gridRowGap);
            }
            if (!column.isInfinity)
                rowIndex++;
        }
    }
    columnWidthTotal = Math.max(target.width, columnWidthTotal - gridColumnGap);
    rowHeightTotal = Math.max(target.height, rowHeightTotal - gridRowGap);
    target.width = columnWidthTotal;
    target.height = rowHeightTotal;
    CSSBasicLayout_1.$tempRectangle.width = columnWidthTotal;
    CSSBasicLayout_1.$tempRectangle.height = rowHeightTotal;
    return CSSBasicLayout_1.$tempRectangle;
}
exports.updateGridLayout = updateGridLayout;


/***/ }),

/***/ "./src/layout/CSSLayout.ts":
/*!*********************************!*\
  !*** ./src/layout/CSSLayout.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDisplayLayout = exports.measure = exports.$TempMeasureRectangle = exports.$TempLayoutRectangle = exports.$TempyAlignRectangle = void 0;
var CSSGridLayout_1 = __webpack_require__(/*! ./CSSGridLayout */ "./src/layout/CSSGridLayout.ts");
var CSSBasicLayout_1 = __webpack_require__(/*! ./CSSBasicLayout */ "./src/layout/CSSBasicLayout.ts");
var UIKeys = __webpack_require__(/*! ../core/DisplayLayoutKeys */ "./src/core/DisplayLayoutKeys.ts");
exports.$TempyAlignRectangle = new vf.Rectangle();
exports.$TempLayoutRectangle = new vf.Rectangle();
exports.$TempMeasureRectangle = new vf.Rectangle();
function updateDisplayAlign(target, parentWidth, parentHeight, marginTop, marginLeft) {
    if (marginTop === void 0) { marginTop = 0; }
    if (marginLeft === void 0) { marginLeft = 0; }
    if (target.style == undefined) {
        return false;
    }
    if (target.style.justifyContent == undefined && target.style.alignContent == undefined) {
        return false;
    }
    var oldX = target.x;
    var oldY = target.y;
    var startX = 0;
    var startY = 0;
    var bounds = target.getPreferredBounds(exports.$TempyAlignRectangle);
    switch (target.style.justifyContent) {
        case "center":
            startX = parentWidth - bounds.width >> 1;
            break;
        case "flex-start":
            startX = marginLeft;
            break;
        case "flex-end":
            startX = parentWidth - bounds.width - (marginLeft);
            break;
    }
    switch (target.style.alignContent) {
        case "center":
            startY = parentHeight - bounds.height >> 1;
            break;
        case "flex-start":
            startY = marginTop;
            break;
        case "flex-end":
            startY = parentHeight - bounds.height - (marginTop);
            break;
    }
    if (startX !== 0)
        target.x = startX;
    if (startY !== 0)
        target.y = startY;
    if (oldX !== startX || oldY !== startY) {
        return true;
    }
    return false;
}
/**
 * @private
 * 一个工具方法，使用BasicLayout规则测量目标对象。
 */
function measure(target) {
    if (!target) {
        return;
    }
    var width = 0;
    var height = 0;
    var bounds = exports.$TempMeasureRectangle;
    var count = target.uiChildren.length;
    for (var i = 0; i < count; i++) {
        var layoutElement = target.uiChildren[i];
        if (!layoutElement.includeInLayout) {
            continue;
        }
        var values = layoutElement.$values;
        var hCenter = +values[UIKeys.horizontalCenter];
        var vCenter = +values[UIKeys.verticalCenter];
        var left = +values[UIKeys.left];
        var right = +values[UIKeys.right];
        var top_1 = +values[UIKeys.top];
        var bottom = +values[UIKeys.bottom];
        var extX = void 0;
        var extY = void 0;
        layoutElement.getPreferredBounds(bounds);
        if (!isNaN(left) && !isNaN(right)) {
            extX = left + right;
        }
        else if (!isNaN(hCenter)) {
            extX = Math.abs(hCenter) * 2;
        }
        else if (!isNaN(left) || !isNaN(right)) {
            extX = isNaN(left) ? 0 : left;
            extX += isNaN(right) ? 0 : right;
        }
        else {
            extX = bounds.x;
        }
        if (!isNaN(top_1) && !isNaN(bottom)) {
            extY = top_1 + bottom;
        }
        else if (!isNaN(vCenter)) {
            extY = Math.abs(vCenter) * 2;
        }
        else if (!isNaN(top_1) || !isNaN(bottom)) {
            extY = isNaN(top_1) ? 0 : top_1;
            extY += isNaN(bottom) ? 0 : bottom;
        }
        else {
            extY = bounds.y;
        }
        var preferredWidth = bounds.width;
        var preferredHeight = bounds.height;
        width = Math.ceil(Math.max(width, extX + preferredWidth));
        height = Math.ceil(Math.max(height, extY + preferredHeight));
    }
    target.setMeasuredSize(width, height);
}
exports.measure = measure;
/**
 * 调整目标的元素的大小并定位这些元素。
 */
function updateDisplayLayout(target, unscaledWidth, unscaledHeight) {
    if (target.style == undefined) {
        return;
    }
    // if(target.parent){
    //     target.parent.validateNow();
    // }
    if (target.style.display === "block") {
        var pos = CSSBasicLayout_1.updateBasicDisplayList(target, unscaledWidth, unscaledHeight);
        //console.log(pos);
    }
    else if (target.style.display === "grid") {
        var size = CSSGridLayout_1.updateGridLayout(target);
        CSSBasicLayout_1.updateBasicDisplayList(target, size.width, size.height);
    }
    var isUpdateTransform = false;
    if (target.parent) {
        isUpdateTransform = updateDisplayAlign(target, target.parent.width, target.parent.height, target.style.gridRowGap, target.style.gridColumnGap);
    }
    if (target.isContainer) {
        var bounds = target.getPreferredBounds(exports.$TempLayoutRectangle);
        var child = void 0;
        for (var i = 0; i < target.uiChildren.length; i++) {
            child = target.uiChildren[i];
            isUpdateTransform = updateDisplayAlign(child, bounds.width, bounds.height, child.style.gridRowGap, child.style.gridColumnGap);
        }
    }
    if (isUpdateTransform) {
        target.updateTransform();
    }
}
exports.updateDisplayLayout = updateDisplayLayout;


/***/ }),

/***/ "./src/layout/CSSSSystem.ts":
/*!**********************************!*\
  !*** ./src/layout/CSSSSystem.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** ===================== mask  ===================== */
Object.defineProperty(exports, "__esModule", { value: true });
exports.lineWidth = exports.ColorRGBA = exports.color = exports.updateFontStyle = void 0;
// export function maskPosition(target: DisplayObject) {
//     if (target.style == undefined) {
//         return;
//     }
//     if (target.$mask) {
//         const style = target.style;
//         if (style.maskPosition === undefined) {
//             return;
//         }
//         if (target.$mask instanceof DisplayObject) {
//             target.$mask.x = style.maskPosition[0];
//             target.$mask.y = style.maskPosition[1];
//         } else {
//             target.$mask.position.set(style.maskPosition[0], style.maskPosition[1])
//         }
//     }
// }
// export function maskSize(target: DisplayObject) {
//     if (target.style == undefined) {
//         return;
//     }
//     if (target.$mask) {
//         const style = target.style;
//         if (style.maskSize === undefined) {
//             return;
//         }
//         target.$mask.width = style.maskSize[0];
//         target.$mask.height = style.maskSize[1];
//         if (target.$mask instanceof vf.Graphics) {
//             //target.$mask.clone
//         }
//         if (!(target.$mask instanceof DisplayObject))
//             target.$mask.updateTransform();
//     }
// }
// export function maskImage(target: DisplayObject) {
//     if (target.style == undefined) {
//         return;
//     }
//     target.container.mask = null as any;
//     if (target.$mask && target.$mask.parent) {
//         if (target.$mask instanceof DisplayObject) {
//             target.removeChild(target.$mask);
//         } else {
//             target.$mask.parent.removeChild(target.$mask);
//         }
//     }
//     for (let i = 0; i < target.uiChildren.length; i++) {
//         if (target.uiChildren[i].name == "maskImage") {
//             target.removeChild(target.uiChildren[i]);
//             break;
//         }
//     }
//     target.$mask = undefined;
//     const style = target.style;
//     const container = target.container;
//     let maskdisplay = getDisplayObject(style.maskImage, target) as MaskSprite | vf.Graphics | string;
//     if (maskdisplay == null && style.maskImage instanceof vf.Graphics) {
//         maskdisplay = style.maskImage as vf.Graphics;
//     }
//     if (maskdisplay == null || maskdisplay === '') {
//         return;
//     }
//     if (maskdisplay instanceof vf.Graphics) {
//         target.$mask = maskdisplay;
//         container.mask = target.$mask;
//         container.addChild(target.$mask);
//     } else if (maskdisplay instanceof DisplayObject) {
//         if (maskdisplay.maskSprite) {
//             target.$mask = maskdisplay;//gui组件
//             target.$mask.name = "maskImage";
//             if(maskdisplay.maskSprite() === undefined){ // 后续修复，原因是image组件中的sprite还没创建
//                 setTimeout(() => {
//                     container.mask = (maskdisplay as any).maskSprite() || null;//vf组件
//                 }, 60);
//             }else{
//                 container.mask = maskdisplay.maskSprite() || null;//vf组件
//             }
//             if (maskdisplay.parent == undefined) {
//                 target.addChild(maskdisplay);
//             }
//         }
//     } else {
//         target.$mask = vf.Sprite.from(getTexture(style.maskImage));
//         container.mask = target.$mask;
//         container.addChild(target.$mask);
//     }
//     maskSize(target);
//     maskPosition(target)
// }
/** ===================== font  ===================== */
function updateFontStyle(target, key, value) {
    if (target.setInputStyle) {
        target.setInputStyle(key, value);
    }
    else if (target.setRichLabelStyle) { //富文本
        target.setRichLabelStyle(key, value);
    }
    else if (target.sprite && target.sprite.style) {
        target.sprite.style[key] = value;
    }
}
exports.updateFontStyle = updateFontStyle;
function color(target, key, value) {
    if (target.setInputStyle) {
        target.setInputStyle(key, value);
    }
    else {
        target.color = value;
    }
}
exports.color = color;
// 图形文字通用
function ColorRGBA(target, key, value) {
    if (target[key] === undefined) {
        console.warn("\u8BBF\u95EE\u7684\u5C5E\u6027" + key + "\u4E0D\u5B58\u5728", target);
    }
    switch (key) {
        case "fillColor":
            target.fillColor = value;
            target.fillAlpha = value[3];
            break;
        case "lineColor":
            target.lineColor = value;
            target.lineAlpha = value[3];
            break;
    }
    // if (target instanceof GraphBase) {
    // } else if (target instanceof Label) {
    //     if (value.length === 0) {
    //         target.color = undefined;
    //     } else {
    //         target.color = `rgba(${value[0]}, ${value[1]}, ${value[2]}, ${value[3]})`;
    //     }
    // }
}
exports.ColorRGBA = ColorRGBA;
// 图形文字通用
function lineWidth(target, key, value) {
    if (target[key] === undefined) {
        console.warn("\u8BBF\u95EE\u7684\u5C5E\u6027" + key + "\u4E0D\u5B58\u5728", target);
    }
    target.lineWidth = value;
}
exports.lineWidth = lineWidth;


/***/ }),

/***/ "./src/layout/CSSStyle.ts":
/*!********************************!*\
  !*** ./src/layout/CSSStyle.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CSSStyle = void 0;
var CSSFunction = __webpack_require__(/*! ./CSSSSystem */ "./src/layout/CSSSSystem.ts");
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Utils_2 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
/**
 * 组件样式表
 */
var CSSStyle = /** @class */ (function () {
    function CSSStyle(target) {
        /**
         * 规定元素的显示类型。布局模式
         *
         * grid 模式下，子节点会忽略left,top,right，bottom,width,height等
         *
         * none 模式下，忽略style
         * */
        this._display = "block";
        /**
         * 规定元素的定位类型。
         * */
        this._position = "absolute";
        /**
         * 填充颜色，后面取代Color
         * 数组形式 [r,g,b,a]
         */
        this._fillColor = [];
        /**
         * 支持：图形
         * 边框线条颜色
         * 数组形式 [r,g,b,a]
         */
        this._lineColor = [];
        /**
         * 支持：图形
         * 边框线条宽度
         */
        this._lineWidth = 0;
        /**
         * 文本颜色
         * 16进制RGB 0xffffff ｜ 16777215
         * 数组形式 [r,g,b,a]
         *
         * 默认白色
         * */
        this._color = [255, 255, 255, 1];
        /**
         * 是否自动换行
         * */
        this._wordWrap = false;
        /**
         * 下划线类型
         * */
        this._textDecoration = "None";
        /**
        * 下划线颜色
        * */
        this._textDecorationColor = NaN;
        /**
         * 多行文本(wordWrap = true) - 对齐方式
         * */
        this._textAlign = "center";
        /**
         * 多行文本(wordWrap = true) - 垂直对齐方式
         * */
        this._verticalAlign = "middle";
        /** 字体 示例：fontFamily = "\"Comic Sans MS\", cursive, sans-serif" */
        this._fontFamily = 'Arial';
        this._whiteFamily = ['Arial']; //白名单 通用字体  肯定不走加载
        /** 字体大小 */
        this._fontSize = 22;
        /** 字体样式 */
        this._fontStyle = "normal";
        /**  字体变形，普通或小写  */
        this._fontVariant = "normal";
        this._fontWeight = "normal" /* normal */;
        /** 描边的笔触粗细值 */
        this._strokeThickness = 0;
        /** 是否设置投影 */
        this._dropShadow = false;
        /** 投影的alpha值 */
        this._dropShadowAlpha = false;
        /** 是否设置投影 */
        this._dropShadowAngle = 0; //Math.PI / 6;
        /** 投影的模糊半径 */
        this._dropShadowBlur = 0;
        /** 投影填充颜色值 */
        this._dropShadowColor = 0x000000;
        /** 投影深度 */
        this._dropShadowDistance = 5;
        /**
         * 渐变类型
         *  0 = 垂直渐变
         *  1 = 水平渐变
         */
        this._fillGradientType = 0;
        /** 渐变区间 */
        this._fillGradientStops = [];
        /** 中文换行 */
        this._breakWords = true;
        this.parent = target;
    }
    CSSStyle.prototype.release = function () {
        //
    };
    Object.defineProperty(CSSStyle.prototype, "display", {
        get: function () {
            return this._display;
        },
        set: function (value) {
            this._display = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "position", {
        get: function () {
            return this._position;
        },
        set: function (value) {
            this._position = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "justifyContent", {
        get: function () {
            return this._justifyContent;
        },
        set: function (value) {
            this._justifyContent = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "alignContent", {
        get: function () {
            return this._alignContent;
        },
        set: function (value) {
            this._alignContent = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "gridTemplateColumns", {
        get: function () {
            return this._gridTemplateColumns;
        },
        set: function (value) {
            this._gridTemplateColumns = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "gridColumnGap", {
        get: function () {
            return this._gridColumnGap;
        },
        set: function (value) {
            this._gridColumnGap = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "gridTemplateRows", {
        get: function () {
            return this._gridTemplateRows;
        },
        set: function (value) {
            this._gridTemplateRows = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "gridRowGap", {
        get: function () {
            return this._gridRowGap;
        },
        set: function (value) {
            this._gridRowGap = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "width", {
        /**
         * 表示显示对象的宽度，以像素为单位。
         * */
        get: function () {
            return this.parent.width;
        },
        set: function (value) {
            if (typeof value === 'number') {
                this.parent.width = value;
                this.parent.percentWidth = NaN;
            }
            else {
                this.parent.percentWidth = Utils_1.formatRelative(value, 1);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "height", {
        /**
         * 表示显示对象的高度，以像素为单位。
         * */
        get: function () {
            return this.parent.height;
        },
        set: function (value) {
            if (typeof value === 'number') {
                this.parent.height = value;
                this.parent.percentWidth = NaN;
            }
            else {
                this.parent.percentHeight = Utils_1.formatRelative(value, 1);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "minWidth", {
        /**
         * 设置元素的最小宽度。
         */
        get: function () {
            return this.parent.minWidth;
        },
        set: function (value) {
            this.parent.minWidth = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "maxWidth", {
        /**
         * 设置元素的最大宽度。
         */
        get: function () {
            return this.parent.maxWidth;
        },
        set: function (value) {
            this.parent.maxWidth = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "maxHeight", {
        /**
         * 设置元素的最小高度。
         */
        get: function () {
            return this.parent.maxHeight;
        },
        set: function (value) {
            this.parent.maxHeight = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "minHeight", {
        /**
         * 设置元素的最大高度。
         * */
        get: function () {
            return this.parent.minHeight;
        },
        set: function (value) {
            this.parent.minHeight = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "left", {
        /**
         * 设置定位元素左外边距边界与其容器左边界之间的偏移。
         * */
        get: function () {
            return this.parent.left;
        },
        set: function (value) {
            this.parent.left = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "top", {
        /**
         * 设置定位元素的上外边距边界与其容器上边界之间的偏移。
         * */
        get: function () {
            return this.parent.top;
        },
        set: function (value) {
            this.parent.top = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "right", {
        /**
         * 设置定位元素右外边距边界与其容器右边界之间的偏移。
         * */
        get: function () {
            return this.parent.right;
        },
        set: function (value) {
            this.parent.right = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "bottom", {
        /**
         * 设置定位元素下外边距边界与其容器下边界之间的偏移。
         * */
        get: function () {
            return this.parent.bottom;
        },
        set: function (value) {
            this.parent.bottom = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "scaleX", {
        /**
         * 缩放
         * */
        get: function () {
            return this.parent.scaleX;
        },
        set: function (value) {
            var parent = this.parent;
            parent.scaleX = value;
            parent.invalidateSize();
            parent.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "scaleY", {
        /**
         * 缩放
         * */
        get: function () {
            return this.parent.scaleY;
        },
        set: function (value) {
            var parent = this.parent;
            parent.scaleY = value;
            parent.invalidateSize();
            parent.invalidateParentLayout();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "skewX", {
        /**
         * 设置元素水平拉伸扭曲（角度）。
         * */
        get: function () {
            return this.parent.skewX;
        },
        set: function (value) {
            var parent = this.parent;
            parent.skewX = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "skewY", {
        /**
         * 设置元素垂直拉伸扭曲（角度）。
         * */
        get: function () {
            return this.parent.skewY;
        },
        set: function (value) {
            var parent = this.parent;
            parent.skewY = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "rotate", {
        /**
         * 设置元素旋转 （角度）
        */
        get: function () {
            return this.parent.rotation;
        },
        set: function (value) {
            this.rotation = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "rotation", {
        /**
         * 设置元素旋转 （角度）
        */
        get: function () {
            return this.parent.rotation;
        },
        set: function (value) {
            var parent = this.parent;
            parent.rotation = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "pivotX", {
        /**
         * 轴点 像素值
         */
        get: function () {
            return this.parent.pivotX;
        },
        set: function (value) {
            var parent = this.parent;
            parent.pivotX = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "pivotY", {
        /**
         * 轴点 像素值
         */
        get: function () {
            return this.parent.pivotY;
        },
        set: function (value) {
            var parent = this.parent;
            parent.pivotY = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "tint", {
        /**
          * 调整元素的色调，取消设置0xFFFFFF
          */
        get: function () {
            return this.parent.tint;
        },
        set: function (value) {
            this.parent.tint = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "alpha", {
        /**
         * 表示指定对象的 Alpha 透明度值。有效值为0（完全透明）～ 1（完全不透明）。
         * */
        get: function () {
            return this.parent.alpha;
        },
        set: function (value) {
            this.parent.alpha = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "visible", {
        /**
         * 显示对象是否可见
         * */
        get: function () {
            return this.parent.visible;
        },
        set: function (value) {
            this.parent.visible = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "visibility", {
        get: function () {
            return this.parent.visible ? "visible" : "hidden";
        },
        set: function (value) {
            this.visible = value === "hidden" ? false : true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "backgroundColor", {
        /**
         * 设置元件的背景颜色。（16进制数字0xffffff
         * */
        get: function () {
            return this.parent.$background.color;
        },
        set: function (value) {
            var parent = this.parent;
            parent.$background.type = 1;
            parent.$background.fillColor = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "backgroundRadius", {
        /**
         * 设置元素的背景圆角
         */
        get: function () {
            return this.parent.$background.radius;
        },
        set: function (value) {
            var parent = this.parent;
            parent.$background.radius = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "backgroundImage", {
        /**
         * 设置元素的背景图像。backgroundImage = "./xxx.png"
         * */
        get: function () {
            return this.parent.$background.src;
        },
        set: function (value) {
            var parent = this.parent;
            parent.$background.type = 2;
            parent.$background.src = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "backgroundPositionX", {
        /**
         * 设置 backgroundImage 后 ，设置背景图像的X位置
         * */
        get: function () {
            return this.parent.$background.positionX;
        },
        set: function (value) {
            var parent = this.parent;
            parent.$background.positionX = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "backgroundPositionY", {
        /**
         * 设置 backgroundImage 后 ，设置背景图像的Y位置
         * */
        get: function () {
            return this.parent.$background.positionY;
        },
        set: function (value) {
            var parent = this.parent;
            parent.$background.positionY = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "backgroundSize", {
        /**
         * 设置 backgroundImage 后， 规定背景图像的尺寸。 [width,height]
         * */
        get: function () {
            return this.parent.$background.size;
        },
        set: function (value) {
            var parent = this.parent;
            parent.$background.size = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "backgroundRepeat", {
        /**
         * 设置 backgroundImage 后，设置是否及如何重复背景图像。
         * repeat重复
         * no-repeat不重复，
         */
        get: function () {
            return this.parent.$background.repeat;
        },
        set: function (value) {
            var parent = this.parent;
            parent.$background.repeat = value;
            parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "backgroundAlpha", {
        /**
         * 设置背景透明度
         */
        get: function () {
            return this.parent.$background.alpha;
        },
        set: function (value) {
            var parent = this.parent;
            parent.$background.alpha = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "maskImage", {
        /**
         * 遮罩图
         */
        get: function () {
            return this.parent.$mask.image;
        },
        set: function (value) {
            this.parent.$mask.image = value;
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "maskPosition", {
        /**
         * 设置位数 [x,y]
         */
        get: function () {
            return this.parent.$mask.position;
        },
        set: function (value) {
            this.parent.$mask.position = value;
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "maskSize", {
        /**
         * 设置遮罩位图的大小
         */
        get: function () {
            return this.parent.$mask.size;
        },
        set: function (value) {
            this.parent.$mask.size = value;
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "filter", {
        /**
         * 设置滤镜
         */
        get: function () {
            return this.parent.filter;
        },
        set: function (value) {
            console.error('[VF LOG] 只读属性 filter!');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "cursor", {
        /**
         * 设置鼠标样式
         */
        get: function () {
            return this.parent.container.cursor;
        },
        set: function (value) {
            this.parent.container.cursor = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "fillColor", {
        get: function () {
            return this._fillColor;
        },
        set: function (value) {
            this._fillColor = value;
            CSSFunction.ColorRGBA(this.parent, "fillColor", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "lineColor", {
        get: function () {
            return this._lineColor;
        },
        set: function (value) {
            this._lineColor = value;
            CSSFunction.ColorRGBA(this.parent, "lineColor", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "lineWidth", {
        get: function () {
            return this._lineWidth;
        },
        set: function (value) {
            this._lineWidth = value;
            CSSFunction.lineWidth(this.parent, "lineWidth", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            vf.utils.deprecation("1.0.0", "style.color API近期会被删除，请使用style.fillColor");
            this._color = value;
            CSSFunction.color(this.parent, "color", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "letterSpacing", {
        get: function () {
            return this._letterSpacing;
        },
        set: function (value) {
            this._letterSpacing = value;
            CSSFunction.updateFontStyle(this.parent, "letterSpacing", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "wordWrap", {
        get: function () {
            return this._wordWrap;
        },
        set: function (value) {
            this._wordWrap = value;
            CSSFunction.updateFontStyle(this.parent, "wordWrap", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "wordWrapWidth", {
        get: function () {
            return this._wordWrapWidth;
        },
        set: function (value) {
            this._wordWrapWidth = value;
            if (isNaN(value) || value === undefined || value === null) {
                value = this.width;
            }
            CSSFunction.updateFontStyle(this.parent, "wordWrapWidth", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "textDecoration", {
        get: function () {
            return this._textDecoration;
        },
        set: function (value) {
            this._textDecoration = value;
            CSSFunction.updateFontStyle(this.parent, "textDecoration", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "textDecorationColor", {
        get: function () {
            return this._textDecorationColor;
        },
        set: function (value) {
            var color = undefined;
            color = Utils_1.hexToInt(value, color);
            if (this._textDecorationColor === color) {
                return;
            }
            this._textDecorationColor = color;
            CSSFunction.updateFontStyle(this.parent, "textDecorationColor", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "textAlign", {
        get: function () {
            return this._textAlign;
        },
        set: function (value) {
            this._textAlign = value;
            CSSFunction.updateFontStyle(this.parent, "textAlign", value);
            CSSFunction.updateFontStyle(this.parent, "align", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "verticalAlign", {
        get: function () {
            return this._verticalAlign;
        },
        set: function (value) {
            this._verticalAlign = value;
            CSSFunction.updateFontStyle(this.parent, "verticalAlign", value);
            // CSSFunction.updateFontStyle(this.parent, "align", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "lineHeight", {
        get: function () {
            return this._lineHeight;
        },
        set: function (value) {
            this._lineHeight = value;
            CSSFunction.updateFontStyle(this.parent, "lineHeight", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "fontFamily", {
        get: function () {
            return this._fontFamily;
        },
        set: function (value) {
            var _this = this;
            this._fontFamily = value;
            var familyList = [];
            if (value) {
                var list = [].concat(value);
                if (list) {
                    list.forEach(function (element) {
                        if (element && element !== "") {
                            var item = element;
                            if (element && _this._whiteFamily.indexOf(element) < 0) {
                                var o = Utils_1.getSource(element);
                                if (typeof o === 'object' && o.name) {
                                    item = o.name;
                                }
                            }
                            familyList.push(item);
                        }
                    });
                }
            }
            if (familyList.length === 0) {
                familyList = ['Arial'];
            }
            CSSFunction.updateFontStyle(this.parent, "fontFamily", Utils_2.deepCopy(familyList));
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "fontSize", {
        get: function () {
            return this._fontSize;
        },
        set: function (value) {
            this._fontSize = value;
            CSSFunction.updateFontStyle(this.parent, "fontSize", value);
            this.parent.allInvalidate();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "fontStyle", {
        get: function () {
            return this._fontStyle;
        },
        set: function (value) {
            this._fontStyle = value;
            CSSFunction.updateFontStyle(this.parent, "fontStyle", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "fontVariant", {
        get: function () {
            return this._fontVariant;
        },
        set: function (value) {
            this._fontVariant = value;
            CSSFunction.updateFontStyle(this.parent, "fontVariant", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "fontWeight", {
        /**
         * 字体粗细
         * 枚举 vf.gui.enum.FontWeight
         * */
        get: function () {
            return this._fontWeight;
        },
        set: function (value) {
            this._fontWeight = value;
            CSSFunction.updateFontStyle(this.parent, "fontWeight", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "padding", {
        get: function () {
            return this._padding;
        },
        set: function (value) {
            this._padding = value;
            CSSFunction.updateFontStyle(this.parent, "padding", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "stroke", {
        get: function () {
            return this._stroke;
        },
        set: function (value) {
            this._stroke = value;
            if (Array.isArray(value)) {
                if (value.length === 0) {
                    value = undefined;
                }
                else {
                    value = "rgba(" + value[0] + ", " + value[1] + ", " + value[2] + ", " + value[3] + ")";
                }
            }
            CSSFunction.updateFontStyle(this.parent, "stroke", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "strokeThickness", {
        get: function () {
            return this._strokeThickness;
        },
        set: function (value) {
            this._strokeThickness = value;
            CSSFunction.updateFontStyle(this.parent, "strokeThickness", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "dropShadow", {
        get: function () {
            return this._dropShadow;
        },
        set: function (value) {
            this._dropShadow = value;
            CSSFunction.updateFontStyle(this.parent, "dropShadow", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "dropShadowAlpha", {
        get: function () {
            return this._dropShadowAlpha;
        },
        set: function (value) {
            this._dropShadowAlpha = value;
            CSSFunction.updateFontStyle(this.parent, "dropShadowAlpha", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "dropShadowAngle", {
        get: function () {
            return this._dropShadowAngle;
        },
        set: function (value) {
            this._dropShadowAngle = value;
            CSSFunction.updateFontStyle(this.parent, "dropShadowAngle", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "dropShadowBlur", {
        get: function () {
            return this._dropShadowBlur;
        },
        set: function (value) {
            this._dropShadowBlur = value;
            CSSFunction.updateFontStyle(this.parent, "dropShadowBlur", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "dropShadowColor", {
        get: function () {
            return this._dropShadowColor;
        },
        set: function (value) {
            this._dropShadowColor = value;
            if (Array.isArray(value)) {
                if (value.length === 0) {
                    value = undefined;
                }
                else {
                    CSSFunction.updateFontStyle(this.parent, "dropShadowAlpha", value[3]);
                    value = Utils_1.rgbToNumber(value[0], value[1], value[2]); // `rgba(${value[0]}, ${value[1]}, ${value[2]}, ${value[3]})`;
                }
            }
            CSSFunction.updateFontStyle(this.parent, "dropShadowColor", value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "dropShadowDistance", {
        get: function () {
            return this._dropShadowDistance;
        },
        set: function (value) {
            this._dropShadowDistance = value;
            CSSFunction.updateFontStyle(this.parent, "dropShadowDistance", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "fillGradientType", {
        get: function () {
            return this._fillGradientType;
        },
        set: function (value) {
            this._fillGradientType = value;
            CSSFunction.updateFontStyle(this.parent, "fillGradientType", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "fillGradientStops", {
        get: function () {
            return this._fillGradientStops;
        },
        set: function (value) {
            this._fillGradientStops = value;
            CSSFunction.updateFontStyle(this.parent, "fillGradientStops", value);
            this.parent.invalidateDisplayList();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CSSStyle.prototype, "breakWords", {
        get: function () {
            return this._breakWords;
        },
        set: function (value) {
            this._breakWords = value;
            CSSFunction.updateFontStyle(this.parent, "breakWords", value);
        },
        enumerable: false,
        configurable: true
    });
    return CSSStyle;
}());
exports.CSSStyle = CSSStyle;
/*
CSS3.0 所有样式属性

    background: string | null;
    backgroundAttachment: string | null;
    backgroundClip: string | null;
    // backgroundColor: string | null;
    // backgroundImage: string | null;
    backgroundOrigin: string | null;
    backgroundPosition: string | null;
    // backgroundPositionX: string | null;
    // backgroundPositionY: string | null;
    backgroundRepeat: string | null;
    // backgroundSize: string | null;


    alignContent: string;
    alignItems: string;
    alignSelf: string;
    alignmentBaseline: string | null;
    animation: string;
    animationDelay: string;
    animationDirection: string;
    animationDuration: string;
    animationFillMode: string;
    animationIterationCount: string;
    animationName: string;
    animationPlayState: string;
    animationTimingFunction: string;
    backfaceVisibility: string | null;

    baselineShift: string | null;
    border: string | null;
    borderBottom: string | null;
    borderBottomColor: string | null;
    borderBottomLeftRadius: string | null;
    borderBottomRightRadius: string | null;
    borderBottomStyle: string | null;
    borderBottomWidth: string | null;
    borderCollapse: string | null;
    borderColor: string | null;
    borderImage: string | null;
    borderImageOutset: string | null;
    borderImageRepeat: string | null;
    borderImageSlice: string | null;
    borderImageSource: string | null;
    borderImageWidth: string | null;
    borderLeft: string | null;
    borderLeftColor: string | null;
    borderLeftStyle: string | null;
    borderLeftWidth: string | null;
    borderRadius: string | null;
    borderRight: string | null;
    borderRightColor: string | null;
    borderRightStyle: string | null;
    borderRightWidth: string | null;
    borderSpacing: string | null;
    borderStyle: string | null;
    borderTop: string | null;
    borderTopColor: string | null;
    borderTopLeftRadius: string | null;
    borderTopRightRadius: string | null;
    borderTopStyle: string | null;
    borderTopWidth: string | null;
    borderWidth: string | null;
    // bottom: string | null;
    boxShadow: string | null;
    boxSizing: string;
    breakAfter: string | null;
    breakBefore: string | null;
    breakInside: string | null;
    captionSide: string | null;
    caretColor: string;
    clear: string | null;
    clip: string;
    clipPath: string;
    clipRule: string;
    // color: string | null;
    colorInterpolationFilters: string;
    columnCount: string;
    columnFill: string;
    columnGap: string;
    columnRule: string;
    columnRuleColor: string;
    columnRuleStyle: string;
    columnRuleWidth: string;
    columnSpan: string;
    columnWidth: string;
    columns: string;
    content: string | null;
    counterIncrement: string | null;
    counterReset: string | null;
    cssFloat: string | null;
    cssText: string;
    cursor: string;
    direction: string;
    // display: string | null;
    dominantBaseline: string | null;
    emptyCells: string | null;
    enableBackground: string | null;
    fill: string | null;
    fillOpacity: string | null;
    fillRule: string | null;
    filter: string;
    flex: string | null;
    flexBasis: string | null;
    flexDirection: string | null;
    flexFlow: string | null;
    flexGrow: string | null;
    flexShrink: string | null;
    flexWrap: string | null;
    floodColor: string;
    floodOpacity: string;
    font: string;
    // fontFamily: string;
    fontFeatureSettings: string;
    fontKerning: string;
    // fontSize: string;
    fontSizeAdjust: string;
    fontStretch: string;
    // fontStyle: string;
    fontSynthesis: string;
    // fontVariant: string;
    fontVariantCaps: string;
    fontVariantEastAsian: string;
    fontVariantLigatures: string;
    fontVariantNumeric: string;
    fontVariantPosition: string;
    // fontWeight: string;
    gap: string;
    glyphOrientationHorizontal: string | null;
    glyphOrientationVertical: string;
    grid: string | null;
    gridArea: string | null;
    gridAutoColumns: string | null;
    gridAutoFlow: string | null;
    gridAutoRows: string | null;
    gridColumn: string | null;
    gridColumnEnd: string | null;
    gridColumnGap: string;
    gridColumnStart: string | null;
    gridGap: string;
    gridRow: string | null;
    gridRowEnd: string | null;
    gridRowGap: string;
    gridRowStart: string | null;
    gridTemplate: string | null;
    gridTemplateAreas: string | null;
    gridTemplateColumns: string | null;
    gridTemplateRows: string | null;
    // height: string | null;
    hyphens: string;
    imageOrientation: string;
    imageRendering: string;
    imeMode: string | null;
    justifyContent: string;
    justifyItems: string;
    justifySelf: string;
    kerning: string | null;
    layoutGrid: string | null;
    layoutGridChar: string | null;
    layoutGridLine: string | null;
    layoutGridMode: string | null;
    layoutGridType: string | null;
    // left: string | null;
    readonly length: number;
    // letterSpacing: string;
    lightingColor: string;
    lineBreak: string;
    // lineHeight: string | null;
    listStyle: string | null;
    listStyleImage: string | null;
    listStylePosition: string | null;
    listStyleType: string | null;

    margin: string | null;
    marginBottom: string | null;
    marginLeft: string | null;
    marginRight: string | null;
    marginTop: string | null;

    marker: string | null;
    markerEnd: string | null;
    markerMid: string | null;
    markerStart: string | null;
    mask: string;
    maskComposite: string;
    maskImage: string;
    maskPosition: string;
    maskRepeat: string;
    maskSize: string;
    maskType: string;

    // maxHeight: string | null;
    // maxWidth: string | null;
    // minHeight: string | null;
    // minWidth: string | null;

    objectFit: string;
    objectPosition: string;
    opacity: string | null;
    order: string | null;
    orphans: string | null;
    outline: string;
    outlineColor: string;
    outlineOffset: string;
    outlineStyle: string;
    outlineWidth: string;

    overflow: string;
    overflowAnchor: string;
    overflowWrap: string;
    overflowX: string;
    overflowY: string;

    padding: string | null;
    paddingBottom: string | null;
    paddingLeft: string | null;
    paddingRight: string | null;
    paddingTop: string | null;

    pageBreakAfter: string | null;
    pageBreakBefore: string | null;
    pageBreakInside: string | null;
    readonly parentRule: CSSRule;
    penAction: string | null;
    perspective: string | null;
    perspectiveOrigin: string | null;
    placeContent: string;
    placeItems: string;
    placeSelf: string;
    pointerEvents: string | null;
    // position: string | null;
    quotes: string | null;
    resize: string;
    // right: string | null;
    rotate: string | null;
    rowGap: string;
    rubyAlign: string | null;
    rubyOverhang: string | null;
    rubyPosition: string | null;
    // scale: string | null;
    scrollBehavior: string;
    stopColor: string | null;
    stopOpacity: string | null;

    stroke: string | null;
    strokeDasharray: string | null;
    strokeDashoffset: string | null;
    strokeLinecap: string | null;
    strokeLinejoin: string | null;
    strokeMiterlimit: string | null;
    strokeOpacity: string | null;
    strokeWidth: string | null;

    tabSize: string;
    tableLayout: string | null;
    // textAlign: string;
    textAlignLast: string;
    textAnchor: string | null;
    textCombineUpright: string;
    textDecoration: string;
    textDecorationColor: string;
    textDecorationLine: string;
    textDecorationStyle: string;
    textEmphasis: string;
    textEmphasisColor: string;
    textEmphasisPosition: string;
    textEmphasisStyle: string;
    textIndent: string;
    textJustify: string;
    textKashida: string | null;
    textKashidaSpace: string | null;
    textOrientation: string;
    textOverflow: string;
    textShadow: string;
    textTransform: string;
    textUnderlinePosition: string;
    // top: string | null;
    touchAction: string;
    transform: string;
    transformBox: string;
    transformOrigin: string;
    transformStyle: string | null;
    transition: string;
    transitionDelay: string;
    transitionDuration: string;
    transitionProperty: string;
    transitionTimingFunction: string;
    translate: string | null;
    unicodeBidi: string;
    userSelect: string;
    verticalAlign: string | null;
    visibility: string | null;

    whiteSpace: string;
    widows: string | null;
    // width: string | null;
    willChange: string;
    wordBreak: string;
    wordSpacing: string;
    // wordWrap: string;
    writingMode: string;
    // zIndex: string | null;
    zoom: string | null;
    */


/***/ }),

/***/ "./src/tween/Easing.ts":
/*!*****************************!*\
  !*** ./src/tween/Easing.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Easing = void 0;
/**
 * 完整的缓动曲线列表
 *
 * @example vf.gui.Easing.Linear.None;
 *
 */
exports.Easing = {
    Linear: {
        None: function (k) {
            return k;
        }
    },
    Quadratic: {
        In: function (k) {
            return Math.pow(k, 2);
        },
        Out: function (k) {
            return k * (2 - k);
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(k, 2);
            }
            return -0.5 * (--k * (k - 2) - 1);
        }
    },
    Cubic: {
        In: function (k) {
            return Math.pow(k, 3);
        },
        Out: function (k) {
            return --k * k * k + 1;
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(k, 3);
            }
            return 0.5 * ((k -= 2) * k * k + 2);
        }
    },
    Quartic: {
        In: function (k) {
            return Math.pow(k, 4);
        },
        Out: function (k) {
            return 1 - --k * k * k * k;
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(k, 4);
            }
            return -0.5 * ((k -= 2) * k * k * k - 2);
        }
    },
    Quintic: {
        In: function (k) {
            return Math.pow(k, 5);
        },
        Out: function (k) {
            return --k * k * k * k * k + 1;
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(k, 5);
            }
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        }
    },
    Sinusoidal: {
        In: function (k) {
            return 1 - Math.cos((k * Math.PI) / 2);
        },
        Out: function (k) {
            return Math.sin((k * Math.PI) / 2);
        },
        InOut: function (k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        }
    },
    Exponential: {
        In: function (k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        },
        Out: function (k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        },
        InOut: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(1024, k - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        }
    },
    Circular: {
        In: function (k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        Out: function (k) {
            return Math.sqrt(1 - --k * k);
        },
        InOut: function (k) {
            if ((k *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        }
    },
    Elastic: {
        In: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
        },
        Out: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            k *= 2;
            if (k < 1) {
                return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
        }
    },
    Back: {
        In: function (k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        },
        Out: function (k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        },
        InOut: function (k) {
            var s = 1.70158 * 1.525;
            if ((k *= 2) < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
            }
            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        }
    },
    Bounce: {
        In: function (k) {
            return 1 - exports.Easing.Bounce.Out(1 - k);
        },
        Out: function (k) {
            var x = 2.75;
            var y = 7.5625;
            if (k < 1 / x) {
                return y * k * k;
            }
            else if (k < 2 / x) {
                return y * (k -= 1.5 / x) * k + 0.75;
            }
            else if (k < 2.5 / x) {
                return y * (k -= 2.25 / x) * k + 0.9375;
            }
            else {
                return y * (k -= 2.625 / x) * k + 0.984375;
            }
        },
        InOut: function (k) {
            if (k < 0.5) {
                return exports.Easing.Bounce.In(k * 2) * 0.5;
            }
            return exports.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
        }
    },
    Stepped: {
        steps: function (steps) { return function (k) { return ((k * steps) | 0) / steps; }; }
    }
};


/***/ }),

/***/ "./src/tween/TimeLine.ts":
/*!*******************************!*\
  !*** ./src/tween/TimeLine.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable no-prototype-builtins */
/**
 * 基于帧的时间轴控制类
    *
 * @example let timeline = new vf.gui.Timeline();
 *
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeLine = exports.TimeLineDataItem = exports.TimeLineDefaultData = void 0;
var Tween_1 = __webpack_require__(/*! ./Tween */ "./src/tween/Tween.ts");
var Ticker_1 = __webpack_require__(/*! ../core/Ticker */ "./src/core/Ticker.ts");
var core_1 = __webpack_require__(/*! ./private/core */ "./src/tween/private/core.ts");
var TimeLineDefaultData = /** @class */ (function () {
    function TimeLineDefaultData() {
        this.delay = 0; //时间轴动画开始之前的延迟秒数）
        this.paused = false; //如果设置为true，时间轴将在创建时立即暂停.
        this.repeat = 0; //动画在第一次完成后应重复的次数。例如，如果repeat为1，则动画将总共播放两次（初始播放加1次重复）。要无限重复，请使用-1。
        this.yoyo = false;
    }
    return TimeLineDefaultData;
}());
exports.TimeLineDefaultData = TimeLineDefaultData;
var TimeLineDataItem = /** @class */ (function () {
    function TimeLineDataItem() {
        this.positionTime = NaN;
        this.hasPlay = false;
    }
    return TimeLineDataItem;
}());
exports.TimeLineDataItem = TimeLineDataItem;
//目前timeline 不支持时间线乱序的插入  （由于支持了回放 但是数据结构未做整体调整 下个版本有需要修改)
var TimeLine = /** @class */ (function (_super) {
    __extends(TimeLine, _super);
    function TimeLine(options) {
        var _this = _super.call(this) || this;
        _this._duration = 0; //当前位置  用于顺序播放排位置  播放总长度
        _this._reactDuration = 0; //播放长度
        _this._objList = []; //对象列表 
        _this._propertyList = []; //属性列表   和对象列表一一对应
        _this._pauseTime = NaN;
        _this._currenTimer = 0; //时间轴当前播放时间
        _this._totalRepeat = 0;
        _this._repeat = 0;
        _this._playStates = 0; // 0停止 1正放 2倒放
        _this._oldPlayStates = 0;
        _this._tickIns = undefined;
        _this._isFinite = false;
        _this._needDownGrade = false;
        _this._tweens = [];
        //修改默认参数
        _this._defaultParam = options;
        options.repeat && (_this._repeat = _this._totalRepeat = options.repeat);
        if (!_this._defaultParam.paused) {
            _this.play();
        }
        core_1.addTimeLine(_this);
        return _this;
    }
    Object.defineProperty(TimeLine.prototype, "needDownGrade", {
        get: function () {
            return this._needDownGrade;
        },
        set: function (value) {
            this._needDownGrade = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onStart", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onStart = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onStartParams", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onStartParams = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onUpdate", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onUpdate = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onUpdateParams", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onUpdateParams = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onRepeat", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onRepeat = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onRepeatParams", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onRepeatParams = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onComplete", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onComplete = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onCompleteParams", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onCompleteParams = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onReverseComplete", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onReverseComplete = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "onReverseCompleteParams", {
        set: function (value) {
            var _defaultParam = this.getDefaultParam();
            _defaultParam.onReverseCompleteParams = value;
        },
        enumerable: false,
        configurable: true
    });
    TimeLine.prototype.getDefaultParam = function () {
        var _defaultParam = this._defaultParam;
        if (!_defaultParam) {
            _defaultParam = new TimeLineDefaultData();
        }
        return _defaultParam;
    };
    Object.defineProperty(TimeLine.prototype, "playStates", {
        set: function (value) {
            this._playStates = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "duration", {
        get: function () {
            return this._duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "currenTimer", {
        get: function () {
            return this._currenTimer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "reversed", {
        get: function () {
            var states = this._playStates;
            if (this._playStates === 0) {
                states = this._oldPlayStates;
            }
            return states === 2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TimeLine.prototype, "paused", {
        get: function () {
            return this._playStates === 0;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 顺序播放
     *
     */
    TimeLine.prototype.add = function (value, position) {
        var _this = this;
        if (position === void 0) { position = NaN; }
        //begin
        if (Array.isArray(value)) {
            value.map && value.map(function (_v) {
                _this.add(_v, position);
            });
            return this;
        }
        var _defaultParam = this._defaultParam;
        //目前支持tween
        var defaultdelay = _defaultParam.delay ? _defaultParam.delay : 0;
        var item = new TimeLineDataItem();
        if (value instanceof Tween_1.Tween) {
            item.tween = value;
        }
        var delay = (item.tween ? item.tween.delayTime : 0);
        position = isNaN(position) ? 0 : position;
        var during = (item.tween ? Number(item.tween.duration) : 0);
        item.positionTime = position + defaultdelay;
        this._reactDuration = Math.max((during + delay + position), 0);
        this._duration = this._reactDuration + defaultdelay;
        this._tweens.push(item);
        //起始时间排序
        this._tweens.sort(function (a, b) {
            return a.positionTime - b.positionTime;
        });
        //当前to对象
        this._objList = [];
        this._propertyList = [];
        for (var i = 0; i < this._tweens.length; i++) {
            var item_1 = this._tweens[i];
            if (item_1 && item_1.tween) {
                var obj = item_1.tween.object;
                if (this._objList.indexOf(obj) >= 0) {
                    continue;
                }
                else {
                    this._objList.push(obj);
                    var propItem = this.getPropertyList(obj);
                    this._propertyList.push(propItem);
                }
            }
        }
        this.cacheStartData();
        // this.cacheStartDataTest();
        return this;
    };
    // private resetTweenList() {
    //     const { _tweens } = this;
    //     const newTween: TimeLineDataItem[] = [];
    //     let curTimeStamp = 0;
    //     let maxDuration = Number.MAX_VALUE;
    //     for (let i: number = 0; i < _tweens.length; i++) {
    //         const startTime = _tweens[i].positionTime;
    //         for (let i: number = 0; i < _tweens.length; i++) {
    //             const tweenItem = _tweens[i].tween;
    //             const endTime = _tweens[i].positionTime + (tweenItem ? Number(tweenItem.duration) : 0);
    //             if (endTime > startTime) {
    //                 maxDuration = Math.min(maxDuration, endTime);
    //             }
    //         }
    //         //获取了时间区间
    //     }
    //     return newTween;
    // }
    TimeLine.prototype.cacheStartData = function () {
        //这里重新缓存每个item的start数据  便于倒放初始值获取不全问题  导致错乱
        var _tweens = this._tweens;
        var dList = {};
        for (var i = 0; i <= _tweens.length - 1; i++) {
            var item = _tweens[i];
            if (item && item.tween) {
                var objIdx = this._objList.indexOf(item.tween.object);
                var propertyList = this._propertyList[objIdx];
                if (!dList[objIdx]) {
                    dList[objIdx] = {};
                }
                var virtualData = dList[objIdx];
                item.tween._virtualValueStart = {};
                for (var j = propertyList.length - 1; j >= 0; j--) {
                    var p = propertyList[j];
                    var curValue = item.tween.object[p];
                    if (virtualData.hasOwnProperty(p)) {
                        curValue = virtualData[p];
                        //TODO
                    }
                    else {
                        virtualData[p] = curValue;
                        //TODO
                    }
                    item.tween._virtualValueStart[p] = item.tween.valuesStart[p] = curValue;
                    if (!item.tween.valuesEnd.hasOwnProperty(p)) {
                        item.tween.valuesEnd[p] = curValue;
                        //TODO
                    }
                    else {
                        virtualData[p] = item.tween.valuesEnd[p] = item.tween.valuesEnd[p];
                        //TODO
                    }
                }
            }
        }
    };
    // timeline 拆分  并且重新缓存每个item的start数据  便于倒放初始值获取不全问题  导致错乱
    TimeLine.prototype.cacheStartDataTest = function () {
        var _tweens = this._tweens;
        var dList = {};
        var newTweenList = [];
        // //
        // console.error("..", vf.gui.Utils.deepCopy(_tweens));
        // while(){
        // }
        // //分割tween  这是一个比较费时的过程。。
        // for (let i = 0; i <= _tweens.length - 1; i++) {
        //     const item = _tweens[i];
        //     const curStartTime = item.positionTime;
        //     const curDurationTime = item.tween?.duration as number;
        //     const nextItem = this.getNextValue(item.positionTime, i);
        //     if (nextItem.value.length === 0) {
        //         //没有重合的
        //         newTweenList.push(deepCopy(item));
        //     } else {
        //         //
        //         if (nextItem.isStart) {//头 当前tween到最近tween 拆成一个tween  
        //         } else {//下一个是尾巴  所有数组里的属性存起来 合并一个tween
        //         }
        //     }
        // }
        //先根据关键帧  拆分很多个临时tween   根据已有tween数据 合并
        this.cacheStartData();
    };
    //获取最近的值  
    TimeLine.prototype.getNextValue = function (value, index) {
        var _a, _b;
        var _tweens = this._tweens;
        var returnValue = { value: [], isStart: false };
        for (var i = 0; i <= _tweens.length - 1; i++) {
            var item = _tweens[i];
            if (i === index) {
                continue;
            }
            var curStartTime = item.positionTime;
            var curDurationTime = (_a = item.tween) === null || _a === void 0 ? void 0 : _a.duration;
            var v = -1;
            var isStart = false;
            if (curStartTime > value) {
                v = curStartTime;
                isStart = true;
            }
            else if (curDurationTime > value) {
                v = curDurationTime;
                isStart = false;
            }
            if (returnValue.value && returnValue.value[0]) { //只要最近的
                var item_2 = returnValue.value[0];
                var num = returnValue.isStart ? item_2.positionTime : (item_2.positionTime + ((_b = item_2.tween) === null || _b === void 0 ? void 0 : _b.duration));
                if (num > v) {
                    returnValue.value = [item_2];
                    returnValue.isStart = !isStart ? returnValue.isStart : isStart; //多条吻合  只取处于周期内的tween
                }
                else if (num === v) {
                    returnValue.value.push(item_2);
                }
            }
        }
        return returnValue;
    };
    TimeLine.prototype.getPropertyList = function (obj) {
        var _tweens = this._tweens;
        var propertyList = [];
        for (var i = _tweens.length - 1; i >= 0; i--) {
            var item = _tweens[i];
            if (item && item.tween && item.tween.object === obj) {
                for (var p in item.tween.valuesEnd) {
                    if (propertyList.indexOf(p) >= 0) {
                        continue;
                    }
                    propertyList.push(p);
                }
            }
        }
        return propertyList;
    };
    TimeLine.prototype.toStartData = function (dis) {
        var _tweens = this._tweens;
        var cacheObj = [];
        for (var i = 0; i < _tweens.length; i++) {
            var itemTween = _tweens[i].tween;
            if (itemTween) {
                var obj = itemTween.object;
                if (cacheObj.indexOf(obj) >= 0) {
                    itemTween.stop();
                    continue;
                }
                cacheObj.push(obj);
                var time = (this._playStates === 2 ? (Number(itemTween.duration) - dis) : dis);
                itemTween.gotoAndStop(time);
            }
        }
    };
    /**
     *
     * 获取时刻数据
     */
    TimeLine.prototype.setTimeProries = function (timer) {
        var _tweens = this._tweens;
        var tList = [];
        for (var i = 0; i < _tweens.length; i++) {
            var item = _tweens[i];
            var tween = item.tween;
            if (!tween || timer < item.positionTime) {
                continue;
            }
            tList.push(item);
        }
        tList.sort(function (a, b) {
            if (!a.tween || !b.tween) {
                return 0;
            }
            return (a.positionTime + Number(a.tween.duration)) - (b.positionTime + Number(b.tween.duration));
        });
        for (var i = 0; i < tList.length; i++) {
            var item = tList[i];
            var tween = item.tween;
            if (!tween) {
                continue;
            }
            var duration = tween ? Number(tween.duration) : 0;
            if (timer >= item.positionTime) {
                tween.gotoAndStop(Math.min(timer - item.positionTime, duration));
            }
            else {
                continue;
            }
        }
    };
    /**
     *
     */
    TimeLine.prototype.addPause = function (position, callback, paranms) {
        if (position === void 0) { position = NaN; }
        this._pauseTime = (isNaN(position) ? this._currenTimer : position);
        this._pauseCallBack = callback;
        this._pauseCallBackParam = paranms;
        return this;
    };
    /**
     * 相当于 add(TweenLite.to(...))
     */
    TimeLine.prototype.to = function (element, duration, options, position) {
        var tween = new Tween_1.Tween(element);
        var opt = {};
        if (this._defaultParam && this._defaultParam.ease) {
            tween.easing(this._defaultParam.ease);
            tween.easingReverse(this._defaultParam.ease);
        }
        for (var property in options) {
            var value = options[property];
            switch (property) {
                case "yoyo":
                    tween.yoyo(value);
                    break;
                case "repeat":
                    tween.repeat(value);
                    tween["repeat"].call(this, value);
                    break;
                case "ease":
                    tween.easing(value);
                    tween.easingReverse(value);
                    break;
                case "onStart":
                case "onStartParams":
                case "onUpdate":
                case "onUpdateParams":
                case "onComplete":
                case "onCompleteParams":
                case "onRepeat":
                case "onRepeatParams":
                case "onReverseComplete":
                case "onReverseCompleteParams":
                    tween[property] = options[property];
                    break;
                default:
                    if (typeof value !== 'function') {
                        opt[property] = value;
                    }
                    break;
            }
        }
        tween.to(opt, duration);
        this.add(tween, position);
        return this;
    };
    /**
     *
     */
    TimeLine.prototype.play = function (timer) {
        if (timer === void 0) { timer = NaN; }
        var _defaultParam = this._defaultParam;
        this.playStates = 1;
        this._oldPlayStates = this._playStates;
        if (!isNaN(timer)) {
            this._currenTimer = timer;
        }
        if (this._currenTimer === 0 && _defaultParam && _defaultParam.onStart) {
            _defaultParam.onStart(_defaultParam.onStartParams);
        }
        !this._tickIns && (this._tickIns = Ticker_1.TickerShared.add(this.onUpdata, this));
    };
    /**
     * 暂停
     */
    TimeLine.prototype.pause = function () {
        this._oldPlayStates = this._playStates;
        this.addPause(this._currenTimer);
    };
    /**
     *
     */
    TimeLine.prototype.resume = function () {
        this.playStates = this._oldPlayStates;
        !this._tickIns && (this._tickIns = Ticker_1.TickerShared.add(this.onUpdata, this));
    };
    /**
     * 跳转
     */
    TimeLine.prototype.seek = function (timer) {
        this._currenTimer = timer;
        this.setTimeProries(timer);
        // this._playStates = 1;
    };
    /**
     * 倒放
     */
    TimeLine.prototype.reverse = function (timer) {
        if (timer === void 0) { timer = NaN; }
        if (this._playStates === 2) {
            return;
        }
        if (!isNaN(timer)) {
            this._currenTimer = timer; //跳转
        }
        this.playStates = 2;
        this._oldPlayStates = this._playStates;
        if (!this._isFinite) {
            this._repeat = this._totalRepeat >= 0 ? this._totalRepeat - this._repeat : -1;
        }
        !this._tickIns && (this._tickIns = Ticker_1.TickerShared.add(this.onUpdata, this));
    };
    /**
     * 刷新
     */
    TimeLine.prototype.onUpdata = function (time) {
        var _a = this, _tweens = _a._tweens, _playStates = _a._playStates, _defaultParam = _a._defaultParam;
        if ((_playStates === 0 || !_tweens || _tweens.length <= 0)) {
            return;
        }
        if (this.needDownGrade === true && this._repeat >= 0) {
            Ticker_1.TickerShared.remove(this.onUpdata, this);
            this._tickIns = undefined;
            if (_defaultParam.yoyo === true) {
                this._playStates = (this._repeat % 2 === 1 ? 2 : 1);
            }
            var time_1 = (this._playStates === 1 ? this.duration : 0);
            this.seek(time_1);
            this.complete(); //结束
            return;
        }
        if (this._isFinite === true) {
            this._isFinite = false;
        }
        //
        if (_playStates !== 0) {
            this.playUpdate();
        }
    };
    TimeLine.prototype.playUpdate = function () {
        var _a = this, _duration = _a._duration, _playStates = _a._playStates, _defaultParam = _a._defaultParam;
        if (_playStates === 0) {
            return;
        }
        if (_defaultParam && _defaultParam.onUpdate) {
            _defaultParam.onUpdate(_defaultParam.onUpdateParams);
        }
        if (_playStates === 1) {
            this._currenTimer += Ticker_1.TickerShared.deltaMS;
        }
        else {
            this._currenTimer -= Ticker_1.TickerShared.deltaMS;
        }
        var elapsed; //当前完成比例 倒放当前比例加正放 ===1
        var time = this._currenTimer;
        elapsed = time / _duration;
        elapsed = elapsed > 1 ? 1 : elapsed;
        elapsed = elapsed < 0 ? 0 : elapsed;
        //根据elsapse 播放
        this.tweenItemPlay();
        //循环检测
        this.checkNextRepeat(elapsed);
        //遇到暂停
        this.checkPause();
    };
    TimeLine.prototype.checkPause = function () {
        var _a = this, _tweens = _a._tweens, _playStates = _a._playStates, _pauseCallBack = _a._pauseCallBack, _pauseCallBackParam = _a._pauseCallBackParam;
        if (!isNaN(this._pauseTime) && ((this._currenTimer >= this._pauseTime && _playStates === 1) || (this._currenTimer <= this._pauseTime && _playStates === 2))) {
            //暂停
            this.playStates = 0;
            this._pauseTime = NaN;
            if (_pauseCallBack) {
                _pauseCallBack(_pauseCallBackParam);
                this._pauseCallBack = undefined;
                this._pauseCallBackParam = undefined;
            }
            var i = 0;
            while (i < _tweens.length) {
                var item = _tweens[i].tween;
                item && item.isPlaying && item.pause();
                // console.log("暂停了", i, this._currenTimer - _tweens[i].positionTime);
                i++;
            }
            // this._tickIns = false;
            // TickerShared.remove(this.onUpdata, this);
            return;
        }
    };
    TimeLine.prototype.tweenItemPlay = function () {
        var _a = this, _tweens = _a._tweens, _playStates = _a._playStates;
        var time = this._currenTimer;
        for (var i = 0; i < _tweens.length; i++) {
            var item = _tweens[i];
            var timing = time - item.positionTime;
            if (_playStates === 2) {
                timing = (item.tween ? Number(item.tween.duration) : 0) - timing;
            }
            if (!item || !item.tween) {
                continue;
            }
            var rev = item.tween.reversed();
            var dur = Number(item.tween.duration);
            if (timing >= 0) { // 播放中或者播放完
                if (timing < item.tween.duration) {
                    if ((_playStates === 2 && rev === false) || (_playStates === 1 && rev === true)) {
                        item.tween.reverse(!rev, timing); //倒放
                    }
                    if (item.tween.isPlaying === false) {
                        item.hasPlay = true;
                        item.tween.gotoAndPlay(timing);
                    }
                }
                else { // 播放完 检测  防止duration小于一帧 导致的未播放跳过问题
                    if (item.hasPlay === false) {
                        if ((_playStates === 2 && rev === false) || (_playStates === 1 && rev === true)) {
                            item.tween.reverse(!rev, timing); //倒放
                        }
                        item.hasPlay = true;
                        if (item.tween.isPlaying === false) {
                            item.tween.gotoAndEnd();
                        }
                    }
                }
            }
        }
    };
    TimeLine.prototype.checkNextRepeat = function (elapsed) {
        var _a = this, _repeat = _a._repeat, _defaultParam = _a._defaultParam;
        if ((elapsed === 1 || (this._playStates === 2 && elapsed === 0)) && this.checkTweensComplete()) {
            if (_repeat) {
                this._repeat--;
                if (!_defaultParam.yoyo || (_defaultParam.yoyo && this._playStates !== 2)) {
                    _defaultParam && _defaultParam.onRepeat && _defaultParam.onRepeat(_defaultParam.onRepeatParams);
                }
                else {
                    _defaultParam && _defaultParam.onStart && _defaultParam.onStart(_defaultParam.onStartParams);
                }
                this.toNext(); //循环
            }
            else {
                this.complete(); //结束
            }
        }
    };
    TimeLine.prototype.checkTweensComplete = function () {
        for (var i = 0; i < this._tweens.length; i++) {
            var item = this._tweens[i];
            if (!item.tween) {
                continue;
            }
            if (item.tween.isPlaying) {
                return false;
            }
        }
        return true;
    };
    TimeLine.prototype.toNext = function () {
        var _a = this, _duration = _a._duration, _defaultParam = _a._defaultParam;
        this.stopAll();
        var dis = (this._playStates === 2 ? Math.abs(this._currenTimer) : (this._currenTimer - this.duration));
        if (_defaultParam.yoyo) {
            this._playStates = (this._playStates === 2 ? 1 : 2);
        }
        else {
            this.toStartData(dis);
        }
        this._currenTimer = (this._playStates === 2 ? (_duration - dis) : dis);
    };
    TimeLine.prototype.complete = function () {
        var _defaultParam = this._defaultParam;
        this._isFinite = true;
        this.stopAll();
        this._repeat = this._totalRepeat;
        // 播放完成
        if (this._playStates === 2) {
            this.playStates = 0;
            _defaultParam && _defaultParam.onReverseComplete && _defaultParam.onReverseComplete(_defaultParam.onReverseCompleteParams);
        }
        else if (this._playStates === 1) {
            this.playStates = 0;
            _defaultParam && _defaultParam.onComplete && _defaultParam.onComplete(_defaultParam.onCompleteParams);
        }
    };
    TimeLine.prototype.stopAll = function () {
        var _tweens = this._tweens;
        for (var i = 0; i < _tweens.length; i++) {
            var item = _tweens[i];
            if (item && item.tween) {
                item.tween.stop();
                item.hasPlay = false;
            }
        }
    };
    TimeLine.prototype.release = function () {
        core_1.removeTimeLine(this);
        this._tickIns = undefined;
        this._defaultParam = undefined;
        this._duration = 0;
        this._reactDuration = 0;
        this._objList = [];
        this._propertyList = [];
        this._pauseTime = NaN;
        this._pauseCallBack = undefined;
        this._pauseCallBackParam = undefined;
        this._currenTimer = 0;
        this._totalRepeat = 0;
        this._repeat = 0;
        this._playStates = 0;
        this._oldPlayStates = 0;
        this._tickIns = undefined;
        if (this._tweens) {
            for (var i = 0; i < this._tweens.length; i++) {
                var item = this._tweens[i];
                if (item && item.tween) {
                    item.tween.release();
                }
            }
            this._tweens = [];
        }
        Ticker_1.TickerShared.remove(this.onUpdata, this);
    };
    return TimeLine;
}(vf.utils.EventEmitter));
exports.TimeLine = TimeLine;


/***/ }),

/***/ "./src/tween/Tween.ts":
/*!****************************!*\
  !*** ./src/tween/Tween.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tween = void 0;
var Utils_1 = __webpack_require__(/*! ../utils/Utils */ "./src/utils/Utils.ts");
var Easing_1 = __webpack_require__(/*! ./Easing */ "./src/tween/Easing.ts");
var Interpolation_1 = __webpack_require__(/*! ./private/Interpolation */ "./src/tween/private/Interpolation.ts");
var core_1 = __webpack_require__(/*! ./private/core */ "./src/tween/private/core.ts");
var constants_1 = __webpack_require__(/*! ./private/constants */ "./src/tween/private/constants.ts");
var TweenEvent_1 = __webpack_require__(/*! ../event/TweenEvent */ "./src/event/TweenEvent.ts");
var defaultEasing = Easing_1.Easing.Linear.None;
/**
 * 缓动动画
 *
 * @example let tween = new vf.gui.Tween(myObject).to({width:'300px'}, 2000).start()
 *
 */
var Tween = /** @class */ (function (_super) {
    __extends(Tween, _super);
    function Tween(object) {
        var _this = _super.call(this) || this;
        _this._valuesEnd = null;
        _this._duration = 1000;
        _this._easingFunction = defaultEasing;
        _this._easingReverse = defaultEasing;
        _this._startTime = 0;
        _this._delayTime = 0;
        _this._repeat = 0;
        _this._initRepeat = 0;
        _this._isPlaying = false;
        _this._yoyo = false;
        _this._reversed = false;
        _this._onStartCallbackFired = false;
        _this._isFinite = true;
        _this._prevTime = 0;
        _this._rendered = false;
        _this._reverseDelayTime = 0;
        /** 附加数据 */
        _this.data = {};
        _this._needDownGrade = false;
        _this.id = Utils_1.uid();
        _this.object = object;
        _this._valuesStart = Array.isArray(object) ? [] : {};
        _this._interpolationFunction = Interpolation_1.Interpolation.Linear;
        return _this;
    }
    /**
     * Easier way to call the Tween
     * @param {object} object - Initial value
     * @param {object} to - Target value
     * @param {object} params - Options of tweens
     * @example Tween.fromTo(myObject, {x:0}, {x:200},1000)
     * @memberof vf.gui.Tween
     * @static
     */
    Tween.fromTo = function (object, to, duration) {
        var tween = new Tween(object).to(to, duration);
        return tween;
    };
    /**
     * Easier way calling constructor only applies the `to` value, useful for CSS Animation
     * @param {any} object object
     * @param {object} to - Target value
     * @param {object} params - Options of tweens
     * @example Tween.to(myObject, {x:200}, 1000)
     * @memberof vf.gui.Tween
     * @static
     */
    Tween.to = function (object, to, duration) {
        return Tween.fromTo(object, to, duration);
    };
    /**
     * Easier way calling constructor only applies the `from` value, useful for CSS Animation
     * @param {any} object object
     * @param {object} from - Initial value
     * @param {object} params - Options of tweens
     * @example Tween.from(myObject, {x:200}, 1000)
     * @memberof vf.gui.Tween
     * @static
     */
    Tween.from = function (object, from, duration) {
        return Tween.fromTo(object, from, duration);
    };
    Tween.prototype.setObject = function (object) {
        this.object = object;
        this._valuesStart = Array.isArray(object) ? [] : {};
    };
    Tween.prototype.onFunction = function (eventType, object, elapsed) {
        switch (eventType) {
            case TweenEvent_1.TweenEvent.update:
                this.onUpdate && this.onUpdate(this.onUpdateParams);
                break;
            case TweenEvent_1.TweenEvent.start:
                this.onStart && this.onStart(this.onStartParams);
                break;
            case TweenEvent_1.TweenEvent.complete:
                if (this.reversed() === true) {
                    this.onReverseComplete && this.onReverseComplete(this.onReverseCompleteParams);
                }
                else {
                    this.onComplete && this.onComplete(this.onCompleteParams);
                }
                break;
            case TweenEvent_1.TweenEvent.repeat:
                this.onRepeat && this.onRepeat(this.onRepeatParams);
                break;
        }
        this.emit(eventType, object, elapsed);
    };
    Object.defineProperty(Tween.prototype, "needDownGrade", {
        get: function () {
            return this._needDownGrade;
        },
        set: function (value) {
            this._needDownGrade = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tween.prototype, "isPlaying", {
        /**
         * 是否在播放中
         * @return {boolean}
         * @example tween.isPlaying()
         * @memberof vf.gui.Tween
         */
        get: function () {
            return this._isPlaying;
        },
        set: function (value) {
            this._isPlaying = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tween.prototype, "valuesEnd", {
        get: function () {
            return this._valuesEnd;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tween.prototype, "valuesStart", {
        get: function () {
            return this._valuesStart;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tween.prototype, "isStarted", {
        /**
         * 是否开始播放
         * @return {boolean}
         * @example tween.isStarted()
         * @memberof vf.gui.Tween
         */
        get: function () {
            return this._onStartCallbackFired;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tween.prototype, "delayTime", {
        get: function () {
            return this._delayTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tween.prototype, "startTime", {
        /**
         * 获取动画的开始时间
         */
        get: function () {
            return this._startTime;
        },
        /**
         * 获取动画的开始时间
         */
        set: function (value) {
            this._startTime = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tween.prototype, "duration", {
        get: function () {
            return this._duration;
        },
        /**
         * 设置缓动时长
         * @param {number} amount 持续的毫秒值
         * @example tween.duration(2000)
         * @memberof vf.gui.Tween
         * @deprecated 不推荐使用这个方法，内部使用
         * @private
         */
        set: function (amount) {
            this._duration = typeof amount === 'function' ? amount(this._duration) : amount;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 逆向缓动
     * @example tween.reverse()
     * @param {boolean=} state 是否逆向
     * @memberof vf.gui.Tween
     */
    Tween.prototype.reverse = function (state, timer) {
        if (timer === void 0) { timer = NaN; }
        var _reversed = this._reversed;
        if (!isNaN(timer)) {
            this._prevTime = timer;
        }
        this._reversed = state !== undefined ? state : !_reversed;
        return this;
    };
    /**
     * 当前动画是否逆转
     * @return {boolean}
     * @example tween.reversed() true逆向中
     * @memberof vf.gui.Tween
     */
    Tween.prototype.reversed = function () {
        return this._reversed;
    };
    /**
     * 暂停缓动
     * @example tween.pause()
     * @memberof vf.gui.Tween
     */
    Tween.prototype.pause = function () {
        if (!this._isPlaying) {
            return this;
        }
        this.isPlaying = false;
        core_1.remove(this);
        return this.emit(TweenEvent_1.TweenEvent.pause, this.object);
    };
    /**
     * 播放或恢复播放
     * @example tween.play()
     * @memberof vf.gui.Tween
     */
    Tween.prototype.play = function () {
        if (this._isPlaying) {
            return this;
        }
        this.isPlaying = true;
        this._startTime = 0;
        core_1.add(this);
        return this.emit(TweenEvent_1.TweenEvent.play, this.object);
    };
    /**
     * 设置要缓动的目标属性与持续时间
     * @param {object} properties 目标属性值
     * @param {number|Object=} [duration=1000] 持续时间
     * @example let tween = new vf.gui.Tween({x:0}).to({x:100}, 2000)
     * @memberof vf.gui.Tween
     */
    Tween.prototype.to = function (properties, duration) {
        if (duration === void 0) { duration = 1000; }
        this._valuesEnd = properties;
        this._duration = duration;
        return this;
    };
    Tween.prototype.render = function () {
        if (this._rendered) {
            return this;
        }
        var _a = this, _valuesStart = _a._valuesStart, _valuesEnd = _a._valuesEnd, object = _a.object;
        if (!_valuesStart.processed) {
            for (var property in _valuesEnd) {
                var start = object && object[property] && Utils_1.deepCopy(object[property]);
                _valuesStart[property] = start || 0;
                constants_1.decompose(property, object, _valuesStart, _valuesEnd);
            }
            _valuesStart.processed = true;
        }
        this._rendered = true;
        return this;
    };
    /**
     * 开始执行缓动
     * @example tween.start()
     * @memberof vf.gui.Tween
     */
    Tween.prototype.start = function () {
        this._startTime += this._delayTime;
        this._prevTime = 0;
        this._onStartCallbackFired = false;
        this._rendered = false;
        this._isPlaying = true;
        core_1.add(this);
        // 直达终点
        if (this._needDownGrade === true && this._repeat >= 0) {
            this.toEnd();
        }
        return this;
    };
    Tween.prototype.toEnd = function () {
        if (this._yoyo === true) {
            this._reversed = (this._repeat % 2 === 1 ? true : false);
        }
        this._repeat = -1;
        this.gotoAndEnd();
    };
    /**
     * 停止缓动
     * @example tween.stop()
     * @memberof vf.gui.Tween
     */
    Tween.prototype.stop = function () {
        var _a = this, _isPlaying = _a._isPlaying, _isFinite = _a._isFinite, object = _a.object, _duration = _a._duration, _initRepeat = _a._initRepeat, _yoyo = _a._yoyo, _reversed = _a._reversed;
        if (!_isPlaying) {
            return this;
        }
        this.isPlaying = false;
        var atStart = _isFinite ? (_initRepeat + 1) % 2 === 1 : !_reversed;
        this._reversed = false;
        if (_yoyo && atStart) {
            this._prevTime = _duration;
        }
        else {
            this._prevTime = 0;
        }
        this.update(0);
        core_1.remove(this);
        return this.emit(TweenEvent_1.TweenEvent.stop, object);
    };
    /**
     * 设置延迟执行时间
     * @param {number} amount 延迟等待的时间，毫秒
     * @example tween.delay(500)
     * @memberof vf.gui.Tween
     */
    Tween.prototype.delay = function (amount) {
        this._delayTime = amount;
        return this;
    };
    /**
     * 设置重复执行的次数
     * @param {number} amount 重复次数
     * @example tween.repeat(5)
     * @memberof vf.gui.Tween
     */
    Tween.prototype.repeat = function (amount) {
        this._repeat = amount; //!this._duration ? 0 : amount;
        this._initRepeat = this._repeat;
        this._isFinite = isFinite(amount);
        return this;
    };
    /**
     * 设置每个重复执行过程的延迟时间，毫秒
     * @param {number} amount 延迟值
     * @example tween.reverseDelay(500)
     * @memberof vf.gui.Tween
     */
    Tween.prototype.reverseDelay = function (amount) {
        this._reverseDelayTime = amount;
        return this;
    };
    /**
     * 是否在重复执行中启用反向动画
     * @param {boolean} state true启动
     * @param {Function=} _easingReverse 反向时的Easing function
     * @example tween.yoyo(true)
     * @memberof vf.gui.Tween
     */
    Tween.prototype.yoyo = function (state, _easingReverse) {
        this._yoyo = typeof state === 'function' ? state(this._yoyo) : state === null ? this._yoyo : state;
        if (!state) {
            this._reversed = false;
        }
        if (_easingReverse) {
            this._easingReverse = _easingReverse;
        }
        else {
            this._easingReverse = this._easingFunction;
        }
        return this;
    };
    /**
     * 设置缓动函数
     * @param {Function} _easingFunction 缓动函数的公式，如果设置yoyo的第二个值会应用于逆向缓动
     * @example tween.easing(Easing.Elastic.InOut)
     * @memberof vf.gui.Tween
     */
    Tween.prototype.easing = function (_easingFunction) {
        this._easingFunction = _easingFunction;
        return this;
    };
    Tween.prototype.easingReverse = function (_easingReverse) {
        this._easingReverse = _easingReverse;
        return this;
    };
    /**
     * 设置差值
     * @param {Function} _interpolationFunction 差值的函数
     * @example tween.interpolation(Interpolation.Bezier)
     * @memberof vf.gui.Tween
     */
    Tween.prototype.interpolation = function (_interpolationFunction) {
        if (typeof _interpolationFunction === 'function') {
            this._interpolationFunction = _interpolationFunction;
        }
        return this;
    };
    /**
     * 更新动画到指定时间点，进行播放
     * @param time
     */
    Tween.prototype.gotoAndPlay = function (time) {
        this._prevTime = time;
        // this._isPlaying = true;
        // this.update(0);
        this.play();
    };
    /**
     * 更新动画到指定时间点，停止播放
     * @param time
     */
    Tween.prototype.gotoAndStop = function (time) {
        this._prevTime = time;
        this._isPlaying = true;
        this.update(0);
        this.pause();
    };
    /**
     * 更新动画到指定时间点，停止播放
     * @param time
     */
    Tween.prototype.gotoAndEnd = function () {
        this._prevTime = this._duration;
        if (!this._isPlaying) { // 未播放 则强刷
            this._isPlaying = true;
            this.update(this._prevTime);
        }
    };
    /**
     * 更新函数，通过给定的 `time` 设置目标属性变化
    * @param {number=} deltaTime 帧间隔
    * @param {Boolean=} preserve 完成后，防止删除动画对象
     * @param {boolean=} forceTime 强制进行更新渲染，不关心时间是否匹配
     * @example tween.update(100)
     * @memberof vf.gui.Tween
     */
    Tween.prototype.update = function (deltaTime, preserve, forceTime) {
        var _a = this, _onStartCallbackFired = _a._onStartCallbackFired, _easingFunction = _a._easingFunction, _easingReverse = _a._easingReverse, _delayTime = _a._delayTime, _reverseDelayTime = _a._reverseDelayTime, _yoyo = _a._yoyo, _startTime = _a._startTime, _duration = _a._duration, _valuesStart = _a._valuesStart, _valuesEnd = _a._valuesEnd, object = _a.object, _isFinite = _a._isFinite, _isPlaying = _a._isPlaying;
        if (!_isPlaying || (_startTime > 0 && !forceTime)) {
            this._startTime -= deltaTime;
            this._startTime = Math.max(0, this._startTime);
            return true;
        }
        var _reversed = this._reversed;
        var elapsed;
        var property;
        var _repeat = this._repeat;
        if (!_duration) {
            if (_yoyo) {
                _reversed = (_repeat % 2 === 1) ? true : false;
            }
            elapsed = _reversed ? 0 : 1;
            _repeat = 0;
        }
        else {
            this._prevTime += deltaTime;
            if (deltaTime > constants_1.TOO_LONG_FRAME_MS && core_1.isRunning() && core_1.isLagSmoothing()) {
                this._prevTime -= constants_1.FRAME_MS;
            }
            elapsed = (this._prevTime) / _duration;
            elapsed = elapsed > 1 ? 1 : elapsed;
            elapsed = _reversed ? 1 - elapsed : elapsed;
        }
        if (!_onStartCallbackFired) {
            if (!this._rendered) {
                this.render();
                this._rendered = true;
            }
            this.onFunction(TweenEvent_1.TweenEvent.start, object);
            this._onStartCallbackFired = true;
        }
        var currentEasing = _reversed ? _easingReverse || _easingFunction : _easingFunction;
        var startV = _valuesStart;
        if (this._virtualValueStart) {
            startV = this._virtualValueStart;
        }
        for (property in _valuesEnd) {
            var start = startV[property];
            var end = _valuesEnd[property];
            var value = currentEasing[property] ? currentEasing[property](elapsed) : typeof currentEasing === 'function' ? currentEasing(elapsed) : defaultEasing(elapsed);
            if (typeof end === 'number') {
                object[property] = start + (end - start) * value;
            }
            else if (typeof end === 'boolean') {
                object[property] = end;
                elapsed = _reversed ? 0 : 1;
            }
            else { //颜色
                constants_1.recompose(property, object, startV, _valuesEnd, value, elapsed);
            }
            // else if (Array.isArray(end) && !(end as any).isString && !Array.isArray(start)) {
            //     const _interpolationFunctionCall = _interpolationFunction[property]
            //     ? _interpolationFunction[property] : typeof _interpolationFunction === 'function' ? _interpolationFunction : Interpolation.Linear;
            //     object[property] = _interpolationFunctionCall(end, value, object[property]);
            // } 
        }
        this.onFunction(TweenEvent_1.TweenEvent.update, object, elapsed);
        if (elapsed === 1 || (_reversed && elapsed === 0)) {
            this._prevTime = 0;
            if (_repeat > 0 && _duration > 0) {
                if (_isFinite) {
                    this._repeat--;
                }
                if (_yoyo) {
                    this._reversed = !_reversed;
                }
                this.onFunction(_yoyo && !_reversed ? TweenEvent_1.TweenEvent.reverse : TweenEvent_1.TweenEvent.repeat, object);
                if (_reversed && _reverseDelayTime) {
                    this._startTime = _reverseDelayTime;
                }
                else {
                    this._startTime = _delayTime;
                }
                return true;
            }
            else {
                if (!preserve) {
                    this.isPlaying = false;
                    core_1.remove(this);
                }
                this.onFunction(TweenEvent_1.TweenEvent.complete, object);
                this._repeat = this._initRepeat;
                return false;
            }
        }
        return true;
    };
    Tween.prototype.release = function () {
        this.object = undefined;
        this.stop();
    };
    Tween.core = { add: core_1.add, get: core_1.get, getAll: core_1.getAll, remove: core_1.remove, removeAll: core_1.removeAll, removeDisplay: core_1.removeDisplay, update: core_1.update };
    Tween.Event = TweenEvent_1.TweenEvent;
    return Tween;
}(vf.utils.EventEmitter));
exports.Tween = Tween;


/***/ }),

/***/ "./src/tween/private/Interpolation.ts":
/*!********************************************!*\
  !*** ./src/tween/private/Interpolation.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Interpolation = void 0;
var constants_1 = __webpack_require__(/*! ./constants */ "./src/tween/private/constants.ts");
/**
 * 差值计算列表
 * @example
 *
 * let bezier = vf.gui.tween.Interpolation.Bezier
 * new vf.gui.tween.Tween({x:0}).to({x:[0, 4, 8, 12, 15, 20, 30, 40, 20, 40, 10, 50]}, 1000).interpolation(bezier).start()
 * @memberof vf.gui.tween
 */
exports.Interpolation = {
    Linear: function (v, k, value) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = exports.Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f, value);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f, value);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i, value);
    },
    Bezier: function (v, k, value) {
        var b = exports.Interpolation.Utils.Reset(value);
        var n = v.length - 1;
        var pw = Math.pow;
        var fn = exports.Interpolation.Utils.Bernstein;
        var isBArray = Array.isArray(b);
        for (var i = 0; i <= n; i++) {
            if (typeof b === 'number') {
                b += pw(1 - k, n - i) * pw(k, i) * v[i] * fn(n, i);
            }
            else if (isBArray) {
                for (var p = 0, len = b.length; p < len; p++) {
                    if (typeof b[p] === 'number') {
                        b[p] += pw(1 - k, n - i) * pw(k, i) * v[i][p] * fn(n, i);
                    }
                    else {
                        b[p] = v[i][p];
                    }
                }
            }
            else if (typeof b === 'object') {
                for (var p in b) {
                    if (typeof b[p] === 'number') {
                        b[p] += pw(1 - k, n - i) * pw(k, i) * v[i][p] * fn(n, i);
                    }
                    else {
                        b[p] = v[i][p];
                    }
                }
            }
            else if (typeof b === 'string') {
                var STRING_BUFFER = '';
                var idx = Math.round(n * k);
                var vCurr = v[idx];
                for (var ks = 1, len = vCurr.length; ks < len; ks++) {
                    STRING_BUFFER += vCurr[ks];
                }
                return STRING_BUFFER;
            }
        }
        return b;
    },
    CatmullRom: function (v, k, value) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = exports.Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0) {
                i = Math.floor((f = m * (1 + k)));
            }
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i, value);
        }
        else {
            if (k < 0) {
                return fn(v[1], v[1], v[0], v[0], -k, value);
            }
            if (k > 1) {
                return fn(v[m - 1], v[m - 1], v[m], v[m], (k | 0) - k, value);
            }
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i, value);
        }
    },
    Utils: {
        Linear: function (p0, p1, t, v) {
            if (p0 === p1 || typeof p0 === 'string') {
                // Quick return for performance reason
                if (p1.length && p1.splice && p1.isString) {
                    p1 = '';
                    for (var i = 0, len = p0.length; i < len; i++) {
                        p1 += p0[i];
                    }
                }
                return p1;
            }
            else if (typeof p0 === 'number') {
                return typeof p0 === 'function' ? p0(t) : p0 + (p1 - p0) * t;
            }
            else if (typeof p0 === 'object') {
                if (p0.length !== undefined) {
                    var isForceStringProp = typeof p0[0] === 'string' || p0.isString;
                    if (isForceStringProp || p0[0] === constants_1.STRING_PROP) {
                        var STRING_BUFFER = '';
                        for (var i = isForceStringProp ? 0 : 1, len = p0.length; i < len; i++) {
                            var currentValue = t === 0 ? p0[i] : t === 1 ? p1[i] : typeof p0[i] === 'number' ? p0[i] + (p1[i] - p0[i]) * t : p1[i];
                            if ((t > 0 && t < 1 && constants_1.isRGBColor(p0, i)) || constants_1.isRGBColor(p0, i, constants_1.RGBA)) {
                                currentValue |= 0;
                            }
                            STRING_BUFFER += currentValue;
                        }
                        return STRING_BUFFER;
                    }
                    else if (v && v.length && v.splice) {
                        for (var p = 0, len = v.length; p < len; p++) {
                            v[p] = exports.Interpolation.Utils.Linear(p0[p], p1[p], t, v[p]);
                        }
                    }
                }
                else {
                    for (var p in v) {
                        v[p] = exports.Interpolation.Utils.Linear(p0[p], p1[p], t, v[p]);
                    }
                }
                return v;
            }
        },
        Reset: function (value) {
            if (Array.isArray(value)) {
                for (var i = 0, len = value.length; i < len; i++) {
                    value[i] = exports.Interpolation.Utils.Reset(value[i]);
                }
                return value;
            }
            else if (typeof value === 'object') {
                for (var i in value) {
                    value[i] = exports.Interpolation.Utils.Reset(value[i]);
                }
                return value;
            }
            else if (typeof value === 'number') {
                return 0;
            }
            return value;
        },
        Bernstein: function (n, i) {
            var fc = exports.Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: (function () {
            var a = [1];
            return function (n) {
                var s = 1;
                if (a[n]) {
                    return a[n];
                }
                for (var i = n; i > 1; i--) {
                    s *= i;
                }
                a[n] = s;
                return s;
            };
        })(),
        CatmullRom: function (p0, p1, p2, p3, t, v) {
            if (typeof p0 === 'string') {
                return p1;
            }
            else if (typeof p0 === 'number') {
                var v0 = (p2 - p0) * 0.5;
                var v1 = (p3 - p1) * 0.5;
                var t2 = t * t;
                var t3 = t * t2;
                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            }
            else if (typeof p0 === 'object') {
                if (p0.length !== undefined) {
                    if (p0[0] === constants_1.STRING_PROP) {
                        var STRING_BUFFER = '';
                        for (var i = 1, len = p0.length; i < len; i++) {
                            var currentValue = typeof p0[i] === 'number' ? exports.Interpolation.Utils.CatmullRom(p0[i], p1[i], p2[i], p3[i], t) : p3[i];
                            if (constants_1.isRGBColor(p0, i) || constants_1.isRGBColor(p0, i, constants_1.RGBA)) {
                                currentValue |= 0;
                            }
                            STRING_BUFFER += currentValue;
                        }
                        return STRING_BUFFER;
                    }
                    for (var p = 0, len = v.length; p < len; p++) {
                        v[p] = exports.Interpolation.Utils.CatmullRom(p0[p], p1[p], p2[p], p3[p], t, v[p]);
                    }
                }
                else {
                    for (var p in v) {
                        v[p] = exports.Interpolation.Utils.CatmullRom(p0[p], p1[p], p2[p], p3[p], t, v[p]);
                    }
                }
                return v;
            }
        }
    }
};


/***/ }),

/***/ "./src/tween/private/constants.ts":
/*!****************************************!*\
  !*** ./src/tween/private/constants.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SET_NESTED = exports.recompose = exports.isRGBColor = exports.RGBA = exports.RGB = exports.decompose = exports.decomposeString = exports.NUM_REGEX = exports.STRING_PROP = exports.CHAINED_TWEENS = exports.TOO_LONG_FRAME_MS = exports.FRAME_MS = void 0;
var Utils_1 = __webpack_require__(/*! ../../utils/Utils */ "./src/utils/Utils.ts");
/**
 * 卡帧后的平滑处理帧率
 */
exports.FRAME_MS = 50 / 3;
/**
 * 平滑处理允许的触发时间
 */
exports.TOO_LONG_FRAME_MS = 250;
/**
 * 链式补间动画的key前缀
 */
exports.CHAINED_TWEENS = '_chainedTweens';
// For String tweening stuffs
exports.STRING_PROP = 'STRING_PROP';
// Also RegExp's for string tweening
exports.NUM_REGEX = /\s+|([A-Za-z?().,{}:""[\]#%]+)|([-+]=+)?([-+]+)?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]=?\d+)?/g;
var isNaNForST = function (v) { return isNaN(+v) || ((v[0] === '+' || v[0] === '-') && v[1] === '=') || v === '' || v === ' '; };
var hexColor = /^#([0-9a-f]{6}|[0-9a-f]{3})$/gi;
var hex2rgbext = function (all) {
    var hex = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        hex[_i - 1] = arguments[_i];
    }
    var rgb = Utils_1.hexToRgb(all);
    return 'rgb(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ')';
};
function decomposeString(fromValue) {
    if (fromValue && fromValue.splice && fromValue.isString) {
        return fromValue;
    }
    if (typeof fromValue !== 'string') {
        return fromValue;
    }
    if (fromValue.charAt(1) === '=') {
        return fromValue;
    }
    var hex = fromValue.replace(hexColor, hex2rgbext).match(exports.NUM_REGEX);
    var value;
    if (hex && hex.map) {
        value = hex.map(function (v) { return (isNaNForST(v) ? v : +v); });
    }
    value.isString = true;
    return value;
}
exports.decomposeString = decomposeString;
// Decompose value, now for only `string` that required
function decompose(prop, obj, from, to) {
    var fromValue = from[prop];
    var toValue = to[prop];
    if (fromValue === toValue) {
        return true;
    }
    else if (Array.isArray(fromValue) && Array.isArray(toValue) && fromValue.length === toValue.length) {
        for (var i = 0, len = toValue.length; i < len; i++) {
            var a = fromValue[i];
            var b = toValue[i];
            if (a === b || (typeof a === 'number' && typeof b === 'number')) {
                continue;
            }
            else {
                decompose(i, obj[prop], fromValue, toValue);
            }
        }
    }
    if (typeof fromValue === 'number' && typeof toValue === 'number') {
        //
    }
    else if (fromValue && fromValue.splice && fromValue.isString && toValue && toValue.splice && toValue.isString) {
        //
    }
    else if (typeof fromValue === 'string' && Array.isArray(toValue)) {
        var fromValue1 = decomposeString(fromValue);
        var toValues = toValue.map(decomposeString);
        from[prop] = fromValue1;
        to[prop] = toValues;
        return true;
    }
    else if (typeof fromValue === 'string' || typeof toValue === 'string') {
        var fromValue1 = Array.isArray(fromValue) && fromValue[0] === exports.STRING_PROP ? fromValue : decomposeString(fromValue);
        var toValue1 = Array.isArray(toValue) && toValue[0] === exports.STRING_PROP ? toValue : decomposeString(toValue);
        if (fromValue1 === undefined) {
            return;
        }
        var i = 1;
        while (i < fromValue1.length) {
            if (fromValue1[i] === toValue1[i] && typeof fromValue1[i - 1] === 'string') {
                fromValue1.splice(i - 1, 2, fromValue1[i - 1] + fromValue1[i]);
                toValue1.splice(i - 1, 2, toValue1[i - 1] + toValue1[i]);
            }
            else {
                i++;
            }
        }
        i = 0;
        if (fromValue1[0] === exports.STRING_PROP) {
            fromValue1.shift();
        }
        if (toValue1[0] === exports.STRING_PROP) {
            toValue1.shift();
        }
        from[prop] = fromValue1;
        to[prop] = toValue1;
        return true;
    }
    else if (typeof fromValue === 'object' && typeof toValue === 'object') {
        if (Array.isArray(fromValue) && !fromValue.isString && fromValue.map) {
            return fromValue.map(function (v, i) { return decompose(i, obj[prop], fromValue, toValue); });
        }
        else {
            for (var prop2 in toValue) {
                decompose(prop2, obj[prop], fromValue, toValue);
            }
        }
        return true;
    }
    return false;
}
exports.decompose = decompose;
// Recompose value
exports.RGB = 'rgb(';
exports.RGBA = 'rgba(';
function isRGBColor(v, i, r) {
    if (r === void 0) { r = exports.RGB; }
    return typeof v[i] === 'number' && (v[i - 1] === r || v[i - 3] === r || v[i - 5] === r);
}
exports.isRGBColor = isRGBColor;
function recompose(prop, obj, from, to, t, originalT, stringBuffer) {
    var fromValue = stringBuffer ? from : from[prop];
    var toValue = stringBuffer ? to : to[prop];
    if (toValue === undefined) {
        return fromValue;
    }
    if (fromValue === undefined || typeof fromValue === 'string' || fromValue === toValue) {
        return toValue;
    }
    else if (typeof fromValue === 'object' && typeof toValue === 'object') {
        if (!fromValue || !toValue) {
            return obj[prop];
        }
        if (typeof fromValue === 'object' &&
            !!fromValue &&
            fromValue.isString &&
            toValue &&
            toValue.splice &&
            toValue.isString) {
            var STRING_BUFFER = '';
            for (var i = 0, len = fromValue.length; i < len; i++) {
                if (fromValue[i] !== toValue[i] || typeof fromValue[i] !== 'number' || typeof toValue[i] === 'number') {
                    var isRelative = typeof fromValue[i] === 'number' && typeof toValue[i] === 'string' && toValue[i][1] === '=';
                    var currentValue = typeof fromValue[i] !== 'number'
                        ? fromValue[i]
                        : isRelative
                            ? fromValue[i] + parseFloat(toValue[i][0] + toValue[i].substr(2)) * t
                            : fromValue[i] + (toValue[i] - fromValue[i]) * t;
                    if (isRGBColor(fromValue, i) || isRGBColor(fromValue, i, exports.RGBA)) {
                        currentValue |= 0;
                    }
                    STRING_BUFFER += currentValue;
                    if (isRelative && originalT === 1) {
                        fromValue[i] = fromValue[i] + parseFloat(toValue[i][0] + toValue[i].substr(2));
                    }
                }
                else {
                    STRING_BUFFER += fromValue[i];
                }
            }
            if (!stringBuffer) {
                obj[prop] = STRING_BUFFER;
            }
            return STRING_BUFFER;
        }
        else if (Array.isArray(fromValue) && fromValue[0] !== exports.STRING_PROP) {
            for (var i = 0, len = fromValue.length; i < len; i++) {
                if (fromValue[i] === toValue[i] || typeof obj[prop] === 'string') {
                    continue;
                }
                recompose(i, obj[prop], fromValue, toValue, t, originalT);
            }
        }
        else if (typeof fromValue === 'object' && !!fromValue && !fromValue.isString) {
            for (var i in fromValue) {
                if (fromValue[i] === toValue[i]) {
                    continue;
                }
                recompose(i, obj[prop], fromValue, toValue, t, originalT);
            }
        }
    }
    else if (typeof fromValue === 'number') {
        var isRelative = typeof toValue === 'string';
        obj[prop] = isRelative
            ? fromValue + parseFloat(toValue[0] + toValue.substr(2)) * t
            : fromValue + (toValue - fromValue) * t;
        if (isRelative && originalT === 1) {
            from[prop] = obj[prop];
        }
    }
    else if (typeof toValue === 'function') {
        obj[prop] = toValue(t);
    }
    return obj[prop];
}
exports.recompose = recompose;
// Dot notation => Object structure converter
// example
// {'scale.x.y.z':'VALUE'} => {scale:{x:{y:{z:'VALUE'}}}}
// Only works for 3-level parsing, after 3-level, parsing dot-notation not works as it's not affects
var propRegExp = /([.[])/g;
var replaceBrace = /\]/g;
var propExtract = function (obj, property) {
    var value = obj[property];
    var props = property.replace(replaceBrace, '').split(propRegExp);
    var propsLastIndex = props.length - 1;
    var lastArr = Array.isArray(obj);
    var lastObj = typeof obj === 'object' && !lastArr;
    if (lastObj) {
        obj[property] = null;
        delete obj[property];
    }
    else if (lastArr) {
        obj.splice(property, 1);
    }
    return props.reduce(function (nested, prop, index) {
        if (lastArr) {
            if (prop !== '.' && prop !== '[') {
                prop *= 1;
            }
        }
        var nextProp = props[index + 1];
        var nextIsArray = nextProp === '[';
        if (prop === '.' || prop === '[') {
            if (prop === '.') {
                lastObj = true;
                lastArr = false;
            }
            else if (prop === '[') {
                lastObj = false;
                lastArr = true;
            }
            return nested;
        }
        else if (nested[prop] === undefined) {
            if (lastArr || lastObj) {
                nested[prop] = index === propsLastIndex ? value : lastArr || nextIsArray ? [] : lastObj ? {} : null;
                lastObj = lastArr = false;
                return nested[prop];
            }
        }
        else if (nested[prop] !== undefined) {
            if (index === propsLastIndex) {
                nested[prop] = value;
            }
            return nested[prop];
        }
        return nested;
    }, obj);
};
exports.SET_NESTED = function (nested) {
    if (typeof nested === 'object' && !!nested) {
        for (var prop in nested) {
            if (prop.indexOf('.') !== -1 || prop.indexOf('[') !== -1) {
                propExtract(nested, prop);
            }
            else if (typeof nested[prop] === 'object' && !!nested[prop]) {
                var nested2 = nested[prop];
                for (var prop2 in nested2) {
                    if (prop2.indexOf('.') !== -1 || prop2.indexOf('[') !== -1) {
                        propExtract(nested2, prop2);
                    }
                    else if (typeof nested2[prop2] === 'object' && !!nested2[prop2]) {
                        var nested3 = nested2[prop2];
                        for (var prop3 in nested3) {
                            if (prop3.indexOf('.') !== -1 || prop3.indexOf('[') !== -1) {
                                propExtract(nested3, prop3);
                            }
                        }
                    }
                }
            }
        }
    }
    return nested;
};


/***/ }),

/***/ "./src/tween/private/core.ts":
/*!***********************************!*\
  !*** ./src/tween/private/core.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.releaseAllTimeLine = exports.removeTimeLine = exports.addTimeLine = exports.isLagSmoothing = exports.isRunning = exports.update = exports.removeDisplay = exports.remove = exports.get = exports.removeAll = exports.getAll = exports.ToggleLagSmoothing = exports.FrameThrottle = exports.add = exports.Plugins = void 0;
var Ticker_1 = __webpack_require__(/*! ../../core/Ticker */ "./src/core/Ticker.ts");
/**
 * 缓动列表
 * @private
 */
var _tweens = [];
/**
 * timeline 列表
 */
var _timeLines = [];
/**
 * 是否运行中
 */
var isStarted = false;
/**
 * 空帧标识
 */
var emptyFrame = 0;
/**
 * 空帧后最大间隔帧率
 */
var powerModeThrottle = 120;
/**
 * 是否开启卡针后平滑处理
 */
var handleLag = true;
/**
 * 插件存储器
 * @memberof vf.gui.tween
 * @example
 * let num = Plugins.num = function (node, start, end) {
  * return t => start + (end - start) * t
  * }
  *
  * @static
  */
exports.Plugins = {};
/**
 * 添加对象到缓动列表
 * @param {Tween} tween Tween 实例
 * @memberof vf.gui.tween
 * @example
 * let tween = new vf.gui.tween.Tween({x:0})
 * tween.to({x:200}, 1000)
 * vf.gui.tween.add(tween)
 */
function add(tween) {
    var i = _tweens.indexOf(tween);
    if (i > -1) {
        _tweens.splice(i, 1);
    }
    _tweens.push(tween);
    emptyFrame = 0;
    isStarted = true;
}
exports.add = add;
/**
 * 没有缓动后，设置运行多少帧后，停止
 * @param {number} frameCount=120 删除所有动画后，要运行的剩余帧
 * @memberof vf.gui.tween
 * @example
 * vf.gui.tween.FrameThrottle(60)
 */
function FrameThrottle(frameCount) {
    if (frameCount === void 0) { frameCount = 120; }
    powerModeThrottle = frameCount * 1.05;
}
exports.FrameThrottle = FrameThrottle;
/**
 * 延时处理，针对插件、canvas、dom
 * @param {number} state=true 是否平滑处理
 * @memberof vf.gui.tween
 * @example
 * vf.gui.tween.ToggleLagSmoothing(false)
 */
function ToggleLagSmoothing(_state) {
    if (_state === void 0) { _state = true; }
    handleLag = _state;
}
exports.ToggleLagSmoothing = ToggleLagSmoothing;
/**
 * 获得所有缓动对象
 * @memberof vf.gui.tween
 * vf.gui.tween.getAll()
 */
function getAll() {
    return _tweens;
}
exports.getAll = getAll;
/**
 * 移除所有动画对象
 * @example  vf.gui.tween.removeAll()
 * @memberof vf.gui.tween
 */
function removeAll() {
    _tweens.length = 0;
    isStarted = false;
}
exports.removeAll = removeAll;
/**
 * 获取对象
 * @param {Tween} tween 缓动对象实例
 * @return {Tween} 返回对象或null
 * @memberof vf.gui.tween
 * @example
 * vf.gui.tween.get(tween)
 */
function get(tween) {
    for (var i = 0; i < _tweens.length; i++) {
        if (tween === _tweens[i]) {
            return _tweens[i];
        }
    }
    return null;
}
exports.get = get;
/**
 * 从缓动列表移除对象
 * @param {Tween} tween Tween instance
 * @memberof vf.gui.tween
 * @example
 * vf.gui.tween.remove(tween)
 */
function remove(tween) {
    var i = _tweens.indexOf(tween);
    if (i !== -1) {
        _tweens.splice(i, 1);
    }
    if (_tweens.length === 0) {
        isStarted = false;
    }
}
exports.remove = remove;
function removeDisplay(uuid) {
    for (var i = 0; i < _tweens.length; i++) {
        if (_tweens[i].object.uuid && uuid === _tweens[i].object.uuid) {
            _tweens[i].stop();
            remove(_tweens[i]);
            return;
        }
    }
    return;
}
exports.removeDisplay = removeDisplay;
/**
 * 按给定时间更新缓动
 * @param {number=} time 时间戳
 * @param {Boolean=} preserve 完成后，防止删除动画对象
 * @memberof vf.gui.tween
 * @example
 * vf.gui.tween.update(500)
 */
function update(deltaTime) {
    if (!isStarted) {
        return false;
    }
    if (emptyFrame >= powerModeThrottle && handleLag) {
        console.log("mptyFrame >= powerModeThrottle && handleLag");
        isStarted = false;
        emptyFrame = 0;
        return false;
    }
    if (!_tweens.length) {
        emptyFrame++;
    }
    var i = 0;
    var length = _tweens.length;
    while (i < length) {
        _tweens[i++].update(Ticker_1.TickerShared.deltaMS, false);
        if (length > _tweens.length) {
            // The tween has been removed, keep same index
            i--;
        }
        length = _tweens.length;
    }
    return true;
}
exports.update = update;
/**
 * 是否正在运行中
 * @return {Boolean} 只要还有缓动在运行，返回true
 * @memberof vf.gui.tween
 * @example vf.gui.tween.isRunning()
 */
function isRunning() {
    return isStarted;
}
exports.isRunning = isRunning;
/**
 * 返回是否开启延迟平滑状态
 * @return {Boolean}
 * @memberof vf.gui.tween
 * @example vf.gui.tween.isRunning()
 */
function isLagSmoothing() {
    return handleLag;
}
exports.isLagSmoothing = isLagSmoothing;
/**
 * 添加到列表
 */
function addTimeLine(timeLine) {
    var i = _timeLines.indexOf(timeLine);
    if (i > -1) {
        _timeLines.splice(i, 1);
    }
    _timeLines.push(timeLine);
}
exports.addTimeLine = addTimeLine;
/**
 * 移除列表
 */
function removeTimeLine(timeLine) {
    var i = _timeLines.indexOf(timeLine);
    if (i !== -1) {
        _timeLines.splice(i, 1);
    }
}
exports.removeTimeLine = removeTimeLine;
/**
 * 销毁所有
 */
function releaseAllTimeLine() {
    _timeLines.forEach(function (item) {
        if (item) {
            item.release();
        }
    });
    _timeLines.length = 0;
}
exports.releaseAllTimeLine = releaseAllTimeLine;


/***/ }),

/***/ "./src/tween/private/index.ts":
/*!************************************!*\
  !*** ./src/tween/private/index.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.TimeLine = exports.TweenEvent = exports.Interpolation = exports.ToggleLagSmoothing = exports.FrameThrottle = exports.isRunning = exports.removeTimeLine = exports.addTimeLine = exports.releaseAllTimeLine = exports.update = exports.add = exports.removeDisplay = exports.remove = exports.removeAll = exports.getAll = exports.get = exports.Plugins = void 0;
var core_1 = __webpack_require__(/*! ./core */ "./src/tween/private/core.ts");
Object.defineProperty(exports, "add", { enumerable: true, get: function () { return core_1.add; } });
Object.defineProperty(exports, "get", { enumerable: true, get: function () { return core_1.get; } });
Object.defineProperty(exports, "getAll", { enumerable: true, get: function () { return core_1.getAll; } });
Object.defineProperty(exports, "isRunning", { enumerable: true, get: function () { return core_1.isRunning; } });
Object.defineProperty(exports, "FrameThrottle", { enumerable: true, get: function () { return core_1.FrameThrottle; } });
Object.defineProperty(exports, "ToggleLagSmoothing", { enumerable: true, get: function () { return core_1.ToggleLagSmoothing; } });
Object.defineProperty(exports, "Plugins", { enumerable: true, get: function () { return core_1.Plugins; } });
Object.defineProperty(exports, "remove", { enumerable: true, get: function () { return core_1.remove; } });
Object.defineProperty(exports, "removeAll", { enumerable: true, get: function () { return core_1.removeAll; } });
Object.defineProperty(exports, "removeDisplay", { enumerable: true, get: function () { return core_1.removeDisplay; } });
Object.defineProperty(exports, "update", { enumerable: true, get: function () { return core_1.update; } });
Object.defineProperty(exports, "addTimeLine", { enumerable: true, get: function () { return core_1.addTimeLine; } });
Object.defineProperty(exports, "removeTimeLine", { enumerable: true, get: function () { return core_1.removeTimeLine; } });
Object.defineProperty(exports, "releaseAllTimeLine", { enumerable: true, get: function () { return core_1.releaseAllTimeLine; } });
var Interpolation_1 = __webpack_require__(/*! ./Interpolation */ "./src/tween/private/Interpolation.ts");
Object.defineProperty(exports, "Interpolation", { enumerable: true, get: function () { return Interpolation_1.Interpolation; } });
var utils = __webpack_require__(/*! ./constants */ "./src/tween/private/constants.ts");
exports.utils = utils;
var TweenEvent_1 = __webpack_require__(/*! ../../event/TweenEvent */ "./src/event/TweenEvent.ts");
Object.defineProperty(exports, "TweenEvent", { enumerable: true, get: function () { return TweenEvent_1.TweenEvent; } });
var TimeLine_1 = __webpack_require__(/*! ../TimeLine */ "./src/tween/TimeLine.ts");
Object.defineProperty(exports, "TimeLine", { enumerable: true, get: function () { return TimeLine_1.TimeLine; } });


/***/ }),

/***/ "./src/utils/GifFrames.ts":
/*!********************************!*\
  !*** ./src/utils/GifFrames.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GifFrame = exports.GifFrames = void 0;
/* eslint-disable */
var GifReader_1 = __webpack_require__(/*! ./GifReader */ "./src/utils/GifReader.ts");
var GifFrames = /** @class */ (function () {
    function GifFrames(_resource) {
        var _a, _b;
        this._frames = [];
        this._gif = new GifReader_1.GifReader('data' in _resource ? _resource.data : _resource);
        var singleTextureWidth = this.calcSingleTextureWidth();
        var imageData = (_b = (_a = document === null || document === void 0 ? void 0 : document.createElement('canvas')) === null || _a === void 0 ? void 0 : _a.getContext('2d')) === null || _b === void 0 ? void 0 : _b.createImageData(this._gif.width, this._gif.height);
        if (isNaN(singleTextureWidth)) {
            for (var i = 0; i < this._gif.numFrames; i++) {
                //得到每帧的信息并将帧延迟信息保存起来
                var gifFrameInfo = this._gif.getFrameInfo(i);
                this._frames.push(new GifFrame(i, this.generateTextureFromGifData(imageData, this._gif, i), gifFrameInfo.delay * 10));
            }
        }
        else {
            var cols = Math.floor(singleTextureWidth / (this._gif.width + 1));
            var rows = Math.ceil(this._gif.numFrames / cols);
            var gridSize = new vf.Point(this._gif.width + 1, this._gif.height + 1);
            var canvas = document.createElement('canvas');
            canvas.width = gridSize.x * cols - 1;
            canvas.height = gridSize.y * rows - 1;
            var ctx = canvas.getContext('2d');
            var lastFrame = undefined;
            for (var i = 0; i < this._gif.numFrames; i++) {
                var col = i % cols;
                var row = Math.floor(i / cols);
                if (lastFrame && lastFrame.disposal == 2) {
                    imageData === null || imageData === void 0 ? void 0 : imageData.data.fill(0);
                }
                lastFrame = this._gif.decodeAndBlitFrameRGBA(i, imageData === null || imageData === void 0 ? void 0 : imageData.data);
                ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(imageData, col * gridSize.x, row * gridSize.y);
            }
            var spriteSheet = vf.BaseTexture.from(canvas);
            for (var i = 0; i < this._gif.numFrames; i++) {
                var col = i % cols;
                var row = Math.floor(i / cols);
                var gifFrameInfo = this._gif.getFrameInfo(i);
                var texture = new vf.Texture(spriteSheet, new vf.Rectangle(col * gridSize.x, row * gridSize.y, this._gif.width, this._gif.height));
                this._frames.push(new GifFrame(i, texture, gifFrameInfo.delay * 10));
            }
        }
    }
    GifFrames.prototype.calcSingleTextureWidth = function () {
        var sizeList = [1024, 2048, 3072, 4096];
        for (var _i = 0, sizeList_1 = sizeList; _i < sizeList_1.length; _i++) {
            var size = sizeList_1[_i];
            var cols = Math.floor(size / (this._gif.width + 1));
            var rows = Math.floor(size / (this._gif.height + 1));
            if (cols * rows >= this._gif.numFrames) {
                return size;
            }
        }
        return Number.NaN;
    };
    Object.defineProperty(GifFrames.prototype, "gif", {
        get: function () {
            return this._gif;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifFrames.prototype, "frames", {
        get: function () {
            return this._frames;
        },
        enumerable: false,
        configurable: true
    });
    GifFrames.prototype.generateTextureFromGifData = function (imageData, gif, frame) {
        var canvas = document.createElement('canvas');
        canvas.width = gif.width;
        canvas.height = gif.height;
        var ctx = canvas.getContext('2d');
        //将第一帧转换为RGBA值，将赋予到图像区
        gif.decodeAndBlitFrameRGBA(frame, imageData.data);
        //将上面创建的图像数据放回到画面上
        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(imageData, 0, 0);
        var spriteSheet = vf.BaseTexture.from(canvas);
        return new vf.Texture(spriteSheet, new vf.Rectangle(0, 0, gif.width, gif.height));
    };
    Object.defineProperty(GifFrames.prototype, "numFrames", {
        get: function () {
            return this._frames.length;
        },
        enumerable: false,
        configurable: true
    });
    GifFrames.prototype.getFrame = function (index) {
        if (index < 0 || index >= this._frames.length) {
            throw new Error('Gif Frame Index out of range');
        }
        return this._frames[index];
    };
    return GifFrames;
}());
exports.GifFrames = GifFrames;
var GifFrame = /** @class */ (function () {
    function GifFrame(index, texture, delayTime) {
        this.index = index;
        this.texture = texture;
        this.delayTime = delayTime;
    }
    return GifFrame;
}());
exports.GifFrame = GifFrame;


/***/ }),

/***/ "./src/utils/GifReader.ts":
/*!********************************!*\
  !*** ./src/utils/GifReader.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GifReader = void 0;
/* eslint-disable */
var GifReader = /** @class */ (function () {
    function GifReader(arrayBuffer) {
        this._frames = [];
        this._loop_count = NaN;
        var p = 0;
        this._buf = new Uint8Array(arrayBuffer);
        var buf = this._buf;
        // - Header (GIF87a or GIF89a).
        if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
            buf[p++] !== 0x38 || (buf[p++] + 1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
            throw new Error("Invalid GIF 87a/89a header.");
        }
        // - Logical Screen Descriptor.
        var width = buf[p++] | buf[p++] << 8;
        var height = buf[p++] | buf[p++] << 8;
        var pf0 = buf[p++]; // <Packed Fields>.
        var global_palette_flag = pf0 >> 7;
        var num_global_colors_pow2 = pf0 & 0x7;
        var num_global_colors = 1 << (num_global_colors_pow2 + 1);
        var background = buf[p++];
        buf[p++]; // Pixel aspect ratio (unused?).
        var global_palette_offset = NaN;
        var global_palette_size = NaN;
        if (global_palette_flag) {
            global_palette_offset = p;
            global_palette_size = num_global_colors;
            p += num_global_colors * 3; // Seek past palette.
        }
        var no_eof = true;
        var delay = 0;
        var transparent_index = NaN;
        // From the spec:
        //     0 -   No disposal specified. The decoder is
        //           not required to take any action.
        //     1 -   Do not dispose. The graphic is to be left
        //           in place.
        //     2 -   Restore to background color. The area used by the
        //           graphic must be restored to the background color.
        //     3 -   Restore to previous. The decoder is required to
        //           restore the area overwritten by the graphic with
        //           what was there prior to rendering the graphic.
        //  4-7 -    To be defined.
        // NOTE(deanm): Dispose background doesn't really work, apparently most
        // browsers ignore the background palette index and clear to transparency.
        var disposal = 0; // 0 - No disposal specified.
        this._width = width;
        this._height = height;
        while (no_eof && p < buf.length) {
            switch (buf[p++]) {
                case 0x21: // Graphics Control Extension Block
                    switch (buf[p++]) {
                        case 0xff: // Application specific block
                            // Try if it's a Netscape block (with animation loop counter).
                            if (buf[p] !== 0x0b || // 21 FF already read, check block size.
                                // NETSCAPE2.0
                                buf[p + 1] == 0x4e && buf[p + 2] == 0x45 && buf[p + 3] == 0x54 &&
                                    buf[p + 4] == 0x53 && buf[p + 5] == 0x43 && buf[p + 6] == 0x41 &&
                                    buf[p + 7] == 0x50 && buf[p + 8] == 0x45 && buf[p + 9] == 0x32 &&
                                    buf[p + 10] == 0x2e && buf[p + 11] == 0x30 &&
                                    // Sub-block
                                    buf[p + 12] == 0x03 && buf[p + 13] == 0x01 && buf[p + 16] == 0) {
                                p += 14;
                                this._loop_count = buf[p++] | buf[p++] << 8;
                                p++; // Skip terminator.
                            }
                            else { // We don't know what it is, just try to get past it.
                                p += 12;
                                while (true) { // Seek through subblocks.
                                    var block_size = buf[p++];
                                    // Bad block size (ex: undefined from an out of bounds read).
                                    if (!(block_size >= 0))
                                        throw Error("Invalid block size");
                                    if (block_size === 0)
                                        break; // 0 size is terminator
                                    p += block_size;
                                }
                            }
                            break;
                        case 0xf9: // Graphics Control Extension
                            if (buf[p++] !== 0x4 || buf[p + 4] !== 0)
                                throw new Error("Invalid graphics extension block.");
                            var pf1 = buf[p++];
                            delay = buf[p++] | buf[p++] << 8;
                            transparent_index = buf[p++];
                            if ((pf1 & 1) === 0)
                                transparent_index = NaN;
                            disposal = pf1 >> 2 & 0x7;
                            p++; // Skip terminator.
                            break;
                        case 0x01: // Plain Text Extension (fallthrough to Comment Extension)
                        case 0xfe: // Comment Extension.
                            while (true) { // Seek through subblocks.
                                var block_size = buf[p++];
                                // Bad block size (ex: undefined from an out of bounds read).
                                if (!(block_size >= 0))
                                    throw Error("Invalid block size");
                                if (block_size === 0)
                                    break; // 0 size is terminator
                                // console.log(buf.slice(p, p+block_size).toString('ascii'));
                                p += block_size;
                            }
                            break;
                        default:
                            throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
                    }
                    break;
                case 0x2c: // Image Descriptor.
                    var x = buf[p++] | buf[p++] << 8;
                    var y = buf[p++] | buf[p++] << 8;
                    var w = buf[p++] | buf[p++] << 8;
                    var h = buf[p++] | buf[p++] << 8;
                    var pf2 = buf[p++];
                    var local_palette_flag = pf2 >> 7;
                    var interlace_flag = pf2 >> 6 & 1;
                    var num_local_colors_pow2 = pf2 & 0x7;
                    var num_local_colors = 1 << (num_local_colors_pow2 + 1);
                    var palette_offset = global_palette_offset;
                    var palette_size = global_palette_size;
                    var has_local_palette = false;
                    if (local_palette_flag) {
                        var has_local_palette = true;
                        palette_offset = p; // Override with local palette.
                        palette_size = num_local_colors;
                        p += num_local_colors * 3; // Seek past palette.
                    }
                    var data_offset = p;
                    p++; // codesize
                    while (true) {
                        var block_size = buf[p++];
                        // Bad block size (ex: undefined from an out of bounds read).
                        if (!(block_size >= 0))
                            throw Error("Invalid block size");
                        if (block_size === 0)
                            break; // 0 size is terminator
                        p += block_size;
                    }
                    this._frames.push({
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        has_local_palette: has_local_palette,
                        palette_offset: palette_offset,
                        palette_size: palette_size,
                        data_offset: data_offset,
                        data_length: p - data_offset,
                        transparent_index: transparent_index,
                        interlaced: !!interlace_flag,
                        delay: delay,
                        disposal: disposal
                    });
                    break;
                case 0x3b: // Trailer Marker (end of file).
                    no_eof = false;
                    break;
                default:
                    throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
                    break;
            }
        }
    }
    Object.defineProperty(GifReader.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifReader.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifReader.prototype, "numFrames", {
        get: function () {
            return this._frames.length;
        },
        enumerable: false,
        configurable: true
    });
    ;
    Object.defineProperty(GifReader.prototype, "loopCount", {
        get: function () {
            return this._loop_count;
        },
        enumerable: false,
        configurable: true
    });
    ;
    GifReader.prototype.getFrameInfo = function (frame_num) {
        if (frame_num < 0 || frame_num >= this._frames.length) {
            throw new Error("Frame index out of range.");
        }
        return this._frames[frame_num];
    };
    GifReader.prototype.decodeAndBlitFrameBGRA = function (frame_num, pixels) {
        var buf = this._buf;
        var frame = this.getFrameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.
        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
        var palette_offset = frame.palette_offset;
        // NOTE(deanm): It seems to be much faster to compare index to 256 than
        // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
        // the profile, not sure if it's related to using a Uint8Array.
        var trans = frame.transparent_index;
        if (trans === null)
            trans = 256;
        // We are possibly just blitting to a portion of the entire frame.
        // That is a subrect within the framerect, so the additional pixels
        // must be skipped over after we finished a scanline.
        var framewidth = frame.width;
        var framestride = this._width - framewidth;
        var xleft = framewidth; // Number of subrect pixels left in scanline.
        // Output indicies of the top left and bottom right corners of the subrect.
        var opbeg = ((frame.y * this._width) + frame.x) * 4;
        var opend = ((frame.y + frame.height) * this._width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        // Use scanstride to skip past the rows when interlacing.  This is skipping
        // 7 rows for the first two passes, then 3 then 1.
        if (frame.interlaced === true) {
            scanstride += this._width * 4 * 7; // Pass 1.
        }
        var interlaceskip = 8; // Tracking the row interval in the current pass.
        for (var i = 0, il = index_stream.length; i < il; ++i) {
            var index = index_stream[i];
            if (xleft === 0) { // Beginning of new scan line
                op += scanstride;
                xleft = framewidth;
                if (op >= opend) { // Catch the wrap to switch passes when interlacing.
                    scanstride = framestride * 4 + this._width * 4 * (interlaceskip - 1);
                    // interlaceskip / 2 * 4 is interlaceskip << 1.
                    op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
                    interlaceskip >>= 1;
                }
            }
            if (index === trans) {
                op += 4;
            }
            else {
                var r = buf[palette_offset + index * 3];
                var g = buf[palette_offset + index * 3 + 1];
                var b = buf[palette_offset + index * 3 + 2];
                pixels[op++] = b;
                pixels[op++] = g;
                pixels[op++] = r;
                pixels[op++] = 255;
            }
            --xleft;
        }
        return frame;
    };
    // I will go to copy and paste hell one day...
    GifReader.prototype.decodeAndBlitFrameRGBA = function (frame_num, pixels) {
        var buf = this._buf;
        var frame = this.getFrameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.
        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
        var palette_offset = frame.palette_offset;
        // NOTE(deanm): It seems to be much faster to compare index to 256 than
        // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
        // the profile, not sure if it's related to using a Uint8Array.
        var trans = frame.transparent_index;
        if (trans === null)
            trans = 256;
        // We are possibly just blitting to a portion of the entire frame.
        // That is a subrect within the framerect, so the additional pixels
        // must be skipped over after we finished a scanline.
        var framewidth = frame.width;
        var framestride = this._width - framewidth;
        var xleft = framewidth; // Number of subrect pixels left in scanline.
        // Output indicies of the top left and bottom right corners of the subrect.
        var opbeg = ((frame.y * this._width) + frame.x) * 4;
        var opend = ((frame.y + frame.height) * this._width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        // Use scanstride to skip past the rows when interlacing.  This is skipping
        // 7 rows for the first two passes, then 3 then 1.
        if (frame.interlaced === true) {
            scanstride += this._width * 4 * 7; // Pass 1.
        }
        var interlaceskip = 8; // Tracking the row interval in the current pass.
        for (var i = 0, il = index_stream.length; i < il; ++i) {
            var index = index_stream[i];
            if (xleft === 0) { // Beginning of new scan line
                op += scanstride;
                xleft = framewidth;
                if (op >= opend) { // Catch the wrap to switch passes when interlacing.
                    scanstride = framestride * 4 + this._width * 4 * (interlaceskip - 1);
                    // interlaceskip / 2 * 4 is interlaceskip << 1.
                    op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
                    interlaceskip >>= 1;
                }
            }
            if (index === trans) {
                op += 4;
            }
            else {
                var r = buf[palette_offset + index * 3];
                var g = buf[palette_offset + index * 3 + 1];
                var b = buf[palette_offset + index * 3 + 2];
                pixels[op++] = r;
                pixels[op++] = g;
                pixels[op++] = b;
                pixels[op++] = 255;
            }
            --xleft;
        }
        return frame;
    };
    ;
    return GifReader;
}());
exports.GifReader = GifReader;
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.
function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
    var min_code_size = code_stream[p++];
    var clear_code = 1 << min_code_size;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1; // Number of bits per code.
    // NOTE: This shares the same name as the encoder, but has a different
    // meaning here.  Here this masks each code coming from the code stream.
    var code_mask = (1 << cur_code_size) - 1;
    var cur_shift = 0;
    var cur = 0;
    var op = 0; // Output pointer.
    var subblock_size = code_stream[p++];
    // TODO(deanm): Would using a TypedArray be any faster?  At least it would
    // solve the fast mode / backing store uncertainty.
    // var code_table = Array(4096);
    var code_table = new Int32Array(4096); // Can be signed, we only use 20 bits.
    var prev_code = null; // Track code-1.
    while (true) {
        // Read up to two bytes, making sure we always 12-bits for max sized code.
        while (cur_shift < 16) {
            if (subblock_size === 0)
                break; // No more data to be read.
            cur |= code_stream[p++] << cur_shift;
            cur_shift += 8;
            if (subblock_size === 1) { // Never let it get to 0 to hold logic above.
                subblock_size = code_stream[p++]; // Next subblock.
            }
            else {
                --subblock_size;
            }
        }
        // TODO(deanm): We should never really get here, we should have received
        // and EOI.
        if (cur_shift < cur_code_size)
            break;
        var code = cur & code_mask;
        cur >>= cur_code_size;
        cur_shift -= cur_code_size;
        // TODO(deanm): Maybe should check that the first code was a clear code,
        // at least this is what you're supposed to do.  But actually our encoder
        // now doesn't emit a clear code first anyway.
        if (code === clear_code) {
            // We don't actually have to clear the table.  This could be a good idea
            // for greater error checking, but we don't really do any anyway.  We
            // will just track it with next_code and overwrite old entries.
            next_code = eoi_code + 1;
            cur_code_size = min_code_size + 1;
            code_mask = (1 << cur_code_size) - 1;
            // Don't update prev_code ?
            prev_code = null;
            continue;
        }
        else if (code === eoi_code) {
            break;
        }
        // We have a similar situation as the decoder, where we want to store
        // variable length entries (code table entries), but we want to do in a
        // faster manner than an array of arrays.  The code below stores sort of a
        // linked list within the code table, and then "chases" through it to
        // construct the dictionary entries.  When a new entry is created, just the
        // last byte is stored, and the rest (prefix) of the entry is only
        // referenced by its table entry.  Then the code chases through the
        // prefixes until it reaches a single byte code.  We have to chase twice,
        // first to compute the length, and then to actually copy the data to the
        // output (backwards, since we know the length).  The alternative would be
        // storing something in an intermediate stack, but that doesn't make any
        // more sense.  I implemented an approach where it also stored the length
        // in the code table, although it's a bit tricky because you run out of
        // bits (12 + 12 + 8), but I didn't measure much improvements (the table
        // entries are generally not the long).  Even when I created benchmarks for
        // very long table entries the complexity did not seem worth it.
        // The code table stores the prefix entry in 12 bits and then the suffix
        // byte in 8 bits, so each entry is 20 bits.
        var chase_code = code < next_code ? code : prev_code;
        // Chase what we will output, either {CODE} or {CODE-1}.
        var chase_length = 0;
        var chase = chase_code;
        while (chase > clear_code) {
            chase = code_table[chase] >> 8;
            ++chase_length;
        }
        var k = chase;
        var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
        if (op_end > output_length) {
            console.log("Warning, gif stream longer than expected.");
            return;
        }
        // Already have the first byte from the chase, might as well write it fast.
        output[op++] = k;
        op += chase_length;
        var b = op; // Track pointer, writing backwards.
        if (chase_code !== code) // The case of emitting {CODE-1} + k.
            output[op++] = k;
        chase = chase_code;
        while (chase_length--) {
            chase = code_table[chase];
            output[--b] = chase & 0xff; // Write backwards.
            chase >>= 8; // Pull down to the prefix code.
        }
        if (prev_code !== null && next_code < 4096) {
            code_table[next_code++] = prev_code << 8 | k;
            // TODO(deanm): Figure out this clearing vs code growth logic better.  I
            // have an feeling that it should just happen somewhere else, for now it
            // is awkward between when we grow past the max and then hit a clear code.
            // For now just check if we hit the max 12-bits (then a clear code should
            // follow, also of course encoded in 12-bits).
            if (next_code >= code_mask + 1 && cur_code_size < 12) {
                ++cur_code_size;
                code_mask = code_mask << 1 | 1;
            }
        }
        prev_code = code;
    }
    if (op !== output_length) {
        console.log("Warning, gif stream shorter than expected.");
    }
    return output;
}
/* eslint-disable */ 


/***/ }),

/***/ "./src/utils/GifSequence.ts":
/*!**********************************!*\
  !*** ./src/utils/GifSequence.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GifSequence = void 0;
var GifSprite_1 = __webpack_require__(/*! ../display/private/GifSprite */ "./src/display/private/GifSprite.ts");
var GifSequence = /** @class */ (function () {
    function GifSequence(sprite, name, frames, loopCount) {
        this.sprite = sprite;
        this.name = name;
        this.frames = frames;
        this.loopCount = loopCount;
        this._playing = false;
        this._nextFrameTime = 0;
        this._loopedCount = 0;
        this._speedScale = 1;
        this._timeDistance = 33;
    }
    GifSequence.prototype.setEndlessLoop = function () {
        this.loopCount = 0;
    };
    Object.defineProperty(GifSequence.prototype, "speedScale", {
        get: function () {
            return this._speedScale;
        },
        set: function (value) {
            this._speedScale = value || 0.0000001;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifSequence.prototype, "duration", {
        get: function () {
            var value = 0;
            for (var _i = 0, _a = this.frames; _i < _a.length; _i++) {
                var frame = _a[_i];
                value += frame.delayTime;
            }
            return value / this._speedScale;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifSequence.prototype, "playing", {
        get: function () {
            return this._playing;
        },
        enumerable: false,
        configurable: true
    });
    GifSequence.prototype.stop = function (skipEmit) {
        this._playing = false;
        vf.gui.TickerShared.remove(this.update, this);
        skipEmit || this.sprite.emit(GifSprite_1.GifSprite.EVENT.STOP, this.sprite);
    };
    GifSequence.prototype.play = function () {
        this._playing = true;
        this._loopedCount = 0;
        var currentFrame = this.frames[this.currentFrameIndex];
        if (this.sprite.texture != currentFrame.texture) {
            this.sprite.setGifFrame(currentFrame);
        }
        if (this.frames.length > 1) {
            vf.gui.TickerShared.add(this.update, this);
            this._nextFrameTime = vf.gui.Utils.now() + currentFrame.delayTime; //currentFrame.delayTime / this._speedScale;
            this.sprite.emit(GifSprite_1.GifSprite.EVENT.PLAY, this.sprite);
            return true;
        }
        return false;
    };
    Object.defineProperty(GifSequence.prototype, "currentFrameIndex", {
        get: function () {
            var currentFrameIndex = this.frames.indexOf(this.sprite.currentGifFrame);
            if (currentFrameIndex == -1) {
                currentFrameIndex = 0;
            }
            return currentFrameIndex;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GifSequence.prototype, "loopedCount", {
        get: function () {
            return this._loopedCount;
        },
        enumerable: false,
        configurable: true
    });
    GifSequence.prototype.update = function () {
        if (vf.gui.Utils.now() >= this._nextFrameTime) {
            var nextFrameIndex = this.currentFrameIndex + 1;
            if (nextFrameIndex >= this.frames.length) {
                nextFrameIndex = 0;
                this._loopedCount++;
                this.sprite.emit(GifSprite_1.GifSprite.EVENT.END, this.sprite);
                if (this.loopCount && this._loopedCount >= this.loopCount) {
                    this.stop();
                    this.sprite.emit(GifSprite_1.GifSprite.EVENT.COMPLETE, this.sprite);
                    return;
                }
            }
            var nextFrame = this.frames[nextFrameIndex];
            this.sprite.setGifFrame(nextFrame);
            this._nextFrameTime += this.sprite.currentGifFrame.delayTime; //nextFrame.delayTime / this._speedScale;
        }
    };
    return GifSequence;
}());
exports.GifSequence = GifSequence;


/***/ }),

/***/ "./src/utils/GraphicsUtils.ts":
/*!************************************!*\
  !*** ./src/utils/GraphicsUtils.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.toSVGString = exports.parseSvgData = exports.q2b = exports.parser = exports.arcToBezier = exports.mapToEllipse = exports.approxUnitArc = exports.getArcCenter = exports.vectorAngle = exports.parseValues = void 0;
var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
var TAU = Math.PI * 2;
var LEN = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
//数字字符解析成数组格式
function parseValues(args) {
    var numbers = args.match(number);
    return numbers ? numbers.map(Number) : [];
}
exports.parseValues = parseValues;
function vectorAngle(ux, uy, vx, vy) {
    var sign = (ux * vy - uy * vx < 0) ? -1 : 1;
    var umag = Math.sqrt(ux * ux + uy * uy);
    var vmag = Math.sqrt(ux * ux + uy * uy);
    var dot = ux * vx + uy * vy;
    var div = dot / (umag * vmag);
    if (div > 1) {
        div = 1;
    }
    if (div < -1) {
        div = -1;
    }
    return sign * Math.acos(div);
}
exports.vectorAngle = vectorAngle;
function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
    var rxsq = Math.pow(rx, 2);
    var rysq = Math.pow(ry, 2);
    var pxpsq = Math.pow(pxp, 2);
    var pypsq = Math.pow(pyp, 2);
    var radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq);
    if (radicant < 0) {
        radicant = 0;
    }
    radicant /= (rxsq * pypsq) + (rysq * pxpsq);
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
    var centerxp = radicant * rx / ry * pyp;
    var centeryp = radicant * -ry / rx * pxp;
    var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
    var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
    var vx1 = (pxp - centerxp) / rx;
    var vy1 = (pyp - centeryp) / ry;
    var vx2 = (-pxp - centerxp) / rx;
    var vy2 = (-pyp - centeryp) / ry;
    var ang1 = vectorAngle(1, 0, vx1, vy1);
    var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
    if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
    }
    if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
    }
    return [centerx, centery, ang1, ang2];
}
exports.getArcCenter = getArcCenter;
function approxUnitArc(ang1, ang2) {
    var a = 4 / 3 * Math.tan(ang2 / 4);
    var x1 = Math.cos(ang1);
    var y1 = Math.sin(ang1);
    var x2 = Math.cos(ang1 + ang2);
    var y2 = Math.sin(ang1 + ang2);
    return [
        {
            x: x1 - y1 * a,
            y: y1 + x1 * a,
        },
        {
            x: x2 + y2 * a,
            y: y2 - x2 * a,
        },
        {
            x: x2,
            y: y2,
        },
    ];
}
exports.approxUnitArc = approxUnitArc;
function mapToEllipse(data, rx, ry, cosphi, sinphi, centerx, centery) {
    data.x *= rx;
    data.y *= ry;
    var xp = cosphi * data.x - sinphi * data.y;
    var yp = sinphi * data.x + cosphi * data.y;
    return {
        x: xp + centerx,
        y: yp + centery,
    };
}
exports.mapToEllipse = mapToEllipse;
function arcToBezier(px, py, cx, cy, rx, ry, xAxisRotation, largeArcFlag, sweepFlag) {
    if (xAxisRotation === void 0) { xAxisRotation = 0; }
    if (largeArcFlag === void 0) { largeArcFlag = 0; }
    if (sweepFlag === void 0) { sweepFlag = 0; }
    var curves = [];
    if (rx === 0 || ry === 0) {
        return [];
    }
    var sinphi = Math.sin(xAxisRotation * TAU / 360);
    var cosphi = Math.cos(xAxisRotation * TAU / 360);
    var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
    var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
        return [];
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) +
        Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
        rx *= Math.sqrt(lambda);
        ry *= Math.sqrt(lambda);
    }
    var d = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp);
    var centerx = d[0];
    var centery = d[1];
    var ang1 = d[2];
    var ang2 = d[3];
    var segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1);
    ang2 /= segments;
    for (var i = 0; i < segments; i++) {
        curves.push(approxUnitArc(ang1, ang2));
        ang1 += ang2;
    }
    return curves.map(function (curve) {
        var _a = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _a.x, y1 = _a.y;
        var _b = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _b.x, y2 = _b.y;
        var _c = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _c.x, y = _c.y;
        return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };
    });
}
exports.arcToBezier = arcToBezier;
/*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
/**
 * svg格式拆数组格式
 * cmds
(4) [Array(3), Array(8), Array(8), Array(1)]
0: (3) ["M", 280, 250]
1: (8) ["A", 200, 200, 0, 1, 1, 680, 250]
2: (8) ["A", 200, 200, 0, 1, 1, 280, 250]
3: ["Z"]
length: 4
 */
function parser(path) {
    var data = [];
    path.replace(segment, function (a, command, args) {
        var type = command.toLowerCase();
        args = parseValues(args);
        // overloaded moveTo
        if (type == 'm' && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = 'l';
            command = command == 'm' ? 'l' : 'L';
        }
        /*eslint no-constant-condition: ["error", { "checkLoops": false }]*/
        while (true) {
            if (args.length == LEN[type]) {
                args.unshift(command);
                return data.push(args);
            }
            if (args.length < LEN[type])
                throw new Error('malformed path data');
            data.push([command].concat(args.splice(0, LEN[type])));
        }
    });
    return data;
}
exports.parser = parser;
function q2b(x1, y1, x2, y2, x3, y3) {
    return [x1, y1, (x1 + 2 * x2) / 3, (y1 + 2 * y2) / 3, (x3 + 2 * x2) / 3, (y3 + 2 * y2) / 3, x3, y3];
}
exports.q2b = q2b;
/**
 * 解析svg的path
 *
 *
    M = moveto
    L = lineto
    H = horizontal lineto
    V = vertical lineto
    C = curveto
    S = smooth curveto
    Q = quadratic Belzier curve
    T = smooth quadratic Belzier curveto
    A = elliptical Arc
    Z = closepath
    以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位(从上一个点开始)。
 */
function parseSvgData(path) {
    var cmds = parser(path), shapes = [], len = cmds.length;
    var preX = 0, preY = 0, j = 0, current = [], closeX, closeY, preCX = 0, preCY = 0, sLen, curves, lastCurve;
    for (; j < len; j++) {
        var item = cmds[j];
        var action = item[0];
        var preItem = cmds[j - 1];
        switch (action) {
            case 'm':
                sLen = shapes.length;
                shapes[sLen] = [];
                current = shapes[sLen];
                preX = preX + item[1];
                preY = preY + item[2];
                break;
            case 'M':
                sLen = shapes.length;
                shapes[sLen] = [];
                current = shapes[sLen];
                preX = item[1];
                preY = item[2];
                break;
            case 'l':
                if (item[1] !== 0 || item[2] !== 0) {
                    current.push([preX, preY, preX, preY, preX, preY, preX + item[1], preY + item[2]]);
                    preX += item[1];
                    preY += item[2];
                }
                break;
            case 'L':
                if (preX !== item[1] || preY !== item[2]) {
                    current.push([preX, preY, item[1], item[2], item[1], item[2], item[1], item[2]]);
                    preX = item[1];
                    preY = item[2];
                }
                break;
            case 'h':
                current.push([preX, preY, preX, preY, preX, preY, preX + item[1], preY]);
                preX += item[1];
                break;
            case 'H':
                current.push([preX, preY, item[1], preY, item[1], preY, item[1], preY]);
                preX = item[1];
                break;
            case 'v':
                current.push([preX, preY, preX, preY, preX, preY, preX, preY + item[1]]);
                preY += item[1];
                break;
            case 'V':
                current.push([preX, preY, preX, item[1], preX, item[1], preX, item[1]]);
                preY = item[1];
                break;
            case 'C':
                current.push([preX, preY, item[1], item[2], item[3], item[4], item[5], item[6]]);
                preX = item[5];
                preY = item[6];
                break;
            case 'S':
                if (preItem[0] === 'C' || preItem[0] === 'c') {
                    current.push([preX, preY, preX + preItem[5] - preItem[3], preY + preItem[6] - preItem[4], item[1], item[2], item[3], item[4]]);
                }
                else if (preItem[0] === 'S' || preItem[0] === 's') {
                    current.push([preX, preY, preX + preItem[3] - preItem[1], preY + preItem[4] - preItem[2], item[1], item[2], item[3], item[4]]);
                }
                preX = item[3];
                preY = item[4];
                break;
            case 'c':
                current.push([preX, preY, preX + item[1], preY + item[2], preX + item[3], preY + item[4], preX + item[5], preY + item[6]]);
                preX = preX + item[5];
                preY = preY + item[6];
                break;
            case 's':
                if (preItem[0] === 'C' || preItem[0] === 'c') {
                    current.push([preX, preY, preX + preItem[5] - preItem[3], preY + preItem[6] - preItem[4], preX + item[1], preY + item[2], preX + item[3], preY + item[4]]);
                }
                else if (preItem[0] === 'S' || preItem[0] === 's') {
                    current.push([preX, preY, preX + preItem[3] - preItem[1], preY + preItem[4] - preItem[2], preX + item[1], preY + item[2], preX + item[3], preY + item[4]]);
                }
                preX = preX + item[3];
                preY = preY + item[4];
                break;
            case 'a':
                curves = arcToBezier(preX, preY, preX + item[6], preY + item[7], item[1], item[2], item[3], item[4], item[5]);
                lastCurve = curves[curves.length - 1];
                curves.forEach(function (curve, index) {
                    if (index === 0) {
                        current.push([preX, preY, curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y]);
                    }
                    else {
                        current.push([curves[index - 1].x, curves[index - 1].y, curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y]);
                    }
                });
                preX = lastCurve && lastCurve.x;
                preY = lastCurve && lastCurve.y;
                break;
            case 'A':
                curves = arcToBezier(preX, preY, item[6], item[7], item[1], item[2], item[3], item[4], item[5]);
                lastCurve = curves[curves.length - 1];
                curves.forEach(function (curve, index) {
                    if (index === 0) {
                        current.push([preX, preY, curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y]);
                    }
                    else {
                        current.push([curves[index - 1].x, curves[index - 1].y, curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y]);
                    }
                });
                preX = lastCurve && lastCurve.x;
                preY = lastCurve && lastCurve.y;
                break;
            case 'Q':
                current.push(q2b(preX, preY, item[1], item[2], item[3], item[4]));
                preX = item[3];
                preY = item[4];
                break;
            case 'q':
                current.push(q2b(preX, preY, preX + item[1], preY + item[2], item[3] + preX, item[4] + preY));
                preX += item[3];
                preY += item[4];
                break;
            case 'T':
                if (preItem[0] === 'Q' || preItem[0] === 'q') {
                    preCX = preX + preItem[3] - preItem[1];
                    preCY = preY + preItem[4] - preItem[2];
                    current.push(q2b(preX, preY, preCX, preCY, item[1], item[2]));
                }
                else if (preItem[0] === 'T' || preItem[0] === 't') {
                    current.push(q2b(preX, preY, preX + preX - preCX, preY + preY - preCY, item[1], item[2]));
                    preCX = preX + preX - preCX;
                    preCY = preY + preY - preCY;
                }
                preX = item[1];
                preY = item[2];
                break;
            case 't':
                if (preItem[0] === 'Q' || preItem[0] === 'q') {
                    preCX = preX + preItem[3] - preItem[1];
                    preCY = preY + preItem[4] - preItem[2];
                    current.push(q2b(preX, preY, preCX, preCY, preX + item[1], preY + item[2]));
                }
                else if (preItem[0] === 'T' || preItem[0] === 't') {
                    current.push(q2b(preX, preY, preX + preX - preCX, preY + preY - preCY, preX + item[1], preY + item[2]));
                    preCX = preX + preX - preCX;
                    preCY = preY + preY - preCY;
                }
                preX += item[1];
                preY += item[2];
                break;
            case 'Z':
            case 'z':
                closeX = current[0][0];
                closeY = current[0][1];
                if (preX !== closeX || preY !== closeY) {
                    current.push([preX, preY, closeX, closeY, closeX, closeY, closeX, closeY]);
                }
                break;
        }
    }
    return shapes;
}
exports.parseSvgData = parseSvgData;
function toSVGString(shapes) {
    /*克隆一下实时数据*/
    //var shapes = JSON.parse(JSON.stringify(shapes||[]));
    /*对数据中的每个点数组做处理
    * */
    return shapes.map(function (shape) {
        shape.forEach(function (point, idx) {
            if (!idx) {
                /*
                 * 若是第一个点数组，那么对该点数组的处理是前面加M,然后前两个点后面加C
                 * */
                point.splice(2, 0, "C");
                point.unshift("M");
            }
            else {
                /*
                 * 除了第一个点数据外,所有的点数组的前两个点删除掉
                 * */
                point.splice(0, 2, "C");
            }
        });
        return shape.map(function (point) {
            return point.join(" ");
        }).join("");
    }).join("");
}
exports.toSVGString = toSVGString;


/***/ }),

/***/ "./src/utils/ObjectPool.ts":
/*!*********************************!*\
  !*** ./src/utils/ObjectPool.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.objectPoolShared = void 0;
/** 对象池*/
var ObjectPool = /** @class */ (function () {
    function ObjectPool() {
        /**
         * 作为对象池的词典dict
         */
        this.objPoolDict = new Map();
        //
    }
    /**
     * 向对象池中放入对象，以便重复利用
     */
    ObjectPool.prototype.push = function (keyClass, oldObj) {
        if (oldObj === undefined) {
            return;
        }
        var objs = this.objPoolDict.get(keyClass);
        if (objs === undefined) {
            objs = [];
            this.objPoolDict.set(keyClass, objs);
        }
        if (objs.indexOf(oldObj) === -1) {
            oldObj.release();
            objs.push(oldObj);
        }
    };
    /**
     * 从对象池中取出需要的对象
     * @return 取出的相应对象
     *
     */
    ObjectPool.prototype.pop = function (keyClass) {
        var objs = this.objPoolDict.get(keyClass);
        if (objs !== undefined && objs.length > 0) {
            return objs.pop();
        }
        return new keyClass();
    };
    return ObjectPool;
}());
/**
 * 对象池实例
 */
exports.objectPoolShared = new ObjectPool();


/***/ }),

/***/ "./src/utils/Utils.ts":
/*!****************************!*\
  !*** ./src/utils/Utils.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDisplayObject = exports.ParseDataItem = exports.toSVGStr = exports.path2shapes = exports.toDomRectangle = exports.toLoacalTransform = exports.toWorldTransform = exports.toGlobal = exports.toLocal = exports.sayHello = exports.getGuiClass = exports.pointSignAngle = exports.pointPlus = exports.pointSub = exports.pointDistance = exports.formatRelative = exports.isDeltaIdentity = exports.getStringFunctionParam = exports.getQueryVariable = exports.uid = exports.Round = exports.Lerp = exports.hexToRgb = exports.numberToRgb = exports.rgbStrToNumber = exports.rgbToNumber = exports.rgbToHex = exports.componentToHex = exports.hexToRgba = exports.hexListToIntList = exports.hexToInt = exports.deepCopy = exports.now = exports.setRectangle = exports.getDisplayPathById = exports.getStage = exports.getDisplayObject = exports.getSound = exports.getSheet = exports.getTexture = exports.getSource = exports.setDisplayObjectPath = exports.$getUIDisplayObjectPath = exports.setSourcePath = exports.$getSourcePath = exports.log = exports.debug = void 0;
var DisplayObject_1 = __webpack_require__(/*! ../core/DisplayObject */ "./src/core/DisplayObject.ts");
var Stage_1 = __webpack_require__(/*! ../core/Stage */ "./src/core/Stage.ts");
var DisplayObjectAbstract_1 = __webpack_require__(/*! ../core/DisplayObjectAbstract */ "./src/core/DisplayObjectAbstract.ts");
var GraphicsUtils_1 = __webpack_require__(/*! ./GraphicsUtils */ "./src/utils/GraphicsUtils.ts");
var GifFrames_1 = __webpack_require__(/*! ./GifFrames */ "./src/utils/GifFrames.ts");
__exportStar(__webpack_require__(/*! ./ObjectPool */ "./src/utils/ObjectPool.ts"), exports);
__exportStar(__webpack_require__(/*! ./calculateUpdatePlayerSize */ "./src/utils/calculateUpdatePlayerSize.ts"), exports);
__exportStar(__webpack_require__(/*! ./setInteractiveElement */ "./src/utils/setInteractiveElement.ts"), exports);
__exportStar(__webpack_require__(/*! ./cacheDestroy */ "./src/utils/cacheDestroy.ts"), exports);
/**
 * 工具类
 */
/** 日志输出 */
function log(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    console.log.apply(console, __spreadArrays([message], optionalParams));
}
exports.log = log;
function setSourcePath(params) {
    exports.$getSourcePath = params;
}
exports.setSourcePath = setSourcePath;
function setDisplayObjectPath(params) {
    exports.$getUIDisplayObjectPath = params;
}
exports.setDisplayObjectPath = setDisplayObjectPath;
function getSource(src) {
    if (exports.$getSourcePath) {
        src = exports.$getSourcePath(src);
    }
    return src;
}
exports.getSource = getSource;
function getTexture(src) {
    if (src instanceof vf.Texture) {
        return src;
    }
    if (exports.$getSourcePath) {
        var tempSrc = exports.$getSourcePath(src);
        if (tempSrc) {
            src = tempSrc;
            if (src instanceof vf.Texture || (src["extension"] && src["extension"] === 'gif')) {
                return src;
            }
        }
        else if (typeof src === 'string' && src.indexOf('//') !== -1) {
            return vf.Texture.from(src);
        }
        else {
            return undefined;
        }
    }
    if (src === undefined || src === null || src === '') {
        src = undefined;
        return src;
    }
    if (typeof src === 'string') {
        return vf.Texture.from(src);
    }
    if (typeof src === 'object' && src["extension"] && src["extension"] === 'gif') {
        if (src.data) {
            var frames_1 = new GifFrames_1.GifFrames(src);
            src['frames'] = frames_1;
            src.texture = frames_1.getFrame(0).texture;
        }
        return src;
    }
    return undefined;
}
exports.getTexture = getTexture;
function getSheet(src) {
    if (exports.$getSourcePath) {
        src = exports.$getSourcePath(src);
    }
    return src;
}
exports.getSheet = getSheet;
function getSound(src) {
    if (exports.$getSourcePath) {
        src = exports.$getSourcePath(src);
    }
    return src;
}
exports.getSound = getSound;
function getDisplayObject(src, target) {
    if (src instanceof DisplayObject_1.DisplayObject) {
        return src;
    }
    else if (src instanceof DisplayObjectAbstract_1.DisplayObjectAbstract) {
        return src;
    }
    if (exports.$getUIDisplayObjectPath) {
        src = exports.$getUIDisplayObjectPath(src, target);
    }
    return src;
}
exports.getDisplayObject = getDisplayObject;
/**
 * 递归获取舞台，组件必须已经添加到舞台
 * @param DisplayObject
 */
function getStage(target) {
    if (target.$stage) {
        return target.$stage;
    }
    if (target.parent instanceof Stage_1.Stage) {
        return target.parent;
    }
    if (target.parent) {
        return getStage(target.parent);
    }
    return undefined;
}
exports.getStage = getStage;
/**
 * 获取显示对象的路径(解析json需要的id，并不是uuid)
 * @param target
 * @param ids
 */
function getDisplayPathById(target, ids) {
    if (ids === void 0) { ids = []; }
    if (target.id === '') {
        return ids;
    }
    ids.push(target.id);
    if (target.parent) {
        if (target.parent instanceof Stage_1.Stage) {
            return ids;
        }
        return getDisplayPathById(target.parent, ids);
    }
    return ids;
}
exports.getDisplayPathById = getDisplayPathById;
/**
 * 快速设置矩形
 * @param sourcr
 * @param x
 * @param y
 * @param w
 * @param h
 */
function setRectangle(source, x, y, w, h) {
    source.x = x;
    source.y = y;
    source.width = w;
    source.height = h;
}
exports.setRectangle = setRectangle;
/** 获取当前运行时时间 */
function now() {
    if (performance !== undefined && performance.now !== undefined) {
        // This must be bound, because directly assigning this function
        // leads to an invocation exception in Chrome.
        return performance.now.bind(performance)();
        // Use Date.now if it is available.
    }
    else {
        var offset = performance && performance.timing && performance.timing.navigationStart ? performance.timing.navigationStart : Date.now();
        return Date.now() - offset;
    }
}
exports.now = now;
/**
 * 深度拷贝对象
 * @param source 对象元
 */
function deepCopy(source, target) {
    if (source === null || source === undefined || typeof source !== 'object') {
        return source;
    }
    else if (Array.isArray(source)) {
        return [].concat(source);
    }
    else if (typeof source === 'object') {
        var tempTarget = target || {};
        for (var prop in source) {
            tempTarget[prop] = deepCopy(source[prop], tempTarget[prop]);
        }
        return tempTarget;
    }
    return source;
}
exports.deepCopy = deepCopy;
/**
 * helper function to convert string hex to int or default
 *
 * 16进制转int，颜色转换
 * @param str 要转换的值，如#FFFFFF,0xFFFFFF
 * @param def 转换失败的返回值
 */
function hexToInt(str, def) {
    if (str === undefined) {
        return def;
    }
    if (typeof str === 'number')
        return str;
    var sign = "#";
    if (str.charAt(0) === sign) {
        var len = str.length;
        var colorLength = 7;
        if (len > colorLength) {
            console.log("#color longChars need <= " + colorLength);
            str = sign + str.slice(len - colorLength + 1);
        }
        str = str.replace('#', '0x');
    }
    var result = parseInt(str);
    if (isNaN(result))
        return def;
    return result;
}
exports.hexToInt = hexToInt;
/**
 * helper function to convert string hex to int or default
 *
 * 16进制转int，颜色转换
 * @param str 要转换的值，如#FFFFFF,0xFFFFFF
 * @param def 转换失败的返回值
 */
function hexListToIntList(str, def) {
    if (str === undefined) {
        return def;
    }
    var colorlist = [];
    if (Array.isArray(str)) {
        var strList = str;
        var len = strList.length;
        for (var i = 0; i < len; i++) {
            var color = hexToInt(strList[i], undefined);
            colorlist.push(color);
        }
    }
    else {
        colorlist = hexToInt(str, def);
    }
    return colorlist;
}
exports.hexListToIntList = hexListToIntList;
//helper function to convert hex to rgba
/**
 *
 * @param hex 16进制字符窜 如 #FFFFFF ，不能省略三位写法
 * @param alpha 透明度
 * @returns "rgba(255,255,255,1)" || false
 */
function hexToRgba(hex, alpha) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? "rgba(" + parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) + "," + alpha + ")" : false;
}
exports.hexToRgba = hexToRgba;
/**
 * 转换为16位字符串，不够2位的补0，如 “01”
 * @param c 要转换的数字
 */
function componentToHex(c) {
    var hex = c.toString(16);
    if (hex.length == 4) {
        return "00" + hex;
    }
    return hex.length == 1 ? "0" + hex : hex;
}
exports.componentToHex = componentToHex;
/**
 * RGB转16进制
 * @param r 红 0-255
 * @param g 绿 0-255
 * @param b 蓝 0-255
 */
function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}
exports.rgbToHex = rgbToHex;
/**
 * RGB转number
 * @param r 红 0-255
 * @param g 绿 0-255
 * @param b 蓝 0-255
 */
function rgbToNumber(r, g, b) {
    return r * 65536 + g * 256 + b;
}
exports.rgbToNumber = rgbToNumber;
/**
 * rgb字符串形式转换
 * @param color rgb(255,255,255)
 */
function rgbStrToNumber(color) {
    var colors = color.substring(4, color.length - 1).split(",");
    return rgbToNumber(parseInt(colors[0]), parseInt(colors[1]), parseInt(colors[2]));
}
exports.rgbStrToNumber = rgbStrToNumber;
/**
 * 10进制转RGB
 * @param c 数
 */
function numberToRgb(c) {
    return {
        r: Math.floor(c / (256 * 256)),
        g: Math.floor(c / 256) % 256,
        b: c % 256,
    };
}
exports.numberToRgb = numberToRgb;
/**
 * hex 转 RGB，
 *
 * 如hex字符串: "#ffffff"->255,255,255
 *
 * 如16进制数字: 0xffffff->255,255,255
 * @param hex
 */
function hexToRgb(hex) {
    if (hex === undefined)
        hex = 0xffffff;
    if (typeof (hex) == "number") {
        return numberToRgb(hex);
    }
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : { r: 255, g: 255, b: 255 };
}
exports.hexToRgb = hexToRgb;
/**
 * 根据amt计算当前的位置start-stop，两数差值
 * @param start 开始数值
 * @param stop  结束的数值
 * @param amt 0-1 用时 >1为1，小于0为0
 */
function Lerp(start, stop, amt) {
    if (amt > 1)
        amt = 1;
    else if (amt < 0)
        amt = 0;
    return start + (stop - start) * amt;
}
exports.Lerp = Lerp;
/**
 * 四舍五入保留指定位数的小数
 * @param num 取舍的数
 * @param decimals 保留小数位
 */
function Round(num, decimals) {
    var pow = Math.pow(10, decimals);
    return Math.round(num * pow) / pow;
}
exports.Round = Round;
/** 获取全局唯一数 */
function uid() {
    return vf.utils.uid();
}
exports.uid = uid;
/** 获取URL参数 */
function getQueryVariable(variable) {
    var params = new URLSearchParams(location.search);
    if (params.has(variable)) {
        return params.get(variable);
    }
    return undefined;
}
exports.getQueryVariable = getQueryVariable;
/**
 * 解析一个字符串函数的参数，如xxx(1) = 1
 * @param
 */
function getStringFunctionParam(str) {
    var target = {};
    target.key = str.substr(0, str.indexOf("("));
    var value = str.substr(str.indexOf("(") + 1);
    target.value = parseFloat(value.substr(0, value.lastIndexOf(")")));
    return target;
}
exports.getStringFunctionParam = getStringFunctionParam;
function isDeltaIdentity(m) {
    return (m.a === 1 && m.b === 0 && m.c === 0 && m.d === 1);
}
exports.isDeltaIdentity = isDeltaIdentity;
/**
 * 格式化一个百分比为小数
 * @param value
 * @param total
 */
function formatRelative(value, total) {
    if (value == undefined) {
        return NaN;
    }
    if (typeof value === "number") {
        return value;
    }
    var str = value;
    var index = str.indexOf("%");
    if (index == -1) {
        return +str;
    }
    var percent = +str.substring(0, index);
    return percent * 0.01 * total;
}
exports.formatRelative = formatRelative;
/** 计算两点距离 */
function pointDistance(pointA, pointB) {
    return Math.sqrt((pointA.x - pointB.x) * (pointA.x - pointB.x) + (pointA.y - pointB.y) * (pointA.y - pointB.y));
}
exports.pointDistance = pointDistance;
/** 坐标相减 */
function pointSub(source, subPoint) {
    var x = source.x - subPoint.x;
    var y = source.y - subPoint.y;
    return { x: x, y: y };
}
exports.pointSub = pointSub;
/** 坐标相加 */
function pointPlus(source, PlusPoint) {
    var x = source.x + PlusPoint.x;
    var y = source.y + PlusPoint.y;
    return { x: x, y: y };
}
exports.pointPlus = pointPlus;
/** 向量转弧度 */
function pointSignAngle(pointA, pointB) {
    var num1 = (pointA.x * pointB.y) - (pointB.x * pointA.y);
    var num2 = (pointA.x * pointB.x) + (pointA.y * pointB.y);
    return Math.atan2(num1, num2) * (360 / (Math.PI * 2));
}
exports.pointSignAngle = pointSignAngle;
/**
 *  根据类型获得具体的类定义
 * @param type
 */
function getGuiClass(type) {
    return vf.gui[type];
}
exports.getGuiClass = getGuiClass;
function sayHello() {
    vf.utils.versionPrint('gui ' + vf.gui.VERSION, 'https://yunkc.gitee.io/docs/');
}
exports.sayHello = sayHello;
/**
 * 全局坐标转本地坐标
 */
function toLocal(position, localDisplayObject) {
    if (localDisplayObject instanceof DisplayObjectAbstract_1.DisplayObjectAbstract) {
        return localDisplayObject.container.toLocal(position, undefined);
    }
    else {
        return localDisplayObject.toLocal(position, undefined);
    }
}
exports.toLocal = toLocal;
/**
 * 本地坐标转全局坐标
 */
function toGlobal(position, localDisplayObject) {
    if (localDisplayObject instanceof DisplayObjectAbstract_1.DisplayObjectAbstract) {
        return localDisplayObject.container.toGlobal(position, undefined);
    }
    else {
        return localDisplayObject.toGlobal(position, undefined);
    }
}
exports.toGlobal = toGlobal;
/**
 * 本地坐标转全局
 */
function toWorldTransform(localDisplayObject) {
    if (localDisplayObject instanceof DisplayObjectAbstract_1.DisplayObjectAbstract) {
        return localDisplayObject.container.worldTransform;
    }
    else {
        return localDisplayObject.worldTransform;
    }
}
exports.toWorldTransform = toWorldTransform;
function toLoacalTransform(localDisplayObject) {
    if (localDisplayObject instanceof DisplayObjectAbstract_1.DisplayObjectAbstract) {
        return localDisplayObject.container.localTransform;
    }
    else {
        return localDisplayObject.localTransform;
    }
}
exports.toLoacalTransform = toLoacalTransform;
/**
 * 本地显示对象转换到DIV坐标，核心是减去canvas的偏移量
 * @param localDisplayObject
 * @returns
 */
function toDomRectangle(localDisplayObject, point) {
    var rect = new vf.Rectangle();
    if (point) {
        var p = localDisplayObject.container.toGlobal(point);
        rect.x = p.x;
        rect.y = p.y;
        var worldTransform = localDisplayObject.container.worldTransform;
        rect.width = worldTransform.a;
        rect.height = worldTransform.d;
    }
    else {
        rect = localDisplayObject.container.getBounds();
    }
    var viweCanvas;
    if (localDisplayObject.stage) {
        viweCanvas = localDisplayObject.stage.app.view;
    }
    else {
        viweCanvas = localDisplayObject.app.view;
    }
    rect.x += viweCanvas.offsetLeft;
    rect.y += viweCanvas.offsetTop;
    return rect;
}
exports.toDomRectangle = toDomRectangle;
/**
 * svgData to array
 */
function path2shapes(path) {
    return GraphicsUtils_1.parseSvgData(path);
}
exports.path2shapes = path2shapes;
/**
 * array to svgData
 */
function toSVGStr(shapes) {
    return GraphicsUtils_1.toSVGString(shapes);
}
exports.toSVGStr = toSVGStr;
var ParseDataItem = /** @class */ (function () {
    function ParseDataItem() {
        this.type = "M";
        this.x = 0;
        this.y = 0;
        this.ct1X = 0;
        this.ct1Y = 0;
        this.ct2X = 0;
        this.ct2Y = 0;
    }
    return ParseDataItem;
}());
exports.ParseDataItem = ParseDataItem;
/**
 * 创建显示对象
 * @param moduleName
 * @param option
 * @param parent
 * example:
 *   let img = vf.gui.Utils.createDisplayObject("Image", {x: 0, y: 0, src: 'xxxx.png'}, this) as vf.gui.Image;
 */
function createDisplayObject(moduleName, option, parent) {
    var ModuleClass = vf.utils.getGuiModule(moduleName);
    if (ModuleClass) {
        try {
            var obj = new ModuleClass();
            for (var key in option) {
                obj[key] = option[key];
            }
            parent && parent.addChild(obj);
            return obj;
        }
        catch (e) {
            console.error("\u521B\u5EFA" + moduleName + "\u7EC4\u4EF6\u5931\u8D25\uFF1A", e);
        }
    }
    else {
        console.error("\u6CA1\u6709\u627E\u5230" + moduleName + "\u5BF9\u5E94\u7684gui\u6A21\u5757");
    }
}
exports.createDisplayObject = createDisplayObject;


/***/ }),

/***/ "./src/utils/cacheDestroy.ts":
/*!***********************************!*\
  !*** ./src/utils/cacheDestroy.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheDestroy = void 0;
function destroy(obj, bool) {
    if (obj instanceof vf.Texture) {
        obj.destroy(bool);
    }
    else if (obj instanceof vf.Spritesheet) {
        obj.destroy(bool);
    }
    else if (typeof obj === 'object' && obj.texture) {
        obj.texture.destroy(bool);
    }
    else if (typeof obj === 'object' && obj.spritesheet) {
        obj.spritesheet.destroy(bool);
    }
    if (typeof obj === 'string') {
        if (vf.Loader.shared.resources[obj]) {
            destroy(vf.Loader.shared.resources[obj], bool);
            if (bool)
                delete vf.Loader.shared.resources[obj];
        }
    }
    if (vf.utils.TextureCache[obj]) {
        vf.utils.TextureCache[obj].destroy(bool);
    }
}
function cacheDestroy(res, bool) {
    destroy(res, bool);
}
exports.cacheDestroy = cacheDestroy;


/***/ }),

/***/ "./src/utils/calculateUpdatePlayerSize.ts":
/*!************************************************!*\
  !*** ./src/utils/calculateUpdatePlayerSize.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable max-len */
/* eslint-disable no-undef */
/* eslint-disable @typescript-eslint/explicit-function-return-type */
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateUpdatePlayerSize = exports.getBoundingClientRect = void 0;
/**
 * @private
 * 计算舞台显示尺寸
 * @param scaleMode 当前的缩放模式
 * @param screenWidth 播放器视口宽度
 * @param screenHeight 播放器视口高度
 * @param contentWidth 初始化内容宽度
 * @param contentHeight 初始化内容高度
 */
function calculateStageSize(scaleMode, screenWidth, screenHeight, contentWidth, contentHeight) {
    var displayWidth = screenWidth;
    var displayHeight = screenHeight;
    var stageWidth = contentWidth;
    var stageHeight = contentHeight;
    var scaleX = (screenWidth / stageWidth) || 0;
    var scaleY = (screenHeight / stageHeight) || 0;
    switch (scaleMode) {
        case 'showAll':
            if (scaleX > scaleY) {
                displayWidth = Math.round(stageWidth * scaleY);
            }
            else {
                displayHeight = Math.round(stageHeight * scaleX);
            }
            break;
        case 'cover':
            if (scaleX > scaleY) {
                displayHeight = Math.round(stageHeight * scaleX);
            }
            else {
                displayWidth = Math.round(stageWidth * scaleY);
            }
            break;
        case 'contain':
            if (scaleX > scaleY) {
                stageWidth = Math.round(screenWidth / scaleY);
            }
            else {
                stageHeight = Math.round(screenHeight / scaleX);
            }
            break;
        case 'fixedHeight':
            displayWidth = Math.round(stageWidth * scaleY);
            break;
        case 'fixedWidth':
            displayHeight = Math.round(stageHeight * scaleX);
            break;
        default:
            displayWidth = contentWidth;
            displayHeight = contentHeight;
            stageWidth = contentWidth;
            stageHeight = contentHeight;
            break;
    }
    // 宽高不是2的整数倍会导致图片绘制出现问题
    if (stageWidth % 2 !== 0) {
        stageWidth += 1;
    }
    if (stageHeight % 2 !== 0) {
        stageHeight += 1;
    }
    if (displayWidth % 2 !== 0) {
        displayWidth += 1;
    }
    if (displayHeight % 2 !== 0) {
        displayHeight += 1;
    }
    return {
        stageWidth: stageWidth,
        stageHeight: stageHeight,
        displayWidth: displayWidth,
        displayHeight: displayHeight,
    };
}
function getBoundingClientRect(dom) {
    if (dom === null) {
        throw new Error("Error No find canvas parent dom");
    }
    var rect = {};
    rect.width = dom.offsetWidth;
    rect.height = dom.offsetHeight;
    return rect;
}
exports.getBoundingClientRect = getBoundingClientRect;
/**
 * @private
 *
 * 更新播放器视口尺寸
 *
 * noScale 不对内容进行任何缩放，保持原始的1:1比例。如果播放器窗口比内容小，则可能进行一些裁切。
 *
 * showAll 非溢出居中，显示全部内容。水平或垂直“两侧”可能会不够宽而留有黑边。
 *
 * contain 非溢出，显示全部内容，水平或垂直“一侧”方向有黑边。
 *
 * cover 溢出居中，某些部分也许无法显示在播放器视口。
 */
function calculateUpdatePlayerSize(scrennDiv, app, stage, stageW, stageH, scaleMode) {
    var canvas = app.view;
    var canvasScaleFactor = app.renderer.resolution;
    var isWebGl = vf.utils.isWebGLSupported();
    var top = 0;
    var clientRect = getBoundingClientRect(scrennDiv);
    var screenWidth = clientRect.width;
    var screenHeight = clientRect.height;
    stageW = vf.gui.Utils.formatRelative(stageW, screenWidth);
    stageH = vf.gui.Utils.formatRelative(stageH, screenHeight);
    var stageSize = calculateStageSize(scaleMode, screenWidth, screenHeight, stageW || canvas.width, stageH || canvas.height);
    var stageWidth = stageSize.stageWidth;
    var stageHeight = stageSize.stageHeight;
    var displayWidth = stageSize.displayWidth;
    var displayHeight = stageSize.displayHeight;
    if (canvas.style.transformOrigin) {
        canvas.style.transformOrigin = '0% 0% 0px';
    }
    else {
        canvas.style.webkitTransformOrigin = '0% 0% 0px';
    }
    var rotation = 0;
    if (scaleMode && scaleMode !== "noScale" /* NO_SCALE */) {
        canvas.style.top = top + ((screenHeight - displayHeight) / 2) + "px";
        canvas.style.left = (screenWidth - displayWidth) / 2 + "px";
    }
    var scalex = displayWidth / stageWidth;
    var scaley = displayHeight / stageHeight;
    var canvasScaleX = scalex * canvasScaleFactor;
    var canvasScaleY = scaley * canvasScaleFactor;
    if (!isWebGl) {
        canvasScaleX = Math.ceil(canvasScaleX);
        canvasScaleY = Math.ceil(canvasScaleY);
    }
    var m = new vf.Matrix();
    m.identity();
    m.scale(scalex / canvasScaleX, scaley / canvasScaleY);
    m.rotate(rotation * Math.PI / 180);
    canvas.style.position = 'absolute';
    if (canvas.style.transform) {
        canvas.style.transform = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.tx + "," + m.ty + ")";
    }
    else {
        canvas.style.webkitTransform = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.tx + "," + m.ty + ")";
    }
    app.renderer.resize(stageWidth * scalex, stageHeight * scaley);
    // canvas.style.border = '5px solid red';
    stage.container.hitArea = new vf.Rectangle(0, 0, stageWidth, stageHeight);
    stage.width = stageWidth;
    stage.height = stageWidth;
    stage.scaleX = canvasScaleX / canvasScaleFactor;
    stage.scaleY = canvasScaleY / canvasScaleFactor;
    return { width: stageWidth * scalex, height: stageHeight * scaley, scaleX: canvasScaleX, scaleY: canvasScaleY };
}
exports.calculateUpdatePlayerSize = calculateUpdatePlayerSize;


/***/ }),

/***/ "./src/utils/setInteractiveElement.ts":
/*!********************************************!*\
  !*** ./src/utils/setInteractiveElement.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable max-len */
/* eslint-disable max-statements-per-line */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setInteractiveElement = void 0;
/**
 * 设置事件绑定目标
 * @param stage
 * @param parame
 */
function setInteractiveElement(stage, parame) {
    stage.originalEventPreventDefault = true;
    var element = document.getElementById('drawCanvas');
    if (parame.className && parame.className !== 'canvas-container') { // 优先自定义className， 'canvas-container'是历史遗留默认值
        element = document.getElementsByClassName(parame.className)[0];
        if (element) {
            // 为了解决slider画线默认是黑色，线宽是1的问题
            // (element as any).width = element.offsetWidth;
            // (element as any).height = element.offsetHeight;
        }
    }
    if (parame.htmlElement) {
        element = parame.htmlElement;
    }
    if (element === null || element === undefined) {
        var canvasContainer = document.getElementsByClassName('canvas-container')[0];
        if (canvasContainer && canvasContainer.children[1]) {
            element = canvasContainer.children[1];
        }
    }
    if (element === null || element === undefined) {
        // 无法找到画线，可能是回放模式\
        stage.sendToPlayer({
            code: 'E0002',
            level: 'error',
            target: 'setTargetElement',
            data: [parame],
        });
        return;
    }
    var renderer = stage.app.renderer;
    var interaction = renderer.plugins.interaction;
    interaction.setTargetElement(element, parame.resolution || renderer.resolution);
    interaction.cursorStyles.default = element.style.cursor;
    if (parame.defaultPointer) {
        interaction.cursorStyles.pointer = parame.defaultPointer;
    }
    element.style.display = 'none';
    setTimeout(function () { if (element) {
        element.style.display = '';
    } }, 60); // BUG 边检检查
}
exports.setInteractiveElement = setInteractiveElement;


/***/ }),

/***/ "./src/vf-gui.ts":
/*!***********************!*\
  !*** ./src/vf-gui.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.gui = void 0;
/* eslint-disable @typescript-eslint/no-namespace */
var gui = __webpack_require__(/*! ./UI */ "./src/UI.ts");
exports.gui = gui;
if (window.vf === undefined) {
    window.vf = {};
}
window.vf.gui = gui;
window.vf.gui.VERSION = "3.0.3";


/***/ })

/******/ });
});
//# sourceMappingURL=gui.js.map